<!doctype html>
<html lang="ro">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quiz Interactiv Java</title>
    <style>
      :root {
        --primary-color: #2c3e50;
        --accent-color: #3498db;
        --success-color: #27ae60;
        --error-color: #c0392b;
        --bg-color: #f4f7f6;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--bg-color);
        color: #333;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        line-height: 1.6;
      }

      header {
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 2px solid var(--primary-color);
        padding-bottom: 20px;
      }

      h1 {
        color: var(--primary-color);
        margin-bottom: 10px;
      }

      .stats {
        font-size: 0.9em;
        color: #666;
        margin-top: 10px;
      }

      .quiz-selector-container {
        margin: 20px 0;
      }

      select {
        padding: 8px 12px;
        font-size: 1rem;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: white;
        cursor: pointer;
      }

      .quiz-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .question-card {
        padding: 25px;
        border-bottom: 1px solid #eee;
      }

      .question-text {
        font-weight: 600;
        font-size: 1.1em;
        margin-bottom: 15px;
      }

      pre {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid var(--accent-color);
        overflow-x: auto;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 0.9em;
        margin-bottom: 15px;
      }

      .options {
        list-style: none;
        padding: 0;
      }

      .option-item {
        margin-bottom: 10px;
      }

      .option-label {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .option-label:hover {
        background-color: #f0f8ff;
        border-color: var(--accent-color);
      }

      input[type="radio"] {
        margin-right: 15px;
        transform: scale(1.2);
      }

      .controls {
        padding: 20px;
        text-align: center;
        background: #eee;
      }

      button {
        background-color: var(--accent-color);
        color: white;
        border: none;
        padding: 12px 30px;
        font-size: 1em;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.3s;
      }

      button:hover {
        background-color: #2980b9;
      }

      .result-box {
        display: none;
        padding: 15px;
        margin-top: 10px;
        border-radius: 5px;
        font-weight: bold;
      }

      .correct-answer {
        background-color: rgba(39, 174, 96, 0.1);
        border: 1px solid var(--success-color);
        color: var(--success-color);
      }

      .wrong-answer {
        background-color: rgba(192, 57, 43, 0.1);
        border: 1px solid var(--error-color);
        color: var(--error-color);
      }

      .explanation {
        margin-top: 5px;
        font-weight: normal;
        font-size: 0.9em;
        color: #555;
      }

      .code-wrapper {
        position: relative;
      }

      .copy-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 4px 8px;
        font-size: 0.8rem;
        background-color: #f8f9fa;
        color: #333;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        z-index: 5;
        transition: all 0.2s;
        line-height: 1.2;
      }

      .copy-btn:hover {
        background-color: #e2e6ea;
        border-color: #adb5bd;
      }

      /* Highlight classes for results */
      .option-label.correct {
        background-color: #d4edda;
        border-color: #c3e6cb;
      }

      .option-label.incorrect {
        background-color: #f8d7da;
        border-color: #f5c6cb;
      }
    </style>
  </head>

  <body>
    <header>
      <h1 id="quizTitle">Examen Java - Ianuarie 2021</h1>
      <div class="quiz-selector-container">
        <label for="quizSelector">Alege testul: </label>
        <select id="quizSelector" onchange="switchQuiz(this.value)">
          <option value="examExCB">Examen exemplu - CB</option>
          <option value="examCA2021">Examen CA 2021</option>
          <option value="examCA2020">Examen CA 2020</option>
          <option value="javaBasics">Java Basics (Test)</option>
          <option value="setNou1">Set Nou 1 - Stil CB</option>
          <option value="setNou2">Set Nou 2 - Stil CB</option>
          <option value="setNou3">Set Nou 3 - Avansat</option>
          <option value="setNou4">Set Nou 4 - Avansat</option>
        </select>
      </div>
      <div class="stats">Quiz Interactiv</div>
    </header>

    <div class="quiz-container" id="quiz">
      <!-- Întrebările vor fi generate aici prin JS -->
    </div>

    <div class="controls">
      <div id="finalScore" style="font-weight: bold; font-size: 1.2em"></div>
    </div>

    <script>
      // --- DATA ---

      const questionsExamCBExemplu = [
        {
          id: 1,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. package pkgA;\n2. public class Foo {\n3.     int a = 5;\n4.     protected int b = 6;\n5.     public int c = 7;\n6. }\n\n3. package pkgB;\n4. import pkgA.*;\n5. public class Baz {\n6.     public static void main(String[] args) {\n7.         Foo f = new Foo();\n8.         System.out.print(" " + f.a);\n9.         System.out.print(" " + f.b);\n10.         System.out.print(" " + f.c);\n11.     }\n12. }',
          options: [
            "5 6 7",
            "5 urmat de eroare",
            "Eroare de compilare la linia 8",
            "Eroare de compilare la linia 10",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va rula cu succes deoarece câmpul 'a' (cu modificator implicit/package-private) nu este accesibil din pachetul pkgB.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Eroarea va apărea mai devreme, la compilare, nu la rulare.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Câmpul 'a' are modificatorul implicit (package-private) și nu poate fi accesat din pachetul pkgB. Eroarea de compilare apare la linia 8 când se încearcă accesarea lui f.a.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Câmpul 'c' este public și poate fi accesat fără probleme. Eroarea apare mai devreme, la linia 8.",
            },
          ],
        },
        {
          id: 2,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "4. class Announce {\n5.     public static void main(String[] args) {\n6.         for(int __x = 0; __x < 3; __x++) ;\n7.         int #lb = 7;\n8.         long [] x [5];\n9.         Boolean []ba[];\n10.         enum Traffic { RED, YELLOW, GREEN };\n11.     }\n12. }",
          options: [
            "Compilare cu succes",
            "Eroare de compilare la linia 6",
            "Eroare de compilare la linia 8",
            "Eroare de compilare la linia 10",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Există eroare de compilare la linia 7 din cauza caracterului '#' în numele variabilei.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 6 este validă - variabilele pot începe cu underscore.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. La linia 7, identificatorul '#lb' este invalid deoarece caracterul '#' nu este permis în numele variabilelor Java.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Enum-urile locale nu pot fi declarate în interiorul metodelor, dar eroarea apare mai devreme la linia 7.",
            },
          ],
        },
        {
          id: 3,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: 'class Top {\n    public Top(String s) { System.out.print("B"); }\n}\npublic class Bottom2 extends Top {\n    public Bottom2(String s) { System.out.print("D");}\n    public static void main(String [] args) {\n        new Bottom2("C");\n        System.out.println(" ");\n    }\n}',
          options: ["Eroare de compilare", "BD", "DB", "BDC"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Constructorul clasei Bottom2 nu apelează explicit super(s), dar clasa Top nu are un constructor implicit (fără parametri). Java cere apel explicit la super(String) în constructorul Bottom2.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va compila din cauza lipsei apelului explicit la constructorul părintelui.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va compila din cauza lipsei apelului explicit la constructorul părintelui.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va compila din cauza lipsei apelului explicit la constructorul părintelui.",
            },
          ],
        },
        {
          id: 4,
          text: "Care afirmatie este corecta?",
          description: null,
          code: null,
          options: [
            "Coeziunea este un principiu de programare orientata obiect asociat cu ascunderea detaliilor de implementare",
            "Coeziunea este un principiu de programare orientata obiect prin care functionalitatile unei clase sunt expuse printr-un API",
            "Coeziunea este un principiu de programare orientata obiect prin care scopul unei clase se rezuma exclusiv la un punct de interes bine definit",
            "Coeziunea este un principiu de programare orientata obiect prin care un obiect poate fi perceput ca avand multiple tipuri",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Această definiție descrie mai degrabă encapsularea, nu coeziunea.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Acest principiu se referă la interfața publică a clasei, nu la coeziune.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Coeziunea înseamnă că o clasă ar trebui să aibă o singură responsabilitate bine definită și toate metodele și atributele ei să contribuie la acea responsabilitate.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Această definiție descrie polimorfismul, nu coeziunea.",
            },
          ],
        },
        {
          id: 5,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. class MyException extends RuntimeException { }\n2. public class Houdini {\n3.     public static void main(String[] args) throws Exception {\n4.         throw new MyException();\n5.         System.out.println("success");\n6.     }\n}',
          options: [
            "succes",
            "Eroare de compilare la linia 3",
            "Eroare de compilare la linia 4",
            "Eroare de compilare la linia 5",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Excepția este aruncată la linia 4, iar linia 5 nu va fi niciodată atinsă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Declararea 'throws Exception' este validă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Aruncarea MyException (care extinde RuntimeException) este validă.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Linia 5 nu poate fi atinsă niciodată (unreachable code) deoarece linia 4 aruncă întotdeauna o excepție. Aceasta este o eroare de compilare.",
            },
          ],
        },
        {
          id: 6,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. class Alpha {\n4.     static String s = " ";\n5.     protected Alpha() { s += "alpha "; }\n6. }\n7. class SubAlpha extends Alpha {\n8.     private SubAlpha() { s += "sub "; }\n9. }\n10. public class SubSubAlpha extends Alpha {\n11.     private SubSubAlpha() { s += "subsub "; }\n12.     public static void main(String[] args) {\n13.         new SubSubAlpha();\n14.         System.out.println(s);\n15.     }\n16. }',
          options: [
            "subsub",
            "sub subsub",
            "alpha subsub",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorul clasei părinte Alpha este apelat automat înainte de constructorul SubSubAlpha.",
            },
            {
              isCorrect: false,
              explanation: "Fals. SubSubAlpha extinde Alpha, nu SubAlpha.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Când se creează un obiect SubSubAlpha, mai întâi se apelează constructorul Alpha (adăugând 'alpha '), apoi constructorul SubSubAlpha (adăugând 'subsub '). Rezultatul este 'alpha subsub'.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Programul compilează și rulează corect.",
            },
          ],
        },
        {
          id: 7,
          text: "Cate obiecte sunt eligibile sa fie colectate de GC la atingerea secventei indicate?",
          description: null,
          code: "class CardBoard {\n    Short story = 200;\n    CardBoard go(CardBoard cb) {\n        cb = null;\n        return cb;\n    }\n    public static void main(String[] args) {\n        CardBoard c1 = new CardBoard();\n        CardBoard c2 = new CardBoard();\n        CardBoard c3 = c1.go(c2);\n        c1 = null;\n        // secventa rulare GC\n    }\n}",
          options: ["0", "1", "2", "Imposibil de determinat cu exactitate"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Există obiecte care nu mai au referințe și sunt eligibile pentru GC.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Mai mult de un obiect este eligibil pentru colectare.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. c1 este setat la null, deci primul obiect CardBoard nu mai are referințe. c3 primește null din metoda go(), deci al doilea obiect CardBoard (c2) nu mai are referințe. Ambele obiecte CardBoard sunt eligibile pentru GC.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Numărul de obiecte eligibile poate fi determinat analizând referințele.",
            },
          ],
        },
        {
          id: 8,
          text: "Care eroare poate fi prinsa in cadrul urmatorului bloc?",
          description: null,
          code: 'try { int x = Integer.parseInt("unu"); }',
          options: [
            "NumberFormatException",
            "ClassCastException",
            "ArrayIndexOutOfBoundsException",
            "IllegalStateException",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Integer.parseInt() aruncă NumberFormatException când string-ul nu poate fi convertit la un număr valid.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ClassCastException apare la conversii invalide de tip (cast), nu la parsarea string-urilor.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ArrayIndexOutOfBoundsException apare la accesarea unui index invalid într-un array, nu la parsarea string-urilor.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. IllegalStateException se aruncă când o metodă este apelată la un moment nepotrivit, nu la parsarea string-urilor.",
            },
          ],
        },
        {
          id: 9,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class KaChung {\n4.     public static void main(String[] args) {\n5.         String s = "";\n6.         if(Integer.parseInt("011") == Integer.parseInt("9")) s += 1;\n7.         if(021 == Integer.valueOf("17")) s += 2;\n8.         if(1024 == new Integer(1024)) s += 3;\n9.         System.out.println(s);\n10.     }\n}',
          options: ["2", "3", "13", "23"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Mai multe condiții sunt adevărate.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu doar condiția de la linia 8 este adevărată.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Condiția de la linia 6 nu este adevărată (11 != 9).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Linia 6: Integer.parseInt('011') = 11, nu 9, deci fals. Linia 7: 021 (octal) = 17 (decimal), adevărat, s += '2'. Linia 8: auto-unboxing face 1024 == 1024, adevărat, s += '3'. Rezultat: '23'.",
            },
          ],
        },
        {
          id: 10,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public static void main(String[] args) {\n4.     try {\n5.         throw new Error();\n6.     }\n7.     catch (Error e) {\n8.         try { throw new RuntimeException(); }\n9.         catch (Throwable t) { }\n10.     }\n11.     System.out.println("oioioi");\n12. }',
          options: [
            "oioioi",
            "Eroare de compilare la linia 5",
            "Eroare de compilare la linia 8",
            "Eroare de compilare la linia 9",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Excepția Error este prinsă la linia 7. În interiorul blocului catch, se aruncă RuntimeException la linia 8, care este prinsă de catch-ul de la linia 9. Programul continuă normal și afișează 'oioioi' la linia 11.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Aruncarea unui Error este permisă în Java.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sintaxa este validă - try-catch poate fi scris pe o singură linie când este simplu.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sintaxa este validă - catch-ul prinde corect excepția aruncată în try-ul de pe aceeași linie.",
            },
          ],
        },
        {
          id: 11,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: 'class Bird {\n    { System.out.print("b1 "); }\n    public Bird() { System.out.print("b2 "); }\n}\nclass Raptor extends Bird {\n    static { System.out.print("r1 "); }\n    public Raptor() { System.out.print("r2 "); }\n    { System.out.print("r3 "); }\n    static { System.out.print("r4 "); }\n}\nclass Hawk extends Raptor {\n    public static void main(String[] args) {\n        System.out.print("pre ");\n        new Hawk();\n        System.out.println("hawk ");\n    }\n}',
          options: [
            "pre b1 b2 r3 r2 hawk",
            "pre b2 b1 r2 r3 hawk",
            "pre b2 b1 r2 r3 hawk r1 r4",
            "r1 r4 pre b1 b2 r3 r2 hawk",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile static se execută înaintea blocului main și înainte de pre.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile static se execută înaintea blocului main.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile static se execută la începutul încărcării clasei, nu la final.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Ordinea de execuție: (1) Blocurile static ale Raptor (r1 r4) când clasa Hawk este încărcată, (2) main începe (pre), (3) se creează Hawk: bloc de inițializare Bird (b1), constructor Bird (b2), bloc de inițializare Raptor (r3), constructor Raptor (r2), (4) afișare hawk.",
            },
          ],
        },
        {
          id: 12,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Ouch {\n4.     static int ouch = 7;\n5.     public static void main(String[] args) {\n6.         new Ouch().go(ouch);\n7.         System.out.print(" " + ouch);\n8.     }\n9.     void go(int ouch) {\n10.         ouch++;\n11.         for(int ouch = 3; ouch < 6; ouch++)\n12.             ;\n13.         System.out.print(" " + ouch);\n14.     }\n15. }',
          options: ["Eroare de compilare", "5 7", "5 8", "8 8"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Eroare de compilare la linia 11: variabila 'ouch' este deja declarată ca parametru al metodei go() la linia 9. Nu se poate redeclara în bucla for din același scope.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va compila din cauza redeclarării variabilei 'ouch'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va compila din cauza redeclarării variabilei 'ouch'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul nu va compila din cauza redeclarării variabilei 'ouch'.",
            },
          ],
        },
        {
          id: 13,
          text: "Care afirmatie este corecta in momentul atingerii liniei 14?",
          description: null,
          code: "3. class Dozens {\n4.     int[] dz = {1,2,3,4,5,6,7,8,9,10,11,12};\n5. }\n6. public class Eggs {\n7.     public static void main(String[] args) {\n8.         Dozens [] da = new Dozens[3];\n9.         da[0] = new Dozens();\n10.         Dozens d = new Dozens();\n11.         da[1] = d;\n12.         d = null;\n13.         da[1] = null;\n14.         // secventa rulare GC\n15.     }\n16. }",
          options: [
            "1 obiect este preluat de GC",
            "2 obiecte sunt preluate de GC",
            "3 obiecte au fost create",
            "4 obiecte au fost create",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Două obiecte Dozens nu mai au referințe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Obiectul creat la linia 10 (asignat inițial lui d, apoi lui da[1]) nu mai are referințe după liniile 12 și 13. da[0] încă există, dar da[2] este null. Deci 2 obiecte Dozens sunt eligibile pentru GC: cel de la linia 10 și cel de la da[2] care nu a fost niciodată inițializat (dar array-ul da nu contează ca obiect Dozens).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Au fost create mai mult de 3 obiecte (2 obiecte Dozens + array-ul da + array-urile interne dz).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Au fost create doar 2 obiecte Dozens, nu 4.",
            },
          ],
        },
        {
          id: 14,
          text: "Pornind de la declaratia?\n\nSi avand urmatoarele secvente de cod:\n\nCare afirmatie este corecta",
          description:
            "F1. if(f1 == f2)\nF2. if(f1 == f2[2][1])\nF3. if(x == f2[0][0])\nF4. if(f1 == f2[1,1])\nF5. if(f3 == f2[2])",
          code: '1. class Comp {\n2.     public static void main(String[] args) {\n3.         float f1 = 2.3f;\n4.         float[][] f2 = {{42.0f}, {1.7f, 2.3f}, {2.6f, 2.7f}};\n5.         float[] f3 = {2.7f};\n6.         Long x = 42L;\n7.         // inserati o secventa de cod aici\n8.         System.out.println("true");\n9.     }\n10. }',
          options: [
            "1 secv va compila si 1 secv va intoarce true",
            "2 secv vor compila si 1 secv va intoarce true",
            "3 secv vor compila si 1 secv va intoarce true",
            "3 secv vor compila si 2 secv vor intoarce true",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Mai multe de o secvență vor compila.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Mai mult de 2 secvențe vor compila.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Compilează: F2 (compară float cu float, dar 2.3f != 2.7f), F3 (compară Long cu float prin unboxing, 42L == 42.0f adevărat), F5 (compară referințe de array-uri, false). F1 nu compilează (float vs float[][]), F4 nu compilează (sintaxă invalidă f2[1,1]). 3 compilează, doar F3 returnează true.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Doar o secvență va returna true.",
            },
          ],
        },
        {
          id: 15,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. interface Vessel { }\n4. interface Toy { }\n5. class Boat implements Vessel { }\n6. class Speedboat extends Boat implements Toy { }\n7. public class Tree {\n8.     public static void main(String[] args) {\n9.         String s = "0";\n10.         Boat b = new Boat();\n11.         Boat b2 = new Speedboat();\n12.         Speedboat s2 = new Speedboat();\n13.         if((b instanceof Vessel) && (b2 instanceof Toy)) s += "1";\n14.         if((s2 instanceof Vessel) && (s2 instanceof Toy)) s += "2";\n15.         System.out.println(s);\n16.     }\n17. }',
          options: ["0", "01", "02", "012"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Cel puțin una dintre condiții este adevărată.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 13: b instanceof Vessel este true, dar b2 (declarat ca Boat) referă un Speedboat care implementează Toy, deci (b2 instanceof Toy) este true. Dar și linia 14 este true.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ambele condiții de la liniile 13 și 14 sunt adevărate.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Linia 13: b instanceof Vessel (true) && b2 instanceof Toy (true, b2 referă Speedboat care implementează Toy), s devine '01'. Linia 14: s2 instanceof Vessel (true, Speedboat extinde Boat care implementează Vessel) && s2 instanceof Toy (true), s devine '012'.",
            },
          ],
        },
        {
          id: 16,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Circles {\n4.     public static void main(String[] args) {\n5.         int[] ia = {1,3,5,7,9};\n6.         for(int x : ia) {\n7.             for(int j = 0; j < 3; j++) {\n8.                 if(x > 4 && x < 8) continue;\n9.                 System.out.print(" " + x);\n10.                 if(j == 1) break;\n11.                 continue;\n12.             }\n13.             continue;\n14.         }\n15.     }\n16. }',
          options: ["1 3 9", "5 5 7 7", "1 3 3 9 9", "1 1 3 3 9 9"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Fiecare valoare care trece de linia 8 este afișată de 2 ori.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Valorile 5 și 7 sunt sărite de continue la linia 8.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Fiecare valoare eligibilă este afișată de 2 ori, nu o dată.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Pentru x=1,3,9 (nu sunt între 4 și 8): se printează x la j=0, apoi la j=1 se printează din nou și se face break. Pentru x=5,7 (sunt între 4 și 8): continue sare printarea. Rezultat: 1 1 3 3 9 9.",
            },
          ],
        },
        {
          id: 17,
          text: "Care afirmatie este corecta?",
          description: null,
          code: '3. public class Theory {\n4.     public static void main(String[] args) {\n5.         String s1 = "abc";\n6.         String s2 = s1;\n7.         s1 += "d";\n8.         System.out.println(s1 + " " + s2 + " " + (s1==s2));\n9.\n10.         StringBuffer sb1 = new StringBuffer("abc");\n11.         StringBuffer sb2 = sb1;\n12.         sb1.append("d");\n13.         System.out.println(sb1 + " " + sb2 + " " + (sb1==sb2));\n14.     }\n15. }',
          options: [
            "Prima linie este abc abc false",
            "Prima linie este abcd abc false",
            "A doua linie este abc abc false",
            "A doua linie este abcd abc false",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. După s1 += 'd', s1 devine 'abcd', nu 'abc'.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. String-urile sunt imutabile. s1 += 'd' creează un nou String 'abcd', iar s2 rămâne 'abc'. s1 și s2 sunt referințe diferite, deci s1==s2 este false. Prima linie: abcd abc false.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. StringBuffer este mutabil. sb1 și sb2 referă același obiect, care devine 'abcd'. sb1==sb2 este true.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. sb1 și sb2 referă același obiect StringBuffer, deci sb1==sb2 este true, nu false.",
            },
          ],
        },
        {
          id: 18,
          text: "Care declaratie este admisibila?",
          description: null,
          code: "public static void main(String[] args) {\n    // inserati declaratia\n    for (int i = 0; i <= 10; i++) {\n        List<Integer> row = new ArrayList<Integer>();\n        for (int j = 0; j <= 10; j++)\n            row.add(i * j);\n        table.add(row);\n    }\n    for (List<Integer> row : table)\n        System.out.println(row);\n}",
          options: [
            "List<List<Integer>> table = new List<List<Integer>>();",
            "List<List<Integer>> table = new ArrayList<List<Integer>>();",
            "List<List<Integer>> table = new ArrayList<ArrayList<Integer>>();",
            "List<List, Integer> table = new List<List, Integer>();",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. List este o interfață și nu poate fi instanțiată direct cu 'new List<>()'.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Declarația este corectă: List<List<Integer>> este tipul variabilei, iar ArrayList<List<Integer>>() este implementarea concretă. Tipul generic al ArrayList trebuie să fie compatibil cu tipul declarat.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ArrayList<ArrayList<Integer>>() nu este compatibil cu List<List<Integer>> din punct de vedere al tipurilor generice (generics nu sunt covariante).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sintaxa List<List, Integer> este invalidă. Tipurile generice nu folosesc virgule în acest mod.",
            },
          ],
        },
        {
          id: 19,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. import java.util.*;\n4. class Dog { int size; Dog(int s) { size = s; } }\n5. public class FirstGrade {\n6.     public static void main(String[] args) {\n7.         TreeSet<Integer> i = new TreeSet<Integer>();\n8.         TreeSet<Dog> d = new TreeSet<Dog>();\n9.\n10.         d.add(new Dog(1)); d.add(new Dog(2)); d.add(new Dog(1));\n11.         i.add(1); i.add(2); i.add(1);\n12.         System.out.println(d.size() + " " + i.size());\n13.     }\n14. }',
          options: ["1 2", "2 2", "2 3", "Exceptie de rulare"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Programul va arunca o excepție la rulare.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Programul va arunca o excepție la rulare.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Programul va arunca o excepție la rulare.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. TreeSet necesită ca elementele să fie comparabile (să implementeze Comparable sau să se furnizeze un Comparator). Clasa Dog nu implementează Comparable, deci la adăugarea primului obiect Dog se va arunca ClassCastException.",
            },
          ],
        },
        {
          id: 20,
          text: "Care afirmatie este adevarata despre o metoda a unei clase interne?",
          description: null,
          code: null,
          options: [
            "Trebuie sa fie marcata final",
            "Poate fi marcata abstract",
            "Trebuie sa fi marcata publica",
            "Poate fi marcata static",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele claselor interne nu trebuie să fie marcate final în mod obligatoriu.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. O metodă a unei clase interne poate fi marcată abstract, ceea ce ar face ca clasa internă însăși să fie abstractă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele claselor interne pot avea orice modificator de acces (private, protected, public, package-private).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele claselor interne non-statice nu pot fi statice. Doar clasele interne statice pot avea metode statice.",
            },
          ],
        },
        {
          id: 21,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class HorseTest {\n2.     public static void main(String[] args) {\n3.         class Horse {\n4.             public String name;\n5.             public Horse(String s) {\n6.                 name = s;\n7.             }\n8.         }\n9.         Object obj = new Horse("Zippo");\n10.         System.out.println(obj.name);\n11.     }\n12. }',
          options: [
            "Exceptie de rulare la linia 10",
            "Eroare de compilare la linia 3",
            "Zippo",
            "Eroare de compilare la linia 10",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Eroarea apare la compilare, nu la rulare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Declararea unei clase locale în metodă este permisă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Programul nu va compila.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. obj este declarat de tip Object, care nu are câmpul 'name'. Deși obj referă un obiect Horse, compilatorul verifică tipul declarat. Pentru a accesa 'name', ar fi necesară conversie: ((Horse)obj).name. Eroare de compilare la linia 10.",
            },
          ],
        },
        {
          id: 22,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '5. class A { void m() { System.out.println("outer"); } }\n6. public class TestInners {\n7.     public static void main(String[] args) {\n8.         new TestInners().go();\n9.     }\n10.     void go() {\n11.         new A().m();\n12.         class A { void m() { System.out.println("inner"); } }\n13.     }\n14.     class A { void m() { System.out.println("middle"); } }\n15. }',
          options: ["inner", "middle", "outer", "Exceptie la rulare"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Clasa A locală (inner) este declarată după apelul la linia 11, deci nu este vizibilă la momentul apelului.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. La linia 11, new A() se referă la clasa member A (middle) din linia 14, care este vizibilă în metoda go(). Clasa locală A din linia 12 nu este vizibilă încă, iar clasa outer A nu este vizibilă direct în metoda de instanță. Se afișează 'middle'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Clasa outer A nu este cea mai apropiată în scope-ul metodei go().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul compilează și rulează fără excepții.",
            },
          ],
        },
        {
          id: 23,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "3. public class Navel {\n4.     private int size = 7;\n5.     private static int length = 3;\n6.     public static void main(String[] args) {\n7.         new Navel().go();\n8.     }\n9.     void go() {\n10.         int size = 5;\n11.         System.out.println(new Gazer().adder());\n12.     }\n13.     class Gazer {\n14.         int adder() { return size * length; }\n15.     }\n16. }",
          options: [
            "15",
            "21",
            "Eroare de compilare la linia 10",
            "Exceptie la rulare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Metoda adder() accesează câmpul size al clasei outer Navel (7), nu variabila locală size din go().",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Clasa internă Gazer are acces la câmpurile clasei outer Navel. În metoda adder(), 'size' se referă la Navel.this.size = 7 (nu la variabila locală din go()), iar 'length' = 3. Rezultat: 7 * 3 = 21.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu există eroare de compilare - variabilele locale pot avea același nume cu câmpurile clasei.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Programul rulează fără excepții.",
            },
          ],
        },
        {
          id: 24,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: 'class MyThread extends Thread {\n    MyThread() {\n        System.out.print(" MyThread");\n    }\n    public void run() { System.out.print(" bar"); }\n    public void run(String s) { System.out.print(" baz"); }\n}\npublic class TestThreads {\n    public static void main (String [] args) {\n        Thread t = new MyThread() {\n            public void run() { System.out.print(" foo"); }\n        };\n        t.start();\n    }\n}',
          options: ["foo", "MyThread foo", "MyThread bar", "foo bar"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorul MyThread se execută și afișează ' MyThread'.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Se creează o instanță anonimă de MyThread care suprascrie run(). Mai întâi se apelează constructorul MyThread (afișează ' MyThread'), apoi când thread-ul pornește, se execută metoda run() suprascrisă (afișează ' foo'). Rezultat: MyThread foo.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metoda run() este suprascrisă în clasa anonimă, deci nu se va executa run() din MyThread.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorul MyThread se execută și afișează ' MyThread'.",
            },
          ],
        },
        {
          id: 25,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "1. public class Argue {\n2.     static boolean b;\n3.     static int x = 0;\n4.     public static void main(String[] args) {\n5.         int guess = (int)(Math.random() * 5);\n6.         if(guess < 0) assert false;\n7.         assert b = true;\n8.         assert x = 0;\n9.         assert x == 0;\n10.     }\n}",
          options: [
            "Eroare de compilare la linia 6",
            "Eroare de compilare la linia 7",
            "Eroare de compilare la linia 8",
            "Eroare de compilare la linia 9",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 6 este validă - 'assert false' este o expresie boolean corectă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 7 este validă - 'b = true' este o expresie de atribuire care returnează true (boolean).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. La linia 8, 'x = 0' este o expresie de atribuire care returnează int (0), nu boolean. Assert necesită o expresie boolean. Eroare de compilare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 9 este validă - 'x == 0' este o expresie boolean corectă.",
            },
          ],
        },
        {
          id: 26,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. import java.util.*;\n3. public class AndOver {\n4.     public static void main(String[] args) {\n5.         List g = new ArrayList();\n6.         g.add(new Gaited("Eyra"));\n7.         g.add(new Gaited("Vafi"));\n8.         g.add(new Gaited("Andi"));\n9.         Iterator i2 = g.iterator();\n10.         while(i2.hasNext()) {\n11.             System.out.print(i2.next().name + " ");\n12.         }\n13.     }\n}\n13. class Gaited {\n14.     public String name;\n15.     Gaited(String n) { name = n; }\n16. }',
          options: [
            "Eroare de rulare",
            "Andi Eyra Vafi",
            "Eyra Vafi Andi",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Programul compilează, dar va avea eroare la rulare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul va avea eroare la compilare sau la rulare înainte de a afișa.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Programul va avea eroare la compilare sau la rulare înainte de a afișa.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. La linia 11, i2.next() returnează Object (deoarece List nu este parametrizat cu generics). Object nu are câmpul 'name', deci este necesară conversie (cast). Eroare de compilare: cannot find symbol - variable name.",
            },
          ],
        },
        {
          id: 27,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. public class Maize {\n3.     public static void main(String[] args) {\n4.         String s = "12";\n5.         s.concat("ab");\n6.         s = go(s);\n7.         System.out.println(s);\n8.     }\n9.     static String go(String s) {\n10.         s.concat("56");\n11.         return s;\n12.     }\n}',
          options: ["ab", "12", "ab56", "12ab56"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. String-urile sunt imutabile, iar rezultatul concat() nu este asignat.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. String-urile sunt imutabile. Metodele concat() de la liniile 5 și 10 creează noi string-uri, dar rezultatul nu este asignat nicăieri. s rămâne '12' pe tot parcursul execuției.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Valorile concatenate nu sunt păstrate deoarece rezultatul concat() nu este asignat.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Valorile concatenate nu sunt păstrate deoarece rezultatul concat() nu este asignat.",
            },
          ],
        },
        {
          id: 28,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '13. int count = 0;\n14. outer:\n15. for(int x = 0; x < 5; x++) {\n16.     middle:\n17.     for(int y = 0; y < 5; y++) {\n18.         if(y == 1) continue middle;\n19.         if(y == 3) break middle;\n20.         count++;\n21.     }\n22.     if(x > 2) continue outer;\n23.     count = count + 10;\n24. }\n25. System.out.println("count: " + count);',
          options: ["count: 33", "count: 40", "count: 45", "count: 65"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Calculul corect dă un rezultat diferit.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Pentru fiecare iterație x (0-4), bucla interioară execută count++ pentru y=0 și y=2 (y=1 face continue, y=3 face break), deci 2 incrementări per iterație exterioară = 10 total. Apoi count+=10 se execută doar pentru x=0,1,2 (când x>2 se face continue outer), deci 3×10 = 30. Total: 10 + 30 = 40.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Calculul nu ține cont de break-ul de la middle când y==3.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Calculul nu ține cont de continue outer când x>2.",
            },
          ],
        },
        {
          id: 29,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "5. boolean[] ba = {true, false};\n6. short[][] gr = {{1,2}, {3,4}};\n7. int i = 0;\n8. for( ; i < 10; ) i++;\n9. for(short s: gr) ;\n10. for(int j = 0, k = 10; k > j; ++j, k--) ;\n11. for(int j = 0; j < 3; System.out.println(j++)) ;\n12. for(Boolean b: ba) ;",
          options: [
            "Eroare de compilare la linia 8",
            "Eroare de compilare la linia 9",
            "Eroare de compilare la linia 10",
            "Eroare de compilare la linia 11",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 8 este un for valid cu toate cele 3 părți opționale.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. La linia 9, enhanced for încearcă să itereze peste gr care este short[][] (array 2D). Variabila s este declarată short, dar gr[i] este short[] (array 1D), nu short. Incompatibilitate de tipuri. Eroare de compilare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 10 este validă - se pot declara multiple variabile în inițializarea for-ului.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 11 este validă - System.out.println(j++) poate fi în secțiunea de update a for-ului.",
            },
          ],
        },
        {
          id: 30,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. public class Clover extends Harrier {\n3.     String bark() { return "feed me "; }\n4.     public static void main(String[] args) {\n5.         Dog[] dogs = new Dog[3];\n6.         dogs[0] = new Harrier();\n7.         dogs[1] = (Dog)new Clover();\n8.         dogs[2] = (Dog)new Harrier();\n9.         for(Dog d: dogs) System.out.print(d.bark());\n10.     }\n}\n11. class Dog { String bark() { return "bark "; } }\n12. class Harrier extends Dog { String bark() { return "woof "; } }',
          options: [
            "bark bark bark",
            "woof bark bark",
            "woof feed me woof",
            "Eroare de compilare la linia 6.",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Prin polimorfism, se apelează metodele suprascrise, nu metoda din Dog.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Toate cele trei elemente sunt instanțe de Harrier sau Clover, nu Dog direct.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. dogs[0] = Harrier → bark() returnează 'woof '. dogs[1] = Clover (extends Harrier) → bark() returnează 'feed me '. dogs[2] = Harrier → bark() returnează 'woof '. Rezultat: woof feed me woof.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 6 este validă - Harrier extinde Dog, deci conversie implicită este permisă.",
            },
          ],
        },
      ];

      const questionsExamenCa2021 = [
        {
          id: 1,
          text: "Având în vedere codul de mai jos, care dintre afirmațiile de mai jos sunt adevărate în ceea ce privește conceptul de imutabilitate aplicat în cazul clasei Student?",
          description:
            "1. Ambele câmpuri să fie final\n2. Să avem doar metode de tip getter pentru câmpuri\n3. Să avem metode de tip getter și setter pentru câmpuri\n4. În getter-ul pentru grades, trebuie să întoarcem o copie a obiectului grades\n5. În getter-ul pentru grades, putem să întoarcem pur și simplu grades",
          code: "class Student {\n    long id;\n    List<Double> grades;\n}",
          options: ["toate", "1, 2, 4", "1, 2, 5", "1, 3, 5"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Nu toate afirmațiile sunt adevărate. Afirmația 3 (să avem metode getter și setter) contravine principiului imutabilității, iar afirmația 5 (întoarcerea directă a listei grades) ar permite modificarea acesteia din exterior.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Pentru imutabilitate: câmpurile trebuie finale (1), doar getters (2), și getter pentru grades trebuie să returneze o copie (4), astfel încât obiectul grades să nu poată fi modificat din exterior.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 5 este greșită deoarece întoarcerea directă a referinței grades ar permite modificarea listei din exterior, compromițând imutabilitatea.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 3 (metode getter și setter) este greșită pentru imutabilitate, iar afirmația 5 permite modificarea obiectului grades din exterior.",
            },
          ],
        },
        {
          id: 2,
          text: "Care dintre afirmațiile de mai jos sunt adevărate?",
          description:
            "1. Într-un Set putem avea duplicate\n2. În LinkedHashMap se păstrează ordinea de inserție a elementelor\n3. Interfața Map extinde interfața Collection\n4. În TreeSet nu se păstrează ordinea de inserție a elementelor",
          code: null,
          options: ["toate", "2 și 4", "1, 2, 3", "1, 3"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmațiile 1 (Set permite duplicate) și 3 (Map extinde Collection) sunt false. Set nu permite duplicate, iar Map nu extinde Collection.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. LinkedHashMap păstrează ordinea de inserție a elementelor (2) și TreeSet nu păstrează ordinea de inserție, ci sortează elementele natural sau prin comparator (4).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 1 este greșită deoarece Set nu permite duplicate, iar afirmația 3 este greșită deoarece Map nu extinde interfața Collection.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ambele afirmații sunt false. Set nu permite duplicate (1) și Map nu extinde Collection (3).",
            },
          ],
        },
        {
          id: 3,
          text: "Care dintre următoarele afirmații despre clase abstracte în Java sunt false:",
          description:
            "1. Dacă derivăm o clasă abstractă și nu implementăm toate metodele abstracte, atunci clasă derivată trebuie de asemenea să fie abstractă\n2. Clasele abstracte pot avea constructori\n3. O clasă nu poate fi abstractă fără o metodă abstractă\n4. O clasă abstractă poate moșteni de la mai multe clase abstracte",
          code: null,
          options: ["1, 2", "1, 3", "3, 4", "1, 3, 4"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 1 este adevărată (o clasă care nu implementează toate metodele abstracte trebuie să fie abstractă), iar afirmația 2 este de asemenea adevărată (clasele abstracte pot avea constructori).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 1 este adevărată. Doar afirmația 3 este falsă în acest set.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Afirmația 3 este falsă deoarece o clasă poate fi abstractă fără metode abstracte. Afirmația 4 este falsă deoarece Java nu suportă moștenire multiplă - o clasă poate moșteni de la o singură clasă (abstractă sau nu).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 1 este adevărată - o clasă care nu implementează toate metodele abstracte trebuie să fie abstractă.",
            },
          ],
        },
        {
          id: 4,
          text: "Care dintre următoarele afirmații despre interfețe și clase abstracte sunt adevărate?",
          description:
            "1. O clasă poate moșteni în același timp mai multe clase abstracte\n2. O interfață poate moșteni mai multe interfețe în același timp\n3. O interfață poate moșteni o clasă abstractă care are doar metode abstracte\n4. O clasă poate implementa mai multe interfețe în același timp",
          code: null,
          options: ["1, 2, 3", "2, 4", "1, 2, 3, 4", "2, 3, 4"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 1 este falsă deoarece Java nu permite moștenire multiplă a claselor. Afirmația 3 este de asemenea falsă - o interfață nu poate moșteni o clasă.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. O interfață poate moșteni (extends) mai multe interfețe în același timp (2) și o clasă poate implementa (implements) mai multe interfețe simultan (4).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 1 este falsă (nu există moștenire multiplă în Java) și afirmația 3 este falsă (o interfață nu poate moșteni o clasă).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Afirmația 3 este falsă - o interfață nu poate moșteni o clasă abstractă. Interfețele pot moșteni doar alte interfețe.",
            },
          ],
        },
        {
          id: 5,
          text: "Care dintre următoarele afirmații e corectă?",
          description: null,
          code: null,
          options: [
            "Cuvântul final în fața unei metode arată faptul că acea metodă poate fi apelată doar în clasa respectivă",
            "Cuvântul final în fața unei clase înseamnă că nu poate fi instantiată",
            "Cuvântul final în fața unei variabile arată că acea variabilă poate fi asignată o singură dată",
            "Cuvântul final în fața unei variabile arată că acea variabilă nu poate fi moștenită",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Cuvântul final în fața unei metode înseamnă că metoda nu poate fi suprascrisă (overridden) în subclase, nu că poate fi apelată doar în clasa respectivă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Cuvântul final în fața unei clase înseamnă că clasa nu poate fi moștenită (extended), nu că nu poate fi instantiată.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Cuvântul final la o variabilă o transformă într-o constantă, ceea ce înseamnă că poate primi o valoare o singură dată și apoi nu mai poate fi modificată.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Variabilele nu se moștenesc în mod direct. Cuvântul final la o variabilă înseamnă că valoarea ei nu poate fi modificată după inițializare.",
            },
          ],
        },
        {
          id: 6,
          text: "Care dintre următoarele variante nu are legătură cu încapsularea?",
          description: null,
          code: null,
          options: [
            "expunerea unei interfețe de lucru cu obiectul",
            "accesul la membri privați folosind metode de tip getter și setter",
            "construirea de obiecte complexe și ascunderea modului lor de funcționare",
            "posibilitatea suprascrierii (overriding) metodelor",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Expunerea unei interfețe publice pentru lucrul cu obiectul este un aspect fundamental al încapsulării - ascundem detaliile interne și oferim doar metodele necesare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Getters și setters sunt instrumente cheie ale încapsulării, permițând accesul controlat la câmpurile private ale unei clase.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ascunderea detaliilor de implementare și expunerea doar a funcționalității este esența încapsulării.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Overriding-ul (suprascrierea metodelor) este legat de polimorfism, nu de încapsulare. Încapsularea se ocupă de ascunderea detaliilor interne și controlul accesului la date.",
            },
          ],
        },
        {
          id: 7,
          text: "Care este outputul următorului program?",
          description: null,
          code: 'public class Star {\n    private int shininess;\n\n    static void change(Star s, int newShine) {\n        s = new Star();\n        s.shininess = newShine;\n    }\n\n    public static void main() {\n        Star star = new Star();\n        System.out.print("Old shininess:" + star.shininess + "|");\n        change(star, newShine: 10);\n        System.out.println("New shininess:" + star.shininess);\n    }\n}',
          options: [
            "Old shininess: 0 | New shininess: 10",
            "Old shininess: 0 | New shininess: 0",
            "Old shininess: null | New shininess: 0",
            "Old shininess: null | New shininess: 10",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Parametrul s în metoda change este pasat prin valoare (copia referinței). Când creăm un nou obiect în metodă, modificăm doar copia locală, nu obiectul original star.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. În Java, parametrii sunt pasați prin valoare. Când s = new Star() este executat în change(), se creează un nou obiect și s (copia referinței)PointEază către el, dar obiectul original star rămâne neschimbat cu shininess = 0 (valoarea default pentru int).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Câmpul shininess este de tip int (tip primitiv), care are valoarea default 0, nu null. Null se aplică doar referințelor la obiecte.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Shininess este int, nu Object, deci nu poate fi null. De asemenea, modificarea din change() nu afectează obiectul original.",
            },
          ],
        },
        {
          id: 8,
          text: "Care instanțiere este corectă?",
          description: null,
          code: null,
          options: [
            "List<Integer> list = new ArrayList<Object>();",
            "ArrayList<Integer> list = new List<Integer>();",
            "List<Integer> list = new ArrayList<Integer>();",
            "ArrayList<Object> list = new ArrayList<Integer>();",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. List<Integer> nu este compatibil cu ArrayList<Object> chiar dacă Object este superclasă. În Java, generics nu sunt covariant - List<Object> nu este supertip pentru List<Integer>.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. List este o interfață și nu poate fi instantiată direct. Trebuie să instantiem o implementare concretă (ArrayList, LinkedList, etc.).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Tipul din stânga (List<Integer>) este interfața, iar tipul din dreapta (ArrayList<Integer>) este implementarea concretă. ArrayList implementează List, deci această atribuire este validă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ArrayList<Object> și ArrayList<Integer> nu sunt compatibile. Generics în Java sunt invariante - ArrayList<Integer> nu este subtip al ArrayList<Object>.",
            },
          ],
        },
        {
          id: 9,
          text: "Ce design pattern face ușoară separarea operațiilor de obiectele pe care se execută operațiile respective?",
          description: null,
          code: null,
          options: [
            "Builder Pattern",
            "Visitor Pattern",
            "Factory Pattern",
            "Observer Pattern",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Builder Pattern este folosit pentru construirea treptată a obiectelor complexe, nu pentru separarea operațiilor de obiecte.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Visitor Pattern permite definirea de noi operații fără a modifica clasele elementelor pe care operează. Separează algoritmul de structura obiectului, facilitând adăugarea de noi operații.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Factory Pattern se ocupă de crearea obiectelor fără a specifica clasa exactă, nu de separarea operațiilor de obiecte.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Observer Pattern definește o dependență one-to-many între obiecte pentru notificarea automată la schimbări de stare.",
            },
          ],
        },
        {
          id: 10,
          text: "Ce design pattern trebuie să folosim în caz că dorim ca un client să nu aibă rol în crearea unui entități după o preferință de a sa?",
          description: null,
          code: null,
          options: [
            "Singleton Pattern",
            "Factory Pattern",
            "Builder Pattern",
            "Observer Pattern",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Singleton Pattern asigură că o clasă are o singură instanță și oferă un punct global de acces la ea, nu se ocupă de crearea entităților după preferințe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Factory Pattern permite crearea obiectelor fără ca clientul să specifice clasa exactă. Clientul solicită un obiect pe baza unor criterii, iar factory-ul decide ce tip concret să instantieze.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Builder Pattern este folosit pentru construirea treptată a obiectelor complexe, dar clientul rămâne implicat în procesul de configurare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Observer Pattern se ocupă de notificarea automată a observatorilor când se schimbă starea unui subiect, nu de crearea obiectelor.",
            },
          ],
        },
        {
          id: 11,
          text: "Ce fel de Singleton este această secvență de cod?",
          description: null,
          code: "public class Database {\n    private static Database obj = null;\n\n    private Database() {\n    }\n\n    public static Database getInstance() {\n        if (obj == null) {\n            obj = new Database();\n        }\n        return obj;\n    }\n}",
          options: [
            "Singleton cu inițializare eager",
            "Singleton cu inițializare lazy",
            "nu avem Singleton aici",
            "Singleton cu inițializare în blocuri statice",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Inițializarea eager înseamnă că instanța este creată la încărcarea clasei (ex: private static Database obj = new Database();). Aici instanța este creată la cerere.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Singleton cu lazy initialization - obiectul este creat doar când este solicitat prima dată prin getInstance(). Instanța este null inițial și se creează la primul apel al metodei.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Aceasta este o implementare clasică Singleton: constructor privat, instanță statică și metodă publică getInstance().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Inițializarea în blocuri statice ar folosi un bloc static {} pentru a crea instanța la încărcarea clasei. Aici instanța se creează în getInstance().",
            },
          ],
        },
        {
          id: 12,
          text: "Ce metode pot fi accesate din clasa MyTest?",
          description: null,
          code: "package test;\npublic class Test {\n    void execute1() {}\n    protected void execute2() {}\n    private void execute3() {}\n}\n\n....\npackage mytest;\npublic class MyTest extends Test {\n    public void execute2() {}\n}",
          options: [
            "execute1, execute2 din Test, execute2 din MyTest",
            "execute1, execute2 din Test, execute3, execute2 din MyTest",
            "execute2 din Test, execute2 din MyTest",
            "execute2 din MyTest",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. execute1() are acces default (package-private) și poate fi accesată doar în același pachet (test). MyTest este în pachetul mytest, deci nu are acces la execute1().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. execute1() nu este accesibilă (package-private din alt pachet), iar execute3() este privată și nu poate fi accesată din subclase.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. MyTest poate accesa: execute2() din Test (moștenită, protected), și execute2() din MyTest (override public). execute1() este package-private și nu este accesibilă din alt pachet. execute3() este privată.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. MyTest are acces și la execute2() din Test (metoda protected moștenită), nu doar la versiunea override.",
            },
          ],
        },
        {
          id: 13,
          text: "Ce reprezintă o metodă default în cadrul unei interfețe?",
          description: null,
          code: null,
          options: [
            "o metodă abstractă",
            "o metodă non-statică care este deja implementată într-o interfață",
            "o metodă statică implementată într-o interfață",
            "nu putem avea metode default într-o interfață",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele default nu sunt abstracte - ele au implementare în interfață. Metodele abstracte nu au corp și trebuie implementate de clasele care implementează interfața.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Metodele default în interfețe (introduse în Java 8) sunt metode non-statice cu implementare completă. Permit adăugarea de funcționalitate nouă la interfețe fără a rupe compatibilitatea cu clasele existente.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele default sunt non-statice. Interfețele pot avea și metode statice, dar acestea sunt diferite de metodele default.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Din Java 8, interfețele pot conține metode default cu implementare, alături de metodele abstracte și statice.",
            },
          ],
        },
        {
          id: 14,
          text: "Ce se afișează la rularea acestui cod?",
          description: null,
          code: 'class Document {\n}\n\nclass PdfDocument extends Document {\n}\n\nclass CsvDocument extends Document {\n}\n\nclass DocumentViewer {\n    public void openDocument(Document document) {\n        System.out.println("Opening document");\n    }\n\n    public void openDocument(PdfDocument document) {\n        System.out.println("Opening pdf");\n    }\n\n    public void openDocument(CsvDocument document) {\n        System.out.println("Opening csv");\n    }\n}\n\nclass AdobeReader extends DocumentViewer {\n    public void openDocument(PdfDocument document) {\n        System.out.println("Adobe is opening pdf");\n    }\n\n    public void openDocument(CsvDocument document) {\n        System.out.println("Cannot open csv");\n    }\n}\n\nclass DocumentTest {\n    public static void main(String[] args) {\n        DocumentViewer documentViewer = new AdobeReader();\n        Document file1 = new PdfDocument();\n        CsvDocument file2 = new CsvDocument();\n\n        documentViewer.openDocument(file1);\n        documentViewer.openDocument(file2);\n    }\n}',
          options: [
            "Opening document Cannot open csv",
            "Adobe is opening pdf Cannot open csv",
            "Adobe is opening pdf Opening csv",
            "Opening document Opening csv",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. file1 este declarat ca Document (compile-time type), deci se alege openDocument(Document) la compilare, iar la runtime se execută override-ul din AdobeReader. Dar AdobeReader nu override openDocument(Document), deci se execută din DocumentViewer. file2 este CsvDocument, se face override corect.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. file1 are tipul compile-time Document, nu PdfDocument, deci se apelează openDocument(Document). Overloading se rezolvă la compile-time bazat pe tipul declarat, nu pe tipul runtime.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Pentru file1 se apelează openDocument(Document), nu openDocument(PdfDocument), deoarece tipul declarat este Document.",
            },
            {
              isCorrect: false,
              explanation:
                'Fals. Pentru file2, care este de tip CsvDocument, se apelează versiunea override din AdobeReader care printează "Cannot open csv", nu "Opening csv".',
            },
          ],
        },
        {
          id: 15,
          text: "Ce se va afișa la execuția codului de mai jos?",
          description: null,
          code: 'public class Test {\n    public static void main(String[] args){\n        A.B.write();\n        A a = new A();\n        A.write();\n        A.B.write();\n    }\n}\n\nclass A {\n    static boolean x = false;\n    A(){\n        x = false;\n        B.x = true;\n    }\n    static class B {\n        static boolean x = false;\n\n        public static void write(){\n            x = !x;\n            if (x) System.out.print("A");\n            else System.out.print("B");\n        }\n    }\n    public static void write(){\n        x = !x;\n        if (x) System.out.print("C");\n        else System.out.print("D");\n    }\n}',
          options: ["BCA", "ACB", "ADB", "BDA"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Secvența corectă este: A.B.write() -> B.x devine true -> A, new A() setează B.x = true (rămâne true), A.write() -> A.x devine true -> C, A.B.write() -> B.x devine false -> B. Rezultatul este ACB.",
            },
            {
              isCorrect: true,
              explanation:
                'Corect. 1) A.B.write(): B.x devine true -> printează "A". 2) new A(): setează A.x=false și B.x=true. 3) A.write(): A.x devine true -> printează "C". 4) A.B.write(): B.x devine false -> printează "B". Output: ACB.',
            },
            {
              isCorrect: false,
              explanation:
                'Fals. Prima apelare A.B.write() face B.x = true, deci se printează "A", nu "B". A doua apelare A.write() face A.x = true, printând "C".',
            },
            {
              isCorrect: false,
              explanation:
                'Fals. Inițial B.x este false, deci prima apelare A.B.write() va printa "A" (B.x devine true), nu "B".',
            },
          ],
        },
        {
          id: 16,
          text: "Ce tip de clasă reprezintă următoarea implementare?",
          description: null,
          code: "Predicate<Integer> check = x -> x % 2 == 0;",
          options: [
            "clasă locală",
            "clasă anonimă",
            "clasă nested non-statică",
            "clasă nested statică",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. O clasă locală este definită într-o metodă cu un nume explicit (class NumeClasa {...}). Lambda expression-urile nu sunt clase locale.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Lambda expression este o formă concisă de a implementa o interfață funcțională (cu o singură metodă abstractă). Compilatorul o transformă într-o clasă anonimă care implementează interfața Predicate.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. O clasă nested non-statică (inner class) este definită în interiorul altei clase fără modificatorul static. Lambda-urile nu sunt clase nested.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. O clasă nested statică este o clasă membră cu modificatorul static. Lambda expression-urile nu sunt clase nested statice.",
            },
          ],
        },
        {
          id: 17,
          text: "Ce va afișa programul?",
          description: null,
          code: 'public class Test {\n    public static void main(String[] args) {\n        Test obj = new Test();\n        obj.first();\n    }\n\n    void first() {\n        String a = "good";\n        String b = second(a);\n        System.out.print(":" + a + b);\n    }\n\n    String second(String a) {\n        a = a + "luck";\n        System.out.print(a);\n        return "luck";\n    }\n}',
          options: [
            "goodluck:goodluckluck",
            "goodluck:goodgoodluck",
            "goodluck:goodluck",
            "goodluck:luckgoodluck",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                'Fals. În first(), variabila a rămâne "good" deoarece String este imutabil. Operația a + "luck" din second() creează un string nou local, fără a modifica string-ul original.',
            },
            {
              isCorrect: false,
              explanation:
                'Fals. String-urile sunt imutabile în Java. Modificarea lui a în second() nu afectează variabila a din first(). a rămâne "good" în first().',
            },
            {
              isCorrect: true,
              explanation:
                'Corect. 1) În second(), a devine "goodluck" local (String imutabil) și se printează "goodluck". 2) second() returnează "luck" care devine b. 3) În first(), a rămâne "good" (imutabil), se printează ":" + "good" + "luck" = ":goodluck". Total: "goodluck:goodluck".',
            },
            {
              isCorrect: false,
              explanation:
                'Fals. b primește valoarea returnată "luck", nu "goodluck". String-ul modificat în second() este local și nu afectează valoarea returnată.',
            },
          ],
        },
        {
          id: 18,
          text: "Identificați pe care linii avem suprascriere (overriding) și pe care avem supraîncărcare (overloading) corecte, fără erori de compilare:",
          description: null,
          code: "public class Test {\n    public static void main(String[] args) {\n        AudioBook book = new AudioBook();\n    }\n}\n\nclass BookException extends Exception {\n}\n\ninterface Book {\n    void markRead();\n    void markToRead() throws BookException;\n}\n\nclass AudioBook implements Book {\n    public void markRead() {\n    } // 1\n\n    public void markToRead() {\n    } // 2\n\n    public void markRead(int rating) {\n    } // 3\n\n    public void markRead(int rating, Date date) {\n    } // 4\n}",
          options: [
            "Suprascriere: 1, Supraîncărcare: 3, 4",
            "Suprascriere: 1, 2, Supraîncărcare: 3,4",
            "Suprascriere: 3, 4, Supraîncărcare: 1, 2",
            "Suprascriere: 3, 4, Supraîncărcare: 1",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 2 este de asemenea suprascriere (override) a metodei markToRead() din interfața Book. O metodă override poate să nu declare excepții chiar dacă metoda din interfață le declară.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Overriding (implementare interfață): liniile 1 și 2 implementează metodele din Book. Overloading (aceeași metodă, parametri diferiți): liniile 3 și 4 sunt versiuni supraîncărcate ale markRead() cu parametri diferiți.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Liniile 1 și 2 sunt overriding (implementare de interfață), nu overloading. Liniile 3 și 4 sunt overloading al metodei markRead().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 1 este overriding (implementare markRead() din Book), iar linia 2 este de asemenea overriding (implementare markToRead() din Book).",
            },
          ],
        },
        {
          id: 19,
          text: "În ce zonă de memorie sunt stocate obiectele?",
          description: null,
          code: null,
          options: [
            "pe stivă",
            "pe heap",
            "în memoria cache",
            "memoria externă",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Stiva (stack) stochează variabilele locale, parametrii metodelor și referințele la obiecte, nu obiectele în sine.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Obiectele în Java sunt alocate pe heap (memoria dinamică). Referințele la aceste obiecte sunt stocate pe stack, dar obiectele propriu-zise sunt pe heap și sunt gestionate de Garbage Collector.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Memoria cache este o memorie hardware rapidă folosită de procesor pentru optimizare, nu o zonă explicită de alocare a obiectelor în Java.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Memoria externă (disk) nu este folosită implicit pentru stocarea obiectelor în timpul execuției. Obiectele sunt în RAM, pe heap.",
            },
          ],
        },
        {
          id: 20,
          text: "Pentru ce folosim map() pe colecții și pe arrays în Java?",
          description: null,
          code: null,
          options: [
            "pentru a selecta elementele dintr-o colecție / dintr-un array care respectă o condiție reprezentată de funcția lambda dată că parametru",
            "pentru a aplica o operație pe fiecare element din cadrul colecției sau al array-ului, operație reprezentată de funcția lambda dată că parametru",
            "pentru a reduce elementele unei colecții / unui array la un singur element prin operația reprezentată de funcția lambda dată că parametru",
            "pentru a crea o nouă copie a colecției / al array-ului",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Pentru selectarea elementelor care respectă o condiție se folosește filter(), nu map(). Filter returnează un stream cu elementele care îndeplinesc condiția.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. map() aplică o funcție de transformare pe fiecare element și returnează un nou stream/array cu rezultatele. De exemplu, list.stream().map(x -> x * 2) înmulțește fiecare element cu 2.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Pentru reducerea elementelor la o singură valoare se folosește reduce(), nu map(). Reduce acumulează valorile folosind o operație binară.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. map() nu creează o copie simplă, ci transformă fiecare element folosind funcția dată. Pentru copiere simplă există alte metode (clone(), copyOf(), etc.).",
            },
          ],
        },
      ];

      const questionsExamenCa2020 = [
        {
          id: 1,
          text: "Când apare NullPointerException?",
          description: null,
          code: null,
          options: [
            "(a) Când încercăm să deschidem un fișier care nu există",
            "(b) Când facem buffer overflow la un array",
            "(c) Când încercăm să folosim un obiect null",
            "(d) Când folosim o colecție care este instanțiată și goală",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Când încercăm să deschidem un fișier care nu există, se aruncă FileNotFoundException, nu NullPointerException.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Buffer overflow la un array generează ArrayIndexOutOfBoundsException, nu NullPointerException.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. NullPointerException apare când încercăm să folosim un obiect care este null (să apelăm o metodă sau să accesăm un câmp al unui obiect null).",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. O colecție instanțiată și goală nu produce NullPointerException; colecția există în memorie, doar că nu conține elemente.",
            },
          ],
        },
        {
          id: 2,
          text: "Care este rezultatul execuției codului de mai jos?",
          description: null,
          code: 'String a = "hello";\nString b = "world";\nString c = b;\nb = a + b;\nString d = new String("hello");\nSystem.out.println(c + " " + (d == a));',
          options: [
            "(a) world false",
            "(b) helloworld true",
            "(c) hello true",
            "(d) helloworld false",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                'Corect. Variabila c păstrează referința către "world" (valoarea inițială a lui b). Comparația d == a este false pentru că d este creat cu "new" și are o altă adresă în memorie decât a (care folosește string pool-ul).',
            },
            {
              isCorrect: false,
              explanation:
                'Greșit. c nu devine "helloworld" deoarece atribuirea b = a + b modifică doar referința lui b, nu și pe cea a lui c care continua să refere "world".',
            },
            {
              isCorrect: false,
              explanation:
                'Greșit. c nu este "hello", ci "world", valoarea inițială la care referă înainte ca b să fie modificat.',
            },
            {
              isCorrect: false,
              explanation:
                'Greșit. c nu este "helloworld", ci "world", deoarece c a fost asignat cu referința inițială a lui b.',
            },
          ],
        },
        {
          id: 3,
          text: "Care variantă definește cel mai bine legătura dintre interfețe și clase?",
          description: null,
          code: null,
          options: [
            "(a) Nu pot exista relații între clase și interfețe",
            "(b) Nici clasele, nici interfețele nu precizează modul în care un obiect execută o operație",
            "(c) Interfețele precizează operațiile expuse de un obiect, în timp ce clasele modul în care acesta le execută",
            "(d) Atât clasele, cât și interfețele definesc modul în care un obiect execută o operație",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Există relații foarte importante între clase și interfețe - clasele implementează interfețele.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Clasele definesc exact modul în care operațiile sunt executate prin implementarea metodelor.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Interfețele definesc contractul (ce operații trebuie să existe), iar clasele definesc implementarea (cum se execută aceste operații).",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Interfețele nu definesc modul de execuție, ci doar semnătura metodelor; implementarea este furnizată de clase.",
            },
          ],
        },
        {
          id: 4,
          text: "Ce afirmație despre Set și List este adevărată?",
          description: null,
          code: null,
          options: [
            "(a) În Set nu avem elemente duplicate, iar Set extinde interfața List",
            "(b) În Set putem avea elemente duplicate, la fel ca în List",
            "(c) Nici în Set, nici în List nu avem elemente duplicate",
            "(d) În Set nu avem elemente duplicate, iar în List putem să avem",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Deși este corect că Set nu permite duplicate, Set NU extinde interfața List - ambele extind Collection independent.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Set nu permite elemente duplicate, aceasta fiind caracteristica sa definitorie.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. List permite elemente duplicate, spre deosebire de Set.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Set nu permite duplicate (unicitate), în timp ce List permite duplicate și păstrează ordinea de inserție.",
            },
          ],
        },
        {
          id: 5,
          text: "Care este rezultatul execuției codului de mai jos?",
          description:
            'Fie:\nclass Device {\n    public static void charge() {\n        System.out.print("Charging device; ");\n    }\n}\nclass Phone extends Device {\n    public static void charge() {\n        System.out.print("Charging phone; ");\n    }\n}',
          code: "Device phone = new Phone();\nDevice device = new Device();\nphone.charge();\ndevice.charge();\nDevice.charge();",
          options: [
            "(a) Charging device; Charging device; Charging phone;",
            "(b) Charging phone; Charging phone; Charging device;",
            "(c) Charging device; Charging device; Charging device;",
            "(d) Charging phone; Charging device; Charging device;",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Greșit. Ultimul apel nu execută metoda din Phone.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Metodele statice nu beneficiază de polimorfism - apelul se face pe baza tipului variabilei de referință.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Metodele statice nu suportă polimorfism. Apelul se face în funcție de tipul variabilei de referință, nu de tipul obiectului. Toate apelurile folosesc metoda din Device.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. phone.charge() nu execută metoda din Phone, ci din Device, deoarece metodele statice nu sunt polimorfice.",
            },
          ],
        },
        {
          id: 6,
          text: "Care afirmații sunt adevărate despre clase interne statice?",
          description:
            "1. Nu au acces la membri non-statici ai clasei exterioare\n2. Este nevoie de o instanță a clasei externe pentru a o instanția\n3. Trebuie să moștenească clasa exterioară\n4. Trebuie instanțiată astfel: Outer out = new Outer(); Inner in = out.new Inner();",
          code: null,
          options: ["(a) 3", "(b) 1", "(c) 2,4", "(d) 1,2"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Afirmația 3 este falsă - clasele interne statice nu trebuie să moștenească clasa exterioară.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Clasele interne statice (static nested classes) nu au acces la membrii non-statici ai clasei exterioare și pot fi instanțiate direct: Outer.Inner in = new Outer.Inner(); fără a avea nevoie de o instanță a clasei externe.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Ambele afirmații sunt false - clasele interne statice NU necesită instanță a clasei externe și se instanțiază direct: Outer.Inner in = new Outer.Inner();",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Afirmația 2 este falsă - clasele interne statice NU necesită o instanță a clasei externe pentru a fi instanțiate.",
            },
          ],
        },
        {
          id: 7,
          text: "În Java, prin compararea a două obiecte cu ==, ce se compară?",
          description: null,
          code: null,
          options: [
            "(a) tipurile obiectelor",
            "(b) mărimile obiectelor",
            "(c) adresele obiectelor",
            "(d) valorile obiectelor",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Operatorul == nu compară tipurile obiectelor - tipurile sunt verificate la compilare.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Operatorul == nu compară mărimea (dimensiunea) obiectelor în memorie.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Operatorul == pentru obiecte compară adresele (referințele) din memorie, nu conținutul obiectelor.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Pentru compararea valorilor (conținutului) obiectelor trebuie folosită metoda equals(), nu operatorul ==.",
            },
          ],
        },
        {
          id: 8,
          text: "Fie un serviciu de tip Youtube, în care avem utilizatori care se pot abona la canale, putând fi la curent cu noutățile canalelor la care ei sunt abonați (încărcare videoclip nou, depășirea unui anumit număr de abonați etc). Ce design pattern se poate aplica aici?",
          description: null,
          code: null,
          options: [
            "(a) Visitor",
            "(b) Factory",
            "(c) Observer",
            "(d) Command",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Visitor pattern se folosește pentru a adăuga operații noi la o ierarhie de clase fără a le modifica.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Factory pattern se ocupă cu crearea de obiecte, nu cu notificarea schimbărilor.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Observer pattern este utilizat pentru scenariile subscribe/notify, unde observatorii (utilizatorii) sunt notificați automat când subiectul (canalul) se schimbă.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Command pattern încapsulează operații ca obiecte, dar nu gestionează relații subscribe/notify.",
            },
          ],
        },
        {
          id: 9,
          text: "Care dintre următoarele afirmații sunt adevărate?",
          description:
            "1) Clasele abstracte pot avea keyword-ul final\n2) O clasă poate moșteni mai multe clase în același timp\n3) O interfață poate moșteni mai multe interfețe în același timp\n4) Metodele și atributele de tip protected pot fi accesate doar din clasa-origine și din clasele derivate",
          code: null,
          options: ["(a) 1, 2, 3", "(b) 3, 4", "(c) 2, 3, 4", "(d) 1, 2, 3, 4"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Afirmațiile 1 și 2 sunt false - clasele abstracte nu pot fi finale (contradicție) și Java nu suportă moștenire multiplă pentru clase.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Afirmația 3 este adevărată (interfețele pot moșteni multiple interfețe) și 4 este parțial adevărată (protected e accesibil în clasă, clase derivate și în același package). Afirmațiile 1 (abstract și final sunt contradictorii) și 2 (nu există moștenire multiplă pentru clase în Java) sunt false.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Afirmația 2 este falsă - Java nu permite moștenire multiplă pentru clase (doar pentru interfețe).",
            },
            {
              isCorrect: false,
              explanation: "Greșit. Afirmațiile 1 și 2 sunt false.",
            },
          ],
        },
        {
          id: 10,
          text: "Dacă Feline extinde clasa abstractă Animal și Lion extinde Feline, atunci care instanțiere este corectă?",
          description: null,
          code: null,
          options: [
            "(a) Feline feline = new Animal();",
            "(b) Animal animal = new Feline();",
            "(c) Lion lion = new Animal();",
            "(d) Lion lion = new Feline();",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Nu putem instanția Animal deoarece este o clasă abstractă, iar downcast-ul de la clasa abstractă la subclasă este invalid.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Dacă Feline este o clasă concretă (nu abstractă), putem instanția un obiect de tip Feline și îl putem referi prin variabila de tip Animal datorită polimorfismului (upcast de la subclasă la superclasă).",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Nu putem instanția Animal deoarece este o clasă abstractă.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Nu putem face downcast implicit de la Feline la Lion fără un cast explicit, și chiar cu cast ar da ClassCastException la runtime dacă obiectul nu este de fapt un Lion.",
            },
          ],
        },
        {
          id: 11,
          text: "Ce înseamnă constructorul default?",
          description: null,
          code: null,
          options: [
            "(a) constructor fără parametri declarat de utilizator",
            "(b) constructor fără implementare",
            "(c) constructor fără modificatori de acces",
            "(d) constructor fără parametri adăugat de Java dacă niciun constructor nu a fost declarat",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                'Greșit. Un constructor fără parametri declarat de utilizator se numește "no-argument constructor", nu "default constructor".',
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Constructorul default are implementare (chiar dacă goală) și apelează super().",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Constructorul default are modificator de acces - același cu cel al clasei.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Constructorul default este constructorul fără parametri pe care Java îl adaugă automat dacă nu declarăm niciun constructor. Odată ce declarăm orice constructor, Java nu mai adaugă constructorul default.",
            },
          ],
        },
        {
          id: 12,
          text: "Ce design pattern putem folosi pentru a avea un obiect unic și vizibil la nivel global?",
          description: null,
          code: null,
          options: [
            "(a) Observer",
            "(b) Visitor",
            "(c) Singleton",
            "(d) Factory",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Observer pattern se ocupă cu notificări între obiecte, nu cu unicitatea instanțelor.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Visitor pattern se ocupă cu adăugarea de operații noi la ierarhii de clase.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Singleton pattern asigură că o clasă are o singură instanță și oferă un punct global de acces la ea prin constructor privat și metodă statică getInstance().",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Factory pattern se ocupă cu crearea de obiecte, dar nu garantează unicitatea instanței.",
            },
          ],
        },
        {
          id: 13,
          text: "În ce colecție de tip Set se păstrează ordinea inserției elementelor?",
          description: null,
          code: null,
          options: [
            "(a) AbstractSet",
            "(b) LinkedHashSet",
            "(c) HashSet",
            "(d) TreeSet",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. AbstractSet este o clasă abstractă care nu garantează ordinea.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. LinkedHashSet păstrează ordinea de inserție a elementelor folosind o listă dublu înlănțuită, spre deosebire de HashSet care nu garantează ordinea.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. HashSet nu păstrează și nu garantează nicio ordine a elementelor.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. TreeSet păstrează elementele sortate natural sau conform unui Comparator, nu ordinea inserției.",
            },
          ],
        },
        {
          id: 14,
          text: "Ce colecție ar fi mai eficientă de folosit dacă dorim să stocăm o secvență de elemente pe care să o modificăm rar dar pe care să o accesăm foarte des?",
          description: null,
          code: null,
          options: [
            "(a) ArrayList",
            "(b) LinkedList",
            "(c) niciuna din variante",
            "(d) Vector",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. ArrayList este mai eficient pentru acces aleator (get) datorită structurii de array intern care permite acces O(1), în timp ce LinkedList necesită traversare O(n).",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. LinkedList este eficient pentru inserări/ștergeri frecvente, dar accesul la elemente este O(n) față de O(1) la ArrayList.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. ArrayList este o variantă foarte bună pentru acest scenariu.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Deși Vector este similar cu ArrayList pentru acces, este sincronizat (thread-safe) ceea ce adaugă overhead inutil dacă nu este necesar.",
            },
          ],
        },
        {
          id: 15,
          text: "Ce rol are un copy constructor?",
          description: null,
          code: null,
          options: [
            "(a) de a copia datele și referința unui obiect",
            "(b) de a copia referința unui obiect",
            "(c) de a distruge referința unui obiect",
            "(d) de a copia datele unui obiect",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Copy constructor creează un nou obiect cu date copiate, nu copiază referința - ar însemna că ambele variabile ar referi același obiect.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Copierea doar a referinței nu este rolul copy constructor-ului - aceasta se face prin simpla atribuire.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Copy constructor creează obiecte noi, nu distruge referințe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Copy constructor creează un nou obiect copiind datele (valorile câmpurilor) dintr-un obiect existent, creând astfel o copie independentă cu propria referință în memorie.",
            },
          ],
        },
        {
          id: 16,
          text: "Care este rezultatul execuției codului de mai jos?",
          description:
            'Unde:\nclass Cake extends Food {\n    public void cut() {\n        System.out.print(" Cake ");\n    }\n}\nclass Food {\n    public void cut() {\n        System.out.print(" Food ");\n    }\n}',
          code: "Food food1 = new Food();\nFood food2 = new Cake();\nCake cake = new Cake();\nfood1.cut();\nfood2.cut();\ncake.cut();",
          options: [
            "(a) Food Food Cake",
            "(b) Food Food Food",
            "(c) Food Cake Cake",
            "(d) Cake Cake Cake",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. food2 referă un obiect de tip Cake, deci se va apela metoda cut() din Cake datorită polimorfismului.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Polimorfismul face ca metoda din clasa efectivă a obiectului să fie apelată, nu cea din tipul variabilei de referință.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Polimorfism în acțiune: food1.cut() apelează Food.cut(), food2.cut() apelează Cake.cut() (deși tipul variabilei este Food, obiectul este Cake și metoda este override), cake.cut() apelează Cake.cut().",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. food1 este de tip Food și referă un obiect Food, deci se va apela metoda cut() din Food.",
            },
          ],
        },
        {
          id: 17,
          text: "Identificați pe care linii avem suprascriere (overriding) și pe care avem supraîncărcare (overloading)",
          description: null,
          code: "interface Coffee {\n    void brew(); // 1\n    void drink(); // 2\n}\nclass Espresso implements Coffee {\n    public void brew() { } // 3\n    public void drink() { } // 4\n    public void drink(Boolean withSugar) { } // 5\n    public void drink(Boolean withMilk,\n                      Boolean withSugar) { } // 6\n}",
          options: [
            "(a) Suprascriere: 5,6; Supraîncărcare: 3,4",
            "(b) Suprascriere: 1,2,3; Supraîncărcare: 4,5,6",
            "(c) Suprascriere: 3; Supraîncărcare: 4,5,6",
            "(d) Suprascriere: 3,4; Supraîncărcare: 5,6",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Greșit. Liniile 3 și 4 sunt suprascriere (implementare de metode din interfață), nu supraîncărcare.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Liniile 1 și 2 sunt doar declarații în interfață, nu suprascriere. Linia 4 este suprascriere, nu supraîncărcare.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Linia 4 este suprascriere (implementare din interfață), nu supraîncărcare.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Liniile 3 și 4 implementează (override) metodele din interfața Coffee. Liniile 5 și 6 sunt overloading (aceeași metodă drink cu parametri diferiți în aceeași clasă).",
            },
          ],
        },
        {
          id: 18,
          text: "Ce se va afișa la rularea codului?",
          description: null,
          code: "class Foo {\n    public int doWork(int x) {\n        try {\n            x++;\n            if (x < 3) {\n                throw new Exception();\n            }\n            return ++x;\n        } catch (Exception e) {\n            return x++;\n        } finally {\n            return ++x;\n        }\n    }\n}\nclass Main {\n    public static void main(String[] args) {\n        Foo f = new Foo();\n        System.out.println(f.doWork(1));\n    }\n}",
          options: ["(a) 3", "(b) 4", "(c) 2", "(d) 5"],
          answers: [
            {
              isCorrect: false,
              explanation: "Greșit. Valoarea returnată este 4, nu 3.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. x devine 2 în try (x=1, apoi x++), se aruncă excepția (2<3), în catch x++ returnează 2 dar înainte x devine 3, apoi finally execută ++x care face x să devină 4 și returnează 4, suprascriind return-ul din catch.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Deși catch-ul ar returna 2 (valoarea lui x înainte de incrementare), blocul finally suprascrie acest return.",
            },
            {
              isCorrect: false,
              explanation: "Greșit. Valoarea returnată este 4, nu 5.",
            },
          ],
        },
        {
          id: 19,
          text: "Ce se va afișa la rularea codului?",
          description: null,
          code: 'class Foo {\n    public static void doWork() {\n        System.out.print("Done! ");\n    }\n}\nclass Main {\n    public static void main(String[] args) {\n        Foo f = null;\n        f.doWork();\n        Foo.doWork();\n    }\n}',
          options: [
            '(a) "Done! Done!"',
            "(b) La compilare va da o eroare la f.doWork();",
            '(c) "Done! "',
            "(d) La rulare programul va da NullPointerException",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                'Corect. Metodele statice pot fi apelate pe referințe null fără NullPointerException (deși nu e recomandat). Apelul f.doWork() este rezolvat la compile-time ca Foo.doWork(). Ambele apeluri funcționează și afișează "Done! Done!".',
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Nu există eroare de compilare - apelarea metodelor statice pe referințe null este permisă sintactic.",
            },
            {
              isCorrect: false,
              explanation:
                'Greșit. Ambele apeluri se execută și afișează "Done! ", deci rezultatul este "Done! Done!".',
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. NullPointerException apare doar când încercăm să accesăm membri non-statici pe referințe null, nu la metode statice.",
            },
          ],
        },
        {
          id: 20,
          text: "Ce reprezintă implementarea unei clase anonime?",
          description: null,
          code: null,
          options: [
            "(a) implementarea unei interfețe sau extinderea unei clase",
            "(b) implementarea de metode anonime",
            "(c) implementarea unei interfețe în mod exclusiv",
            "(d) crearea unei clase care are un constructor",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Clasele anonime pot implementa o interfață SAU extinde o clasă concretă sau abstractă, oferind implementare inline fără a declara o clasă separată cu nume.",
            },
            {
              isCorrect: false,
              explanation:
                'Greșit. Nu există conceptul de "metode anonime" în Java - clasele anonime implementează metode obișnuite.',
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Clasele anonime pot atât implementa interfețe, cât și extinde clase, nu doar interfețe în mod exclusiv.",
            },
            {
              isCorrect: false,
              explanation:
                "Greșit. Clasele anonime NU pot avea constructori declarați explicit - pot avea doar blocuri de inițializare.",
            },
          ],
        },
      ];

      const questionsJavaBasics = [
        {
          id: 1,
          text: "Care este mărimea tipului primitiv 'int' în Java?",
          code: null,
          options: ["8 biți", "16 biți", "32 biți", "64 biți"],
          answers: [
            { isCorrect: false, explanation: "byte are 8 biți." },
            { isCorrect: false, explanation: "short are 16 biți." },
            {
              isCorrect: true,
              explanation: "Corect. int are 32 de biți (4 bytes).",
            },
            { isCorrect: false, explanation: "long are 64 de biți." },
          ],
        },
        {
          id: 2,
          text: "Care dintre următoarele NU este un cuvânt cheie (keyword) în Java?",
          code: null,
          options: ["static", "Boolean", "void", "transient"],
          answers: [
            { isCorrect: false, explanation: "static este un cuvânt cheie." },
            {
              isCorrect: true,
              explanation:
                "Corect. 'Boolean' este o clasă wrapper din pachetul java.lang. Cuvântul cheie pentru tipul primitiv este 'boolean' (cu literă mică).",
            },
            { isCorrect: false, explanation: "void este un cuvânt cheie." },
            {
              isCorrect: false,
              explanation: "transient este un cuvânt cheie.",
            },
          ],
        },
        {
          id: 3,
          text: "Ce va afișa următorul cod?",
          code: "String s = \"Java\";\ns.concat(\" SE 11\");\ns.replace('J', 'L');\nSystem.out.println(s);",
          options: ["Java SE 11", "Lava", "Java", "Lava SE 11"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Metodele clasei String nu modifică obiectul curent.",
            },
            {
              isCorrect: false,
              explanation:
                "Metodele clasei String nu modifică obiectul curent.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Clasa String este imutabilă. Metodele concat() și replace() returnează noi obiecte String, dar rezultatele lor sunt ignorate aici. Variabila s rămâne neschimbată.",
            },
            {
              isCorrect: false,
              explanation:
                "Metodele clasei String nu modifică obiectul curent.",
            },
          ],
        },
      ];

      const questionsSetNou1 = [
        {
          id: 1,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. package alpha;\n2. public class Base {\n3.     private int x = 10;\n4.     int y = 20;\n5.     protected int z = 30;\n6. }\n\n1. package beta;\n2. import alpha.Base;\n3. public class Derived extends Base {\n4.     public void show() {\n5.         System.out.print(x + " ");\n6.         System.out.print(y + " ");\n7.         System.out.print(z);\n8.     }\n9. }',
          options: [
            "10 20 30",
            "Eroare de compilare la linia 5",
            "Eroare de compilare la linia 6",
            "Eroare de compilare la liniile 5 și 6",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Câmpurile private și package-private nu sunt accesibile din alt pachet.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Linia 5 va da eroare (x este private), dar și linia 6 va da eroare (y este package-private).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu doar linia 6 este problematică, ci și linia 5.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. x este private și nu poate fi accesat din subclasă. y are modificator implicit (package-private) și nu poate fi accesat din alt pachet, chiar dacă clasa este derivată. Doar z (protected) este accesibil în subclasă din alt pachet.",
            },
          ],
        },
        {
          id: 2,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "3. public class Identifiers {\n4.     public static void main(String[] args) {\n5.         int _value = 5;\n6.         int $amount = 10;\n7.         int 2ndPlace = 15;\n8.         int class = 20;\n9.         System.out.println(_value + $amount);\n10.     }\n11. }",
          options: [
            "15",
            "Eroare de compilare la linia 7",
            "Eroare de compilare la linia 8",
            "Eroare de compilare la liniile 7 și 8",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu va compila din cauza identificatorilor invalizi.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu doar linia 7 este problematică, ci și linia 8.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu doar linia 8 este problematică, ci și linia 7.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Linia 7: identificatorii nu pot începe cu o cifră. Linia 8: 'class' este cuvânt cheie rezervat. Identificatorii pot începe cu _, $ sau literă.",
            },
          ],
        },
        {
          id: 3,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: 'class Parent {\n    Parent() { System.out.print("P "); }\n    Parent(int x) { System.out.print("P" + x + " "); }\n}\nclass Child extends Parent {\n    Child() { System.out.print("C "); }\n    Child(int x) { super(x); System.out.print("C" + x + " "); }\n    public static void main(String[] args) {\n        new Child(5);\n    }\n}',
          options: ["P C", "P5 C5", "P C5", "C5 P5"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Se apelează constructorul Child(int), care apelează explicit super(x).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. new Child(5) apelează Child(int x), care apelează super(5), adică Parent(int x) care printează 'P5 ', apoi Child(int x) continuă și printează 'C5 '. Rezultat: P5 C5.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Se apelează constructorul cu parametru din Parent, nu cel fără parametri.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorul părintelui se execută întotdeauna înaintea celui al copilului.",
            },
          ],
        },
        {
          id: 4,
          text: "Care afirmație despre polimorfism este corectă?",
          description: null,
          code: null,
          options: [
            "Polimorfismul permite metodelor să aibă aceeași semnătură dar implementări diferite în clase diferite",
            "Polimorfismul se aplică doar la metode statice",
            "Polimorfismul necesită utilizarea cuvântului cheie 'final'",
            "Polimorfismul nu funcționează cu interfețe",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Polimorfismul (runtime polymorphism) permite ca o metodă să aibă comportamente diferite în funcție de tipul real al obiectului, prin mecanismul de method overriding.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele statice NU sunt polimorfice - ele se rezolvă la compile-time bazat pe tipul referinței, nu pe tipul obiectului.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Cuvântul 'final' împiedică polimorfismul - o metodă finală nu poate fi suprascrisă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Polimorfismul funcționează excelent cu interfețe - aceasta este una dintre utilizările principale.",
            },
          ],
        },
        {
          id: 5,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class TryCatch {\n2.     public static void main(String[] args) {\n3.         try {\n4.             int[] arr = {1, 2, 3};\n5.             System.out.print(arr[3]);\n6.         } catch (RuntimeException e) {\n7.             System.out.print("Runtime ");\n8.         } catch (ArrayIndexOutOfBoundsException e) {\n9.             System.out.print("Array ");\n10.         }\n11.     }\n12. }',
          options: ["Runtime", "Array", "Runtime Array", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu va compila din cauza ordinii blocurilor catch.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul nu va compila.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul nu va compila.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. ArrayIndexOutOfBoundsException este subclasă a RuntimeException. Catch-ul pentru superclasă (RuntimeException) este plasat înaintea celui pentru subclasă, făcând catch-ul de pe linia 8 unreachable. Eroare de compilare.",
            },
          ],
        },
        {
          id: 6,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. class Vehicle {\n4.     static String type = "Vehicle";\n5.     static { System.out.print("V1 "); }\n6.     { System.out.print("V2 "); }\n7.     Vehicle() { System.out.print("V3 "); }\n8. }\n9. class Car extends Vehicle {\n10.     static { System.out.print("C1 "); }\n11.     { System.out.print("C2 "); }\n12.     Car() { System.out.print("C3 "); }\n13.     public static void main(String[] args) {\n14.         new Car();\n15.     }\n16. }',
          options: [
            "V1 C1 V2 V3 C2 C3",
            "V1 V2 V3 C1 C2 C3",
            "C1 V1 V2 V3 C2 C3",
            "V2 V3 C2 C3 V1 C1",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Ordinea: (1) Blocuri statice ale părintelui - V1, (2) Blocuri statice ale copilului - C1, (3) Bloc de inițializare instanță părinte - V2, (4) Constructor părinte - V3, (5) Bloc de inițializare instanță copil - C2, (6) Constructor copil - C3.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile statice ale clasei copil se execută după cele ale părintelui, dar înainte de crearea obiectului.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile statice ale clasei părinte se execută înaintea celor ale copilului.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile statice se execută la încărcarea clasei, înaintea creării obiectelor.",
            },
          ],
        },
        {
          id: 7,
          text: "Câte obiecte sunt eligibile pentru Garbage Collection la atingerea liniei marcate?",
          description: null,
          code: "class Node {\n    Node next;\n    int data;\n    Node(int d) { data = d; }\n}\npublic class LinkedTest {\n    public static void main(String[] args) {\n        Node n1 = new Node(1);\n        Node n2 = new Node(2);\n        Node n3 = new Node(3);\n        n1.next = n2;\n        n2.next = n3;\n        n1 = n3;\n        n2 = null;\n        // linia marcata\n    }\n}",
          options: ["0", "1", "2", "3"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Există obiecte fără referințe care sunt eligibile pentru GC.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. n1 acum referă n3. n2 este null. Obiectul original Node(1) nu mai are referință directă, dar avea n1.next = n2 (Node(2)). Node(2) nu mai are referință (n2 = null), dar era referit de Node(1).next. Node(3) este încă referit de n1. Doar Node(2) este eligibil (Node(1) încă poate fi referit prin lanțul de next-uri, dar de fapt n1 nu mai referă Node(1), deci și Node(1) este eligibil... Reconsidering: n1 = n3, deci Node(1) nu mai e referit de n1. Node(1) NU mai are referință! Node(2) era referit de Node(1).next, dar Node(1) nu mai e referit. Deci atât Node(1) cât și Node(2) sunt eligibile = 2 obiecte.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Node(3) este încă referit de n1 și n3 implicit prin codul original.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Node(3) este încă referit de n1.",
            },
          ],
        },
        {
          id: 8,
          text: "Care excepție poate fi aruncată de următorul cod?",
          description: null,
          code: "String str = null;\nint length = str.length();",
          options: [
            "NullPointerException",
            "StringIndexOutOfBoundsException",
            "IllegalArgumentException",
            "ClassCastException",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Apelarea oricărei metode pe o referință null aruncă NullPointerException.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. StringIndexOutOfBoundsException apare la accesarea unui index invalid într-un String existent.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. IllegalArgumentException apare când un argument invalid este pasat unei metode.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ClassCastException apare la conversii invalide de tip.",
            },
          ],
        },
        {
          id: 9,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Boxing {\n4.     public static void main(String[] args) {\n5.         Integer a = 127;\n6.         Integer b = 127;\n7.         Integer c = 200;\n8.         Integer d = 200;\n9.         System.out.print((a == b) + " ");\n10.         System.out.print(c == d);\n11.     }\n12. }',
          options: ["true true", "false false", "true false", "false true"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Comportamentul Integer caching diferă pentru valori din afara intervalului -128 la 127.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Pentru valori între -128 și 127, Integer folosește cache și referințele sunt egale.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Java face caching pentru Integer în intervalul -128 la 127. a și b referă același obiect din cache (true). c și d sunt în afara acestui interval, deci sunt obiecte diferite (false).",
            },
            {
              isCorrect: false,
              explanation: "Fals. a == b este true datorită Integer caching.",
            },
          ],
        },
        {
          id: 10,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "3. public class Finally {\n4.     public static void main(String[] args) {\n5.         System.out.print(test());\n6.     }\n7.     static int test() {\n8.         try {\n9.             return 1;\n10.         } finally {\n11.             return 2;\n12.         }\n13.     }\n14. }",
          options: ["1", "2", "Eroare de compilare", "1 2"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Blocul finally se execută întotdeauna și suprascrie return-ul din try.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Blocul finally se execută întotdeauna, iar return-ul din finally suprascrie orice return anterior din try sau catch. Se returnează 2.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul compilează, deși returnarea din finally nu este recomandată.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Se returnează o singură valoare, iar cea din finally o suprascrie pe cea din try.",
            },
          ],
        },
        {
          id: 11,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: 'class Animal {\n    void makeSound() { System.out.print("Animal "); }\n}\nclass Dog extends Animal {\n    void makeSound() { System.out.print("Dog "); }\n    void fetch() { System.out.print("Fetch "); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n        a.fetch();\n    }\n}',
          options: [
            "Animal Fetch",
            "Dog Fetch",
            "Eroare de compilare",
            "Animal Dog",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu va compila din cauza apelului fetch().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu va compila din cauza apelului fetch().",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. a este declarat de tip Animal, care nu are metoda fetch(). Chiar dacă obiectul real este Dog, compilatorul verifică tipul declarat. Eroare de compilare la a.fetch().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu va compila din cauza apelului fetch().",
            },
          ],
        },
        {
          id: 12,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Shadowing {\n4.     int x = 10;\n5.     public static void main(String[] args) {\n6.         Shadowing s = new Shadowing();\n7.         s.test(5);\n8.     }\n9.     void test(int x) {\n10.         x = x + 1;\n11.         System.out.print(x + " ");\n12.         System.out.print(this.x);\n13.     }\n14. }',
          options: ["6 6", "6 10", "11 10", "5 10"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Parametrul x umbrește câmpul x, deci modificarea afectează parametrul, nu câmpul.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Parametrul x (valoare 5) umbrește câmpul x. x = x + 1 face parametrul 6. Primul print afișează 6 (parametrul). this.x referă câmpul instanței care rămâne 10. Rezultat: 6 10.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Parametrul primește valoarea 5, nu 10, și devine 6 după incrementare.",
            },
            {
              isCorrect: false,
              explanation: "Fals. x = x + 1 incrementează parametrul la 6.",
            },
          ],
        },
        {
          id: 13,
          text: "Care afirmație este corectă despre array-uri în Java?",
          description: null,
          code: null,
          options: [
            "Array-urile pot avea dimensiune variabilă după creare",
            "Array-urile sunt obiecte și sunt alocate pe heap",
            "Array-urile primitive sunt stocate pe stack",
            "Array-urile nu pot conține elemente null",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Array-urile în Java au dimensiune fixă după creare.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Array-urile în Java sunt obiecte și sunt alocate pe heap, indiferent dacă conțin tipuri primitive sau referințe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Chiar și array-urile de primitive sunt obiecte alocate pe heap. Doar variabilele locale de tipuri primitive sunt pe stack.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Array-urile de referințe pot conține elemente null.",
            },
          ],
        },
        {
          id: 14,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Comparații între tipuri diferite",
          code: '1. class Compare {\n2.     public static void main(String[] args) {\n3.         int i = 10;\n4.         double d = 10.0;\n5.         Integer ii = 10;\n6.         Double dd = 10.0;\n7.         System.out.print((i == d) + " ");\n8.         System.out.print(ii == dd);\n9.     }\n10. }',
          options: [
            "true true",
            "true false",
            "false false",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Comparația între Integer și Double nu compilează.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu compilează la linia 8 din cauza incompatibilității tipurilor.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul nu compilează.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Comparația i == d funcționează (int se promovează la double). Dar ii == dd compară Integer cu Double, care sunt tipuri incompatibile pentru operatorul ==. Eroare de compilare.",
            },
          ],
        },
        {
          id: 15,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. interface Printable {\n4.     default void print() { System.out.print("Printable "); }\n5. }\n6. interface Showable {\n7.     default void print() { System.out.print("Showable "); }\n8. }\n9. class Demo implements Printable, Showable {\n10.     public static void main(String[] args) {\n11.         new Demo().print();\n12.     }\n13. }',
          options: [
            "Printable",
            "Showable",
            "Printable Showable",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Există conflict între metodele default din cele două interfețe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Există conflict între metodele default din cele două interfețe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Există conflict între metodele default din cele două interfețe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Când o clasă implementează două interfețe care au metode default cu aceeași semnătură, clasa TREBUIE să override metoda pentru a rezolva conflictul. Altfel, eroare de compilare.",
            },
          ],
        },
        {
          id: 16,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "3. public class LoopTest {\n4.     public static void main(String[] args) {\n5.         int x = 0;\n6.         outer: for(int i = 0; i < 3; i++) {\n7.             for(int j = 0; j < 3; j++) {\n8.                 if(j == 1) continue outer;\n9.                 x++;\n10.             }\n11.         }\n12.         System.out.println(x);\n13.     }\n14. }",
          options: ["9", "6", "3", "0"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. continue outer sare la următoarea iterație a buclei externe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. continue outer sare la următoarea iterație a buclei externe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Pentru fiecare i (0, 1, 2), bucla internă execută j=0 (x++), apoi j=1 face continue outer. Deci x++ se execută o dată per iterație externă: 3 ori. x = 3.",
            },
            {
              isCorrect: false,
              explanation: "Fals. x++ se execută de câte ori j=0.",
            },
          ],
        },
        {
          id: 17,
          text: "Care afirmație despre StringBuilder și String este corectă?",
          description: null,
          code: null,
          options: [
            "String și StringBuilder sunt ambele imutabile",
            "StringBuilder este thread-safe, String nu este",
            "StringBuilder este mutabil, String este imutabil",
            "String poate fi modificat folosind metoda append()",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. StringBuilder este mutabil, doar String este imutabil.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. String este imutabil deci thread-safe implicit. StringBuilder NU este thread-safe (StringBuffer este).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. StringBuilder permite modificarea conținutului fără a crea noi obiecte (mutabil). String creează un nou obiect la fiecare modificare (imutabil).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. String nu are metoda append(). Este imutabil și nu poate fi modificat.",
            },
          ],
        },
        {
          id: 18,
          text: "Care declarație este corectă?",
          description: null,
          code: "// Declarații pentru o listă de numere\n// A: List<Integer> list = new LinkedList<Number>();\n// B: List<Integer> list = new ArrayList<Integer>();\n// C: ArrayList<Number> list = new ArrayList<Integer>();\n// D: List<Object> list = new ArrayList<String>();",
          options: ["A", "B", "C", "D"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. LinkedList<Number> nu este compatibil cu List<Integer> - generics nu sunt covariant.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. List<Integer> este interfața, ArrayList<Integer> este implementarea. Tipurile generice se potrivesc exact.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ArrayList<Integer> nu este subtip al ArrayList<Number> - generics nu sunt covariant.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ArrayList<String> nu este subtip al List<Object> - generics nu sunt covariant.",
            },
          ],
        },
        {
          id: 19,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. import java.util.*;\n4. public class SetTest {\n5.     public static void main(String[] args) {\n6.         Set<String> set = new HashSet<>();\n7.         set.add("A");\n8.         set.add("B");\n9.         set.add("A");\n10.         set.add("C");\n11.         set.add("B");\n12.         System.out.println(set.size());\n13.     }\n14. }',
          options: ["5", "4", "3", "2"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Set nu permite duplicate, deci nu toate adăugările vor fi efectuate.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Set nu permite duplicate, deci 'A' și 'B' nu vor fi adăugate de două ori.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Set nu permite duplicate. Se adaugă: A, B, (A duplicat), C, (B duplicat). Rezultat: {A, B, C} cu size = 3.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Se adaugă 3 elemente unice: A, B și C.",
            },
          ],
        },
        {
          id: 20,
          text: "Care afirmație despre clase interne este FALSĂ?",
          description: null,
          code: null,
          options: [
            "O clasă internă non-statică are acces la membrii privați ai clasei externe",
            "O clasă internă statică poate fi instanțiată fără o instanță a clasei externe",
            "O clasă internă non-statică poate declara membri statici",
            "O clasă locală (definită într-o metodă) poate accesa variabilele finale din metodă",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Clasele interne au acces la toți membrii clasei externe.",
            },
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Clasele statice nested nu necesită instanță a clasei externe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect, aceasta este FALSĂ. O clasă internă non-statică NU poate declara membri statici (cu excepția constantelor compile-time).",
            },
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Clasele locale pot accesa variabile final sau effectively final din metoda înconjurătoare.",
            },
          ],
        },
        {
          id: 21,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. class Outer {\n2.     private int x = 10;\n3.     class Inner {\n4.         private int x = 20;\n5.         void print() {\n6.             int x = 30;\n7.             System.out.print(x + " ");\n8.             System.out.print(this.x + " ");\n9.             System.out.print(Outer.this.x);\n10.         }\n11.     }\n12.     public static void main(String[] args) {\n13.         new Outer().new Inner().print();\n14.     }\n15. }',
          options: ["30 20 10", "10 20 30", "30 30 30", "Eroare de compilare"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. x (local) = 30, this.x (câmpul Inner) = 20, Outer.this.x (câmpul Outer) = 10. Rezultat: 30 20 10.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Variabila locală x umbrește celelalte, dar putem accesa câmpurile cu this și Outer.this.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. this.x și Outer.this.x referă câmpuri diferite.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul compilează corect - clasele interne pot accesa membrii privați ai clasei externe.",
            },
          ],
        },
        {
          id: 22,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '5. class A { void show() { System.out.print("A "); } }\n6. public class Test {\n7.     public static void main(String[] args) {\n8.         A a = new A() {\n9.             void show() { System.out.print("Anonymous "); }\n10.         };\n11.         a.show();\n12.     }\n13. }',
          options: ["A", "Anonymous", "A Anonymous", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Metoda show() este suprascrisă în clasa anonimă.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Clasa anonimă extinde A și suprascrie metoda show(). Prin polimorfism, se apelează metoda din clasa anonimă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Se apelează doar o metodă, nu două.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează și rulează corect.",
            },
          ],
        },
        {
          id: 23,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "3. public class Calculator {\n4.     private int value = 5;\n5.     private static int count = 0;\n6.     public static void main(String[] args) {\n7.         Calculator c = new Calculator();\n8.         c.compute();\n9.     }\n10.     void compute() {\n11.         int value = 10;\n12.         System.out.print(new Processor().process());\n13.     }\n14.     class Processor {\n15.         int process() { return value + count; }\n16.     }\n17. }",
          options: ["15", "10", "5", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Clasa internă accesează câmpul instanței, nu variabila locală.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. value în Processor se referă la câmpul Calculator.this.value.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. În clasa Processor, value se referă la Calculator.this.value = 5 (nu la variabila locală din compute). count = 0. Rezultat: 5 + 0 = 5.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează corect.",
            },
          ],
        },
        {
          id: 24,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: 'class Worker implements Runnable {\n    Worker() { System.out.print("W "); }\n    public void run() { System.out.print("R "); }\n}\npublic class ThreadTest {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Worker());\n        t.run();\n        t.run();\n        t.start();\n    }\n}',
          options: [
            "W R R R",
            "W R R și posibil R",
            "W și posibil R R R",
            "R R R W",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Primele două apeluri t.run() se execută în thread-ul principal.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Constructorul printează 'W'. t.run() (apel direct) execută run() în thread-ul curent de două ori ('R R'). t.start() pornește un nou thread care va executa run() ('R'), dar ordinea cu ultimul R poate varia.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. t.run() se execută sincron în thread-ul principal, deci 'R R' apar garantat după 'W'.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Constructorul Worker() se execută primul.",
            },
          ],
        },
        {
          id: 25,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class AssertTest {\n2.     public static void main(String[] args) {\n3.         int x = 5;\n4.         assert x > 10 : "x is small";\n5.         assert x < 10;\n6.         assert x++ > 4;\n7.         System.out.print(x);\n8.     }\n9. }',
          options: [
            "5",
            "6",
            "AssertionError la linia 4 (cu assertions activate)",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Dacă assertions nu sunt activate, x devine 6. Dacă sunt activate, apare eroare la linia 4.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Aceasta ar fi valoarea doar dacă assertions nu sunt activate.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Cu assertions activate (java -ea), la linia 4 assert x > 10 este fals (5 > 10 = false), deci se aruncă AssertionError cu mesajul 'x is small'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sintaxa este corectă. Assertions pot avea expresii și mesaje.",
            },
          ],
        },
        {
          id: 26,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. import java.util.*;\n3. public class IteratorTest {\n4.     public static void main(String[] args) {\n5.         List<String> list = new ArrayList<>();\n6.         list.add("A"); list.add("B"); list.add("C");\n7.         Iterator<String> it = list.iterator();\n8.         while(it.hasNext()) {\n9.             String s = it.next();\n10.             if(s.equals("B")) list.remove(s);\n11.             System.out.print(s + " ");\n12.         }\n13.     }\n14. }',
          options: ["A B C", "A C", "A B", "ConcurrentModificationException"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Modificarea listei în timpul iterării cu Iterator cauzează excepție.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Modificarea listei în timpul iterării cu Iterator cauzează excepție.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Modificarea listei în timpul iterării cu Iterator cauzează excepție.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Modificarea unei liste (list.remove()) în timpul iterării cu Iterator (fără a folosi it.remove()) cauzează ConcurrentModificationException.",
            },
          ],
        },
        {
          id: 27,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. public class StringPool {\n3.     public static void main(String[] args) {\n4.         String s1 = "Hello";\n5.         String s2 = "Hello";\n6.         String s3 = new String("Hello");\n7.         String s4 = s3.intern();\n8.         System.out.print((s1 == s2) + " ");\n9.         System.out.print((s1 == s3) + " ");\n10.         System.out.print(s1 == s4);\n11.     }\n12. }',
          options: [
            "true true true",
            "true false false",
            "true false true",
            "false false true",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. s1 == s3 este false deoarece s3 este creat cu new.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. s1 == s4 este true deoarece intern() returnează referința din String pool.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. s1 și s2 referă același obiect din String pool (true). s3 este un obiect nou (false). s4 = s3.intern() returnează referința din pool, care este aceeași cu s1 (true).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. s1 == s2 este true deoarece ambele folosesc String pool.",
            },
          ],
        },
        {
          id: 28,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "10. int sum = 0;\n11. outer:\n12. for(int i = 0; i < 3; i++) {\n13.     inner:\n14.     for(int j = 0; j < 3; j++) {\n15.         if(i == j) continue inner;\n16.         if(i + j == 3) break outer;\n17.         sum++;\n18.     }\n19. }\n20. System.out.println(sum);",
          options: ["3", "4", "5", "6"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. i=0: j=0 continue, j=1 sum=1, j=2 sum=2. i=1: j=0 sum=3, j=1 continue, j=2 (1+2=3) break outer. Total sum = 3.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. break outer oprește execuția când i+j=3 (i=1, j=2).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. break outer oprește execuția când i+j=3 (i=1, j=2).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. break outer oprește execuția când i+j=3 (i=1, j=2).",
            },
          ],
        },
        {
          id: 29,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '5. short[] arr = {1, 2, 3};\n6. int sum = 0;\n7. for(short s : arr) sum += s;\n8. for(int i = 0; i < arr.length; arr[i]++) i++;\n9. System.out.print(sum + " ");\n10. System.out.print(arr[0] + arr[1] + arr[2]);',
          options: ["6 9", "6 8", "6 7", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Bucla de la linia 8 incrementează doar unele elemente.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. sum = 1+2+3 = 6. În bucla for la linia 8: i=0 -> arr[0]++ (arr[0]=2), i++ -> i=1; i=1 < 3 -> arr[1]++ (arr[1]=3), i++ -> i=2; i=2 < 3 -> arr[2]++ (arr[2]=4), i++ -> i=3; i=3 < 3 false. Array final: {2, 3, 4}. Suma: 2+3+4 = 9. Dar stai, arr[i]++ se execută în for update... Reconsidering: for(init; cond; update) - update se execută DUPĂ corp. Nu avem corp, deci arr[i]++ și i++ se execută: i=0, arr[0]=2, i=1; i=1<3, arr[1]=3, i=2; i=2<3, arr[2]=4, i=3; i=3<3 false. Total: 2+3+4=9? Nu, arr devine {2,3,4}, suma e 9. Dar așteptați, suma inițială era 6 (calculată înainte)... Rezultat: 6 9.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Elementele array-ului sunt modificate în bucla for.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează corect.",
            },
          ],
        },
        {
          id: 30,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. class Shape {\n3.     void draw() { System.out.print("Shape "); }\n4. }\n5. class Circle extends Shape {\n6.     void draw() { System.out.print("Circle "); }\n7. }\n8. class Square extends Shape {\n9.     void draw() { System.out.print("Square "); }\n10. }\n11. public class ShapeTest {\n12.     public static void main(String[] args) {\n13.         Shape[] shapes = {new Circle(), new Square(), new Shape()};\n14.         for(Shape s : shapes) s.draw();\n15.     }\n16. }',
          options: [
            "Shape Shape Shape",
            "Circle Circle Circle",
            "Circle Square Shape",
            "Shape Circle Square",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Polimorfismul asigură că metoda corectă este apelată bazat pe tipul real al obiectului.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Fiecare obiect din array este de un tip diferit.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Polimorfism: shapes[0] este Circle -> draw() din Circle, shapes[1] este Square -> draw() din Square, shapes[2] este Shape -> draw() din Shape. Rezultat: Circle Square Shape.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ordinea obiectelor în array este Circle, Square, Shape.",
            },
          ],
        },
      ];

      const questionsSetNou2 = [
        {
          id: 1,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class Operators {\n2.     public static void main(String[] args) {\n3.         int a = 5;\n4.         int b = 3;\n5.         System.out.print((a++ + ++b) + " ");\n6.         System.out.print(a + " " + b);\n7.     }\n8. }',
          options: ["8 6 4", "9 6 4", "8 5 4", "9 5 3"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. a++ returnează 5 (post-increment), ++b returnează 4 (pre-increment). 5+4=9.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. a++ returnează 5 și apoi a devine 6. ++b face b=4 și returnează 4. Suma: 5+4=9. După expresie: a=6, b=4. Rezultat: 9 6 4.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. a++ returnează valoarea înainte de increment, dar a se incrementează.",
            },
            {
              isCorrect: false,
              explanation: "Fals. b este incrementat cu ++b.",
            },
          ],
        },
        {
          id: 2,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Ternary {\n4.     public static void main(String[] args) {\n5.         int x = 10, y = 20;\n6.         int result = x > y ? x++ : --y;\n7.         System.out.print(result + " " + x + " " + y);\n8.     }\n9. }',
          options: ["19 10 19", "20 10 20", "10 11 20", "19 10 20"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. x > y este fals (10 > 20). Se evaluează --y care face y=19 și returnează 19. x rămâne 10 (x++ nu se evaluează). Rezultat: 19 10 19.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. --y este pre-decrement, deci returnează valoarea după decrementare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Condiția x > y este falsă, deci se evaluează ramura false (--y).",
            },
            {
              isCorrect: false,
              explanation: "Fals. y este decrementat de --y.",
            },
          ],
        },
        {
          id: 3,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. abstract class Vehicle {\n2.     abstract void start();\n3.     void stop() { System.out.print("Stop "); }\n4. }\n5. class Car extends Vehicle {\n6.     void start() { System.out.print("Car starts "); }\n7. }\n8. class Bike extends Vehicle {\n9.     void start() { System.out.print("Bike starts "); }\n10.     void stop() { System.out.print("Bike stops "); }\n11. }\n12. public class Test {\n13.     public static void main(String[] args) {\n14.         Vehicle v = new Car();\n15.         v.start();\n16.         v.stop();\n17.         v = new Bike();\n18.         v.start();\n19.         v.stop();\n20.     }\n21. }',
          options: [
            "Car starts Stop Bike starts Bike stops",
            "Car starts Stop Bike starts Stop",
            "Eroare de compilare",
            "Car starts Car stops Bike starts Bike stops",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Car moștenește stop() din Vehicle. Bike suprascrie stop(). Prin polimorfism, se apelează metodele din obiectul real.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Bike suprascrie metoda stop(), deci se afișează 'Bike stops'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul compilează corect - toate metodele abstracte sunt implementate.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Car nu suprascrie stop(), deci folosește versiunea din Vehicle.",
            },
          ],
        },
        {
          id: 4,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. interface A { default void show() { System.out.print("A "); } }\n2. interface B extends A { default void show() { System.out.print("B "); } }\n3. interface C extends A { }\n4. class Demo implements B, C {\n5.     public static void main(String[] args) {\n6.         new Demo().show();\n7.     }\n8. }',
          options: ["A", "B", "Eroare de compilare - conflict", "A B"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. B suprascrie metoda default din A, și B este mai specific.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. B extinde A și suprascrie show(). C extinde A dar nu suprascrie. Demo implementează B și C, iar metoda din B este mai specifică decât cea moștenită de C din A. Se afișează 'B'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu există conflict real - B are implementare mai specifică.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Se apelează o singură metodă show().",
            },
          ],
        },
        {
          id: 5,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Switch {\n4.     public static void main(String[] args) {\n5.         int day = 3;\n6.         switch(day) {\n7.             case 1: System.out.print("Mon ");\n8.             case 2: System.out.print("Tue ");\n9.             case 3: System.out.print("Wed ");\n10.             case 4: System.out.print("Thu ");\n11.             default: System.out.print("Other");\n12.         }\n13.     }\n14. }',
          options: ["Wed", "Wed Thu Other", "Wed Thu", "Other"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Lipsesc instrucțiunile break, deci execuția continuă (fall-through).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. day=3 intră pe case 3, dar fără break execuția continuă prin case 4 și default. Fall-through behavior.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Fără break, se execută și default.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. day=3 se potrivește cu case 3, nu sare direct la default.",
            },
          ],
        },
        {
          id: 6,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. class Base {\n2.     Base() { this(10); System.out.print("B0 "); }\n3.     Base(int x) { System.out.print("B" + x + " "); }\n4. }\n5. class Derived extends Base {\n6.     Derived() { System.out.print("D0 "); }\n7.     Derived(int x) { this(); System.out.print("D" + x + " "); }\n8.     public static void main(String[] args) {\n9.         new Derived(5);\n10.     }\n11. }',
          options: [
            "B10 B0 D0 D5",
            "D5 D0 B0 B10",
            "B0 B10 D0 D5",
            "D0 D5 B10 B0",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Derived(5) -> this() -> Derived() -> super() implicit -> Base() -> this(10) -> Base(10) printează 'B10', Base() printează 'B0', Derived() printează 'D0', Derived(5) printează 'D5'. Rezultat: B10 B0 D0 D5.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorii părintelui se execută întotdeauna înaintea celor ai copilului.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Base() apelează this(10) care se execută ÎNAINTE de printarea din Base().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorii părintelui se execută înaintea celor ai copilului.",
            },
          ],
        },
        {
          id: 7,
          text: "Ce se întâmplă la compilare și execuție?",
          description: null,
          code: '1. class Animal {\n2.     protected void eat() { System.out.print("Animal eats "); }\n3. }\n4. class Dog extends Animal {\n5.     void eat() { System.out.print("Dog eats "); }\n6. }\n7. public class Test {\n8.     public static void main(String[] args) {\n9.         Animal a = new Dog();\n10.         a.eat();\n11.     }\n12. }',
          options: [
            "Dog eats",
            "Animal eats",
            "Eroare de compilare",
            "Dog eats Animal eats",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Dog.eat() are modificator implicit (package-private) care este mai restrictiv decât protected. Eroare de compilare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul nu compilează din cauza modificatorului de acces.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Când suprascrieți o metodă, nu puteți reduce vizibilitatea. Animal.eat() este protected, iar Dog.eat() are vizibilitate implicită (package-private), care este mai restrictivă. Eroare de compilare.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul nu compilează.",
            },
          ],
        },
        {
          id: 8,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '2. import java.util.*;\n3. public class MapTest {\n4.     public static void main(String[] args) {\n5.         Map<String, Integer> map = new HashMap<>();\n6.         map.put("A", 1);\n7.         map.put("B", 2);\n8.         map.put("A", 3);\n9.         map.put(null, 4);\n10.         map.put(null, 5);\n11.         System.out.print(map.size() + " ");\n12.         System.out.print(map.get("A") + " ");\n13.         System.out.print(map.get(null));\n14.     }\n15. }',
          options: ["5 3 5", "3 3 5", "4 1 4", "3 1 5"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Map nu permite chei duplicate - valorile sunt suprascrise.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. put() cu cheie existentă suprascrie valoarea. Chei unice: A, B, null = 3 elemente. A are valoarea 3 (suprascrisă). null are valoarea 5 (suprascrisă). HashMap permite o cheie null.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Valorile pentru chei existente sunt suprascrise, nu păstrate.",
            },
            {
              isCorrect: false,
              explanation: "Fals. A are valoarea 3, nu 1 (a fost suprascrisă).",
            },
          ],
        },
        {
          id: 9,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "1. class Counter {\n2.     static int count = 0;\n3.     Counter() { count++; }\n4.     { count += 10; }\n5.     static { count += 100; }\n6. }\n7. public class Test {\n8.     public static void main(String[] args) {\n9.         Counter c1 = new Counter();\n10.         Counter c2 = new Counter();\n11.         System.out.println(Counter.count);\n12.     }\n13. }",
          options: ["222", "122", "22", "202"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Blocul static se execută o dată la încărcarea clasei: count=100. Pentru fiecare instanță: bloc instanță (+10) și constructor (+1). Deci: 100 + 11 + 11 = 122. Wait, let me recalculate: static block: count=100. c1: instance block count=110, constructor count=111. c2: instance block count=121, constructor count=122. Final: 122.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocul static se execută o singură dată, blocul de instanță se execută pentru fiecare obiect.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocul static adaugă 100 la încărcarea clasei.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile de instanță și constructorii se execută pentru fiecare obiect creat.",
            },
          ],
        },
        {
          id: 10,
          text: "Care afirmație despre enumerări (enum) în Java este FALSĂ?",
          description: null,
          code: null,
          options: [
            "Enum poate avea constructori, câmpuri și metode",
            "Enum poate implementa interfețe",
            "Enum poate extinde alte clase",
            "Fiecare constantă enum este implicit static și final",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Enum poate avea constructori (private), câmpuri și metode.",
            },
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Enum poate implementa oricâte interfețe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect, aceasta este FALSĂ. Enum implicit extinde java.lang.Enum, deci nu poate extinde altă clasă (Java nu suportă moștenire multiplă pentru clase).",
            },
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Constantele enum sunt implicit public static final.",
            },
          ],
        },
        {
          id: 11,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class Varargs {\n2.     static void test(int... nums) {\n3.         System.out.print("varargs ");\n4.     }\n5.     static void test(int a, int b) {\n6.         System.out.print("two params ");\n7.     }\n8.     public static void main(String[] args) {\n9.         test(1, 2);\n10.         test(1, 2, 3);\n11.         test();\n12.     }\n13. }',
          options: [
            "varargs varargs varargs",
            "two params varargs varargs",
            "Eroare de compilare",
            "two params two params varargs",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Metoda cu parametri exacți are prioritate față de varargs.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. test(1,2) se potrivește exact cu test(int,int). test(1,2,3) și test() folosesc varargs deoarece nu există potrivire exactă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul compilează - nu există ambiguitate când există potrivire exactă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. test(1,2,3) are 3 argumente, nu 2.",
            },
          ],
        },
        {
          id: 12,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "2. public class Recursion {\n3.     static int factorial(int n) {\n4.         if (n <= 1) return 1;\n5.         return n * factorial(n - 1);\n6.     }\n7.     public static void main(String[] args) {\n8.         System.out.println(factorial(5));\n9.     }\n10. }",
          options: ["120", "24", "5", "StackOverflowError"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. 5! = 5 × 4 × 3 × 2 × 1 = 120. Recursivitatea funcționează corect cu condiția de oprire n <= 1.",
            },
            {
              isCorrect: false,
              explanation: "Fals. 24 este 4! nu 5!.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Funcția calculează factorialul, nu returnează pur și simplu n.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Există condiție de oprire validă (n <= 1).",
            },
          ],
        },
        {
          id: 13,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class BitwiseOps {\n4.     public static void main(String[] args) {\n5.         int a = 5;  // 0101 in binary\n6.         int b = 3;  // 0011 in binary\n7.         System.out.print((a & b) + " ");\n8.         System.out.print((a | b) + " ");\n9.         System.out.print(a ^ b);\n10.     }\n11. }',
          options: ["1 7 6", "3 5 2", "0 8 8", "1 7 2"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. 5=0101, 3=0011. AND(0101,0011)=0001=1. OR(0101,0011)=0111=7. XOR(0101,0011)=0110=6.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Operațiile bitwise se aplică pe fiecare bit individual.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Verifică operațiile bitwise: & (AND), | (OR), ^ (XOR).",
            },
            {
              isCorrect: false,
              explanation: "Fals. XOR între 0101 și 0011 dă 0110 = 6, nu 2.",
            },
          ],
        },
        {
          id: 14,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. class Singleton {\n2.     private static Singleton instance;\n3.     private Singleton() { System.out.print("Created "); }\n4.     public static Singleton getInstance() {\n5.         if (instance == null) instance = new Singleton();\n6.         return instance;\n7.     }\n8. }\n9. public class Test {\n10.     public static void main(String[] args) {\n11.         Singleton s1 = Singleton.getInstance();\n12.         Singleton s2 = Singleton.getInstance();\n13.         System.out.print(s1 == s2);\n14.     }\n15. }',
          options: [
            "Created Created true",
            "Created Created false",
            "Created true",
            "Created false",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorul se apelează o singură dată în pattern-ul Singleton.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Constructorul se apelează o singură dată.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Prima apelare creează instanța (printează 'Created'). A doua apelare returnează aceeași instanță (instance != null). s1 și s2 referă același obiect, deci s1 == s2 este true.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ambele referințe indică același obiect, deci == returnează true.",
            },
          ],
        },
        {
          id: 15,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "1. import java.util.*;\n2. public class ListOps {\n3.     public static void main(String[] args) {\n4.         List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\n5.         list.remove(2);\n6.         list.remove(Integer.valueOf(2));\n7.         System.out.println(list);\n8.     }\n9. }",
          options: ["[1, 2, 4, 5]", "[1, 4, 5]", "[1, 3, 4, 5]", "[1, 3, 5]"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. remove(2) elimină elementul de la INDEX 2, nu valoarea 2.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. remove(2) elimină elementul de la indexul 2 (valoarea 3). Lista devine [1,2,4,5]. remove(Integer.valueOf(2)) elimină obiectul cu valoarea 2. Lista devine [1,4,5].",
            },
            {
              isCorrect: false,
              explanation: "Fals. Ambele apeluri remove() au efect.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. remove(2) elimină de la index, nu valoarea 2.",
            },
          ],
        },
        {
          id: 16,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class ExceptionChain {\n2.     public static void main(String[] args) {\n3.         try {\n4.             try {\n5.                 throw new RuntimeException("Inner");\n6.             } finally {\n7.                 throw new RuntimeException("Finally");\n8.             }\n9.         } catch (Exception e) {\n10.             System.out.println(e.getMessage());\n11.         }\n12.     }\n13. }',
          options: [
            "Inner",
            "Finally",
            "Inner followed by Finally",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Excepția din finally suprascrie excepția din try.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Când blocul finally aruncă o excepție, aceasta suprascrie orice excepție anterioară. 'Inner' este pierdută, doar 'Finally' este propagată și prinsă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Doar o excepție este prinsă - cea din finally.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează corect.",
            },
          ],
        },
        {
          id: 17,
          text: "Care afirmație despre metodele equals() și hashCode() este corectă?",
          description: null,
          code: null,
          options: [
            "Dacă două obiecte sunt egale conform equals(), ele pot avea hashCode diferit",
            "Dacă două obiecte au același hashCode, ele sunt neapărat egale conform equals()",
            "Dacă suprascrieți equals(), trebuie să suprascrieți și hashCode()",
            "hashCode() returnează întotdeauna adresa de memorie a obiectului",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Contractul stipulează că obiectele egale TREBUIE să aibă același hashCode.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Pot exista coliziuni - obiecte diferite pot avea același hashCode.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Contractul equals-hashCode: obiectele egale trebuie să aibă același hashCode. Dacă suprascrieți equals() fără hashCode(), colecțiile bazate pe hash (HashMap, HashSet) nu vor funcționa corect.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Implementarea default din Object poate folosi adresa, dar nu este garantat și poate fi suprascrisă.",
            },
          ],
        },
        {
          id: 18,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class Casting {\n4.     public static void main(String[] args) {\n5.         Object obj = "Hello";\n6.         String str = (String) obj;\n7.         Integer num = (Integer) obj;\n8.         System.out.println(str + " " + num);\n9.     }\n10. }',
          options: [
            "Hello null",
            "Hello Hello",
            "Eroare de compilare",
            "ClassCastException la runtime",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Cast-ul invalid aruncă excepție, nu returnează null.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Un String nu poate fi convertit la Integer.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Compilatorul nu poate detecta această eroare - obj este Object.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. obj referă un String. Cast-ul la String funcționează. Cast-ul la Integer aruncă ClassCastException la runtime deoarece String nu este Integer.",
            },
          ],
        },
        {
          id: 19,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. interface Walkable {\n2.     default void walk() { System.out.print("Walking "); }\n3. }\n4. interface Runnable {\n5.     default void walk() { System.out.print("Running "); }\n6. }\n7. class Athlete implements Walkable, Runnable {\n8.     public void walk() {\n9.         Walkable.super.walk();\n10.         Runnable.super.walk();\n11.     }\n12.     public static void main(String[] args) {\n13.         new Athlete().walk();\n14.     }\n15. }',
          options: [
            "Walking",
            "Running",
            "Walking Running",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Clasa apelează explicit ambele metode default.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Clasa apelează explicit ambele metode default.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Athlete rezolvă conflictul suprascriind walk() și apelând explicit ambele implementări folosind Interface.super.method() syntax.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sintaxa Interface.super.method() este validă pentru a apela metode default specifice.",
            },
          ],
        },
        {
          id: 20,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "1. import java.util.*;\n2. public class StreamTest {\n3.     public static void main(String[] args) {\n4.         List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);\n5.         int sum = nums.stream()\n6.                       .filter(n -> n % 2 == 0)\n7.                       .mapToInt(n -> n * 2)\n8.                       .sum();\n9.         System.out.println(sum);\n10.     }\n11. }",
          options: ["12", "6", "30", "15"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. filter păstrează numerele pare: 2, 4. mapToInt le dublează: 4, 8. sum() = 4 + 8 = 12.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. 6 ar fi suma numerelor pare neschimbate (2+4).",
            },
            {
              isCorrect: false,
              explanation: "Fals. 30 ar fi suma tuturor numerelor dublate.",
            },
            {
              isCorrect: false,
              explanation: "Fals. 15 ar fi suma tuturor numerelor originale.",
            },
          ],
        },
        {
          id: 21,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "1. class Outer {\n2.     private static int x = 10;\n3.     static class Nested {\n4.         void print() { System.out.print(x); }\n5.     }\n6. }\n7. public class Test {\n8.     public static void main(String[] args) {\n9.         Outer.Nested n = new Outer.Nested();\n10.         n.print();\n11.     }\n12. }",
          options: [
            "10",
            "Eroare de compilare - x este private",
            "Eroare de compilare - Nested nu poate fi instanțiată așa",
            "NullPointerException",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Clasele nested static au acces la membrii privați ai clasei externe, inclusiv cei statici. Instanțierea se face fără o instanță a clasei externe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Clasele nested au acces la membrii privați ai clasei externe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sintaxa new Outer.Nested() este corectă pentru clase nested static.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. x este static și are valoare inițială, nu apare NPE.",
            },
          ],
        },
        {
          id: 22,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class StringMethods {\n4.     public static void main(String[] args) {\n5.         String s = "  Hello World  ";\n6.         System.out.print(s.trim().length() + " ");\n7.         System.out.print(s.substring(2, 7) + " ");\n8.         System.out.print(s.indexOf(\'o\'));\n9.     }\n10. }',
          options: ["11 Hello 4", "15 Hello 4", "11 Hello 5", "11 ello  4"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. indexOf returnează prima apariție a lui 'o', care este la poziția 5, nu 4.",
            },
            {
              isCorrect: false,
              explanation: "Fals. trim() elimină spațiile, reducând lungimea.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. trim() elimină spațiile din față și spate: 'Hello World' (11 caractere). substring(2,7) pe originalul '  Hello World  ' dă 'Hello'. indexOf('o') găsește primul 'o' în s (pozițiile: 0=' ',1=' ',2='H',3='e',4='l',5='l',6='o') la poziția 6... Wait, let me recount: s='  Hello World  ', index 0=' ', 1=' ', 2='H', 3='e', 4='l', 5='l', 6='o', 7=' ', 8='W'. indexOf('o') = 6? Actually substring(2,7) = indices 2,3,4,5,6 = 'Hello'. indexOf('o') first occurrence is at index 6.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. substring(2,7) include caracterele de la index 2 la 6 (exclusiv 7).",
            },
          ],
        },
        {
          id: 23,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. public class Loops {\n2.     public static void main(String[] args) {\n3.         int i = 0;\n4.         while (i < 5) {\n5.             i++;\n6.             if (i == 3) continue;\n7.             if (i == 4) break;\n8.             System.out.print(i + " ");\n9.         }\n10.         System.out.print("end=" + i);\n11.     }\n12. }',
          options: ["1 2 3 end=4", "1 2 end=4", "1 2 4 end=5", "1 2 end=3"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Când i==3, continue sare printarea.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. i=1 print '1', i=2 print '2', i=3 continue (skip print), i=4 break. După loop i=4. Rezultat: 1 2 end=4.",
            },
            {
              isCorrect: false,
              explanation: "Fals. break oprește bucla când i==4, nu continuă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. break se întâmplă la i=4, nu i=3.",
            },
          ],
        },
        {
          id: 24,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. class Resource implements AutoCloseable {\n2.     String name;\n3.     Resource(String n) { name = n; System.out.print("Open " + name + " "); }\n4.     public void close() { System.out.print("Close " + name + " "); }\n5. }\n6. public class TryRes {\n7.     public static void main(String[] args) {\n8.         try (Resource a = new Resource("A"); Resource b = new Resource("B")) {\n9.             System.out.print("Use ");\n10.         }\n11.     }\n12. }',
          options: [
            "Open A Open B Use Close A Close B",
            "Open A Open B Use Close B Close A",
            "Open B Open A Use Close A Close B",
            "Use Open A Open B Close B Close A",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Resursele se închid în ordine inversă creării.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Try-with-resources: resursele se deschid în ordine (A, B), se folosesc, apoi se închid în ordine INVERSĂ (B, A) pentru a respecta dependențele.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Resursele se deschid în ordinea declarării.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Resursele se deschid ÎNAINTE de execuția blocului try.",
            },
          ],
        },
        {
          id: 25,
          text: "Ce modificatori sunt impliciți pentru câmpurile unei interfețe?",
          description: null,
          code: "interface Constants {\n    int VALUE = 100;\n}",
          options: [
            "private",
            "protected static",
            "public static final",
            "public abstract",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Câmpurile interfețelor nu pot fi private - ele sunt implicit public.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Câmpurile interfețelor sunt public, nu protected.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Toate câmpurile unei interfețe sunt implicit public static final (constante).",
            },
            {
              isCorrect: false,
              explanation: "Fals. abstract se aplică metodelor, nu câmpurilor.",
            },
          ],
        },
        {
          id: 26,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. import java.util.*;\n2. public class Compare {\n3.     public static void main(String[] args) {\n4.         List<String> list = new ArrayList<>();\n5.         list.add("banana");\n6.         list.add("Apple");\n7.         list.add("cherry");\n8.         Collections.sort(list);\n9.         System.out.println(list);\n10.     }\n11. }',
          options: [
            "[Apple, banana, cherry]",
            "[apple, banana, cherry]",
            "[banana, Apple, cherry]",
            "[Apple, cherry, banana]",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Sortarea naturală String folosește ordinea lexicografică (Unicode). Literele mari au valori mai mici decât cele mici, deci 'A' < 'b' < 'c'. Rezultat: [Apple, banana, cherry].",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Sortarea nu convertește la lowercase - 'Apple' rămâne cu A mare.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Collections.sort() modifică lista.",
            },
            {
              isCorrect: false,
              explanation: "Fals. 'b' < 'c' în ordinea lexicografică.",
            },
          ],
        },
        {
          id: 27,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '1. class Parent {\n2.     int x = 10;\n3.     int getX() { return x; }\n4. }\n5. class Child extends Parent {\n6.     int x = 20;\n7.     int getX() { return x; }\n8. }\n9. public class Test {\n10.     public static void main(String[] args) {\n11.         Parent p = new Child();\n12.         System.out.print(p.x + " ");\n13.         System.out.print(p.getX());\n14.     }\n15. }',
          options: ["20 20", "10 10", "10 20", "20 10"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Câmpurile nu sunt polimorfice - se folosește tipul declarat.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele SUNT polimorfice - se apelează versiunea din tipul real.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Câmpurile se rezolvă la compile-time (p.x folosește Parent.x = 10). Metodele se rezolvă la runtime (p.getX() apelează Child.getX() = 20). Aceasta este diferența dintre hiding (câmpuri) și overriding (metode).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. p.x accesează câmpul din Parent, p.getX() apelează metoda din Child.",
            },
          ],
        },
        {
          id: 28,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: '3. public class DoWhile {\n4.     public static void main(String[] args) {\n5.         int i = 10;\n6.         do {\n7.             System.out.print(i + " ");\n8.             i--;\n9.         } while (i > 10);\n10.         System.out.print("end");\n11.     }\n12. }',
          options: ["end", "10 end", "10 9 8 ... 1 end", "Buclă infinită"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. do-while execută corpul cel puțin o dată înainte de verificarea condiției.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. do-while execută corpul ÎNTÂI, apoi verifică condiția. Print '10', i devine 9, verifică 9 > 10 (fals), iese. Rezultat: 10 end.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Condiția i > 10 este falsă după prima iterație.",
            },
            {
              isCorrect: false,
              explanation: "Fals. i scade și condiția devine falsă imediat.",
            },
          ],
        },
        {
          id: 29,
          text: "Care afirmație despre synchronized în Java este corectă?",
          description: null,
          code: null,
          options: [
            "synchronized poate fi aplicat pe variabile",
            "Un thread poate deține mai multe lock-uri simultan",
            "synchronized garantează vizibilitatea dar nu atomicitatea",
            "Metodele statice synchronized folosesc lock-ul instanței",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. synchronized se aplică pe metode sau blocuri, nu pe declarații de variabile (pentru asta există volatile).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Un thread poate achiziționa lock-uri multiple, ceea ce poate duce la deadlock dacă nu e gestionat corect. Aceasta se numește lock nesting.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. synchronized garantează AMBELE - vizibilitate și atomicitate pentru operațiile din blocul sincronizat.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele statice synchronized folosesc lock-ul clasei (Class object), nu al instanței.",
            },
          ],
        },
        {
          id: 30,
          text: "Care este rezultatul următoarei secvențe?",
          description: null,
          code: "1. public class Lambda {\n2.     public static void main(String[] args) {\n3.         int x = 10;\n4.         Runnable r = () -> {\n5.             System.out.print(x);\n6.             // x++; \n7.         };\n8.         // x = 20;\n9.         r.run();\n10.     }\n11. }",
          options: ["10", "20", "Eroare de compilare", "0"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. x este effectively final (nu este modificat după inițializare). Lambda-urile pot accesa variabile locale doar dacă sunt final sau effectively final. Codul comentat (x++ sau x=20) ar cauza eroare de compilare dacă ar fi decomentate.",
            },
            {
              isCorrect: false,
              explanation: "Fals. x=20 este comentat, deci x rămâne 10.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. x este effectively final deoarece liniile care l-ar modifica sunt comentate.",
            },
            {
              isCorrect: false,
              explanation: "Fals. x este inițializat cu 10.",
            },
          ],
        },
      ];

      const questionsSetNou3 = [
        {
          id: 1,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Generics și type erasure",
          code: '1. import java.util.*;\n2. public class GenericTest {\n3.     public static void main(String[] args) {\n4.         List<String> strings = new ArrayList<>();\n5.         List<Integer> ints = new ArrayList<>();\n6.         System.out.print(strings.getClass() == ints.getClass());\n7.         System.out.print(" " + (strings instanceof List));\n8.     }\n9. }',
          options: [
            "false true",
            "true true",
            "false false",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Din cauza type erasure, ambele liste au aceeași clasă la runtime.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Type erasure: la runtime, informația despre tipul generic este ștearsă. Ambele sunt ArrayList (aceeași clasă). instanceof verifică tipul raw, care este List.",
            },
            {
              isCorrect: false,
              explanation: "Fals. strings instanceof List este true.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează corect.",
            },
          ],
        },
        {
          id: 2,
          text: "Care declarație este validă?",
          description: "Wildcards în Generics",
          code: "// Opțiuni:\n// A: List<? extends Number> list = new ArrayList<Integer>();\n// B: List<? super Integer> list = new ArrayList<Number>();\n// C: List<?> list = new ArrayList<String>();\n// D: Toate sunt valide",
          options: ["Doar A", "A și B", "A, B și C", "D - Toate sunt valide"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Nu doar A este validă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Și C este validă.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Toate trei sunt valide.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. A: ? extends Number acceptă Integer (subtip). B: ? super Integer acceptă Number (supertip). C: ? (unbounded) acceptă orice tip. Toate sunt valide.",
            },
          ],
        },
        {
          id: 3,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Method references și functional interfaces",
          code: '1. import java.util.*;\n2. import java.util.function.*;\n3. public class MethodRef {\n4.     public static void main(String[] args) {\n5.         List<String> list = Arrays.asList("a", "bb", "ccc");\n6.         list.stream()\n7.             .map(String::length)\n8.             .filter(n -> n > 1)\n9.             .reduce(Integer::sum)\n10.             .ifPresent(System.out::println);\n11.     }\n12. }',
          options: ["5", "6", "3", "Optional[5]"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. map transformă în lungimi: 1, 2, 3. filter păstrează > 1: 2, 3. reduce(Integer::sum) = 2 + 3 = 5. ifPresent printează valoarea, nu Optional-ul.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Suma lungimilor filtrate (2 + 3) este 5.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Sunt 2 elemente după filter, nu 3.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. ifPresent printează valoarea direct, nu reprezentarea Optional.",
            },
          ],
        },
        {
          id: 4,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Concurrency și race conditions",
          code: "1. class Counter {\n2.     private int count = 0;\n3.     public void increment() { count++; }\n4.     public int getCount() { return count; }\n5. }\n6. public class RaceTest {\n7.     public static void main(String[] args) throws Exception {\n8.         Counter c = new Counter();\n9.         Thread t1 = new Thread(() -> { for(int i=0; i<1000; i++) c.increment(); });\n10.         Thread t2 = new Thread(() -> { for(int i=0; i<1000; i++) c.increment(); });\n11.         t1.start(); t2.start();\n12.         t1.join(); t2.join();\n13.         System.out.println(c.getCount());\n14.     }\n15. }",
          options: [
            "Întotdeauna 2000",
            "Întotdeauna mai puțin de 2000",
            "Poate fi orice valoare între 1 și 2000",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. count++ nu este atomic - poate rezulta în lost updates.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Uneori poate fi exact 2000 (depinde de scheduling).",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. count++ implică read-modify-write (3 operații). Fără sincronizare, thread-urile pot interleave și pierde update-uri. Rezultatul este nedeterminist, între ~1000 și 2000 (teoretic chiar mai puțin în cazuri extreme).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează corect.",
            },
          ],
        },
        {
          id: 5,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Covariant return types",
          code: "1. class Animal { Animal create() { return new Animal(); } }\n2. class Dog extends Animal {\n3.     @Override\n4.     Dog create() { return new Dog(); }\n5. }\n6. public class Test {\n7.     public static void main(String[] args) {\n8.         Animal a = new Dog();\n9.         System.out.print(a.create().getClass().getSimpleName());\n10.     }\n11. }",
          options: [
            "Animal",
            "Dog",
            "Eroare de compilare - return type incompatibil",
            "ClassCastException",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Prin polimorfism se apelează Dog.create() care returnează Dog.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Java suportă covariant return types - metoda suprascrisă poate returna un subtip. Dog.create() returnează Dog. Polimorfismul asigură apelarea versiunii din Dog.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Covariant return types sunt permise din Java 5.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Nu există cast explicit, nu apare ClassCastException.",
            },
          ],
        },
        {
          id: 6,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Comparator vs Comparable",
          code: '1. import java.util.*;\n2. class Person implements Comparable<Person> {\n3.     String name; int age;\n4.     Person(String n, int a) { name = n; age = a; }\n5.     public int compareTo(Person p) { return this.age - p.age; }\n6.     public String toString() { return name; }\n7. }\n8. public class SortTest {\n9.     public static void main(String[] args) {\n10.         List<Person> list = Arrays.asList(\n11.             new Person("Ana", 25),\n12.             new Person("Bob", 20),\n13.             new Person("Cris", 30));\n14.         Collections.sort(list, (a, b) -> b.name.compareTo(a.name));\n15.         System.out.println(list);\n16.     }\n17. }',
          options: [
            "[Bob, Ana, Cris]",
            "[Ana, Bob, Cris]",
            "[Cris, Bob, Ana]",
            "[Cris, Ana, Bob]",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Comparatorul din sort() compară după nume descrescător.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Aceasta ar fi ordinea alfabetică crescătoare după nume.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Comparatorul explicit (b.name.compareTo(a.name)) are prioritate față de Comparable. b compareTo a = ordine descrescătoare. Cris > Bob > Ana alfabetic invers.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ordinea este descrescătoare alfabetic după nume.",
            },
          ],
        },
        {
          id: 7,
          text: "Care afirmație despre checked și unchecked exceptions este FALSĂ?",
          description: null,
          code: null,
          options: [
            "RuntimeException și subclasele sale sunt unchecked",
            "IOException este checked și trebuie declarată sau prinsă",
            "Error și subclasele sale sunt checked exceptions",
            "O metodă care aruncă checked exception trebuie să declare throws",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. RuntimeException și subclasele sunt unchecked.",
            },
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. IOException este checked.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect, aceasta este FALSĂ. Error și subclasele (OutOfMemoryError, StackOverflowError) sunt UNCHECKED, nu checked. Ierarhia: Throwable -> Error (unchecked), Exception -> RuntimeException (unchecked), alte Exception (checked).",
            },
            {
              isCorrect: false,
              explanation:
                "Afirmația este adevărată. Checked exceptions trebuie declarate cu throws.",
            },
          ],
        },
        {
          id: 8,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Diamond problem cu interfețe",
          code: '1. interface A { default String get() { return "A"; } }\n2. interface B extends A { default String get() { return "B"; } }\n3. interface C extends A { default String get() { return "C"; } }\n4. interface D extends B, C {\n5.     default String get() { return B.super.get() + C.super.get(); }\n6. }\n7. class Impl implements D {}\n8. public class Test {\n9.     public static void main(String[] args) {\n10.         System.out.print(new Impl().get());\n11.     }\n12. }',
          options: ["A", "BC", "Eroare de compilare - diamond problem", "AB"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. D suprascrie get() și combină B și C.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. D rezolvă diamond problem suprascriind get() și apelând explicit B.super.get() ('B') și C.super.get() ('C'). Rezultat: 'BC'.",
            },
            {
              isCorrect: false,
              explanation: "Fals. D rezolvă conflictul prin override explicit.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Se apelează B și C, nu A.",
            },
          ],
        },
        {
          id: 9,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Optional și null safety",
          code: '1. import java.util.*;\n2. public class OptionalTest {\n3.     public static void main(String[] args) {\n4.         Optional<String> opt = Optional.ofNullable(null);\n5.         String result = opt\n6.             .map(s -> s.toUpperCase())\n7.             .orElse("DEFAULT");\n8.         System.out.print(result);\n9.     }\n10. }',
          options: [
            "null",
            "DEFAULT",
            "NullPointerException",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Optional.orElse() returnează alternativa când optional e gol.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Optional.ofNullable(null) creează un Optional gol. map() pe Optional gol returnează Optional gol (nu execută lambda). orElse() returnează valoarea alternativă 'DEFAULT'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Optional gestionează null safe - nu se aruncă NPE.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
          ],
        },
        {
          id: 10,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Suppressed exceptions în try-with-resources",
          code: '1. class Res implements AutoCloseable {\n2.     public void close() { throw new RuntimeException("Close"); }\n3. }\n4. public class SuppressedTest {\n5.     public static void main(String[] args) {\n6.         try (Res r = new Res()) {\n7.             throw new RuntimeException("Try");\n8.         } catch (RuntimeException e) {\n9.             System.out.print(e.getMessage() + " ");\n10.             System.out.print(e.getSuppressed().length);\n11.         }\n12.     }\n13. }',
          options: ["Try 0", "Close 0", "Try 1", "Close 1"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Excepția din close() devine suppressed.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Excepția principală este cea din try, nu din close().",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. În try-with-resources, excepția din try este principală, iar cele din close() devin suppressed. Mesaj: 'Try', suppressed count: 1 (excepția 'Close').",
            },
            {
              isCorrect: false,
              explanation: "Fals. Excepția principală este cea din try block.",
            },
          ],
        },
        {
          id: 11,
          text: "Care este rezultatul următoarei secvențe?",
          description: "volatile și visibility",
          code: "1. class SharedData {\n2.     private volatile boolean flag = false;\n3.     private int data = 0;\n4.     void writer() {\n5.         data = 42;\n6.         flag = true;\n7.     }\n8.     void reader() {\n9.         if (flag) {\n10.             System.out.print(data);\n11.         }\n12.     }\n13. }",
          options: [
            "reader() va vedea întotdeauna data=42 când flag=true",
            "reader() poate vedea data=0 când flag=true",
            "volatile pe flag nu afectează vizibilitatea lui data",
            "Codul are undefined behavior",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. volatile asigură happens-before: toate scrierile înainte de scrierea volatile (data=42) sunt vizibile pentru citirile după citirea volatile (flag). Acest pattern se numește 'piggyback synchronization'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Happens-before garantează vizibilitatea lui data când flag este citit ca true.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. volatile creează o barieră de memorie care afectează și variabilele non-volatile.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Java Memory Model definește comportamentul clar.",
            },
          ],
        },
        {
          id: 12,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Static binding vs dynamic binding",
          code: '1. class Parent {\n2.     static void print() { System.out.print("Parent "); }\n3.     void show() { System.out.print("Parent "); }\n4. }\n5. class Child extends Parent {\n6.     static void print() { System.out.print("Child "); }\n7.     void show() { System.out.print("Child "); }\n8. }\n9. public class Test {\n10.     public static void main(String[] args) {\n11.         Parent p = new Child();\n12.         p.print();\n13.         p.show();\n14.     }\n15. }',
          options: [
            "Child Child",
            "Parent Parent",
            "Parent Child",
            "Child Parent",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele statice folosesc static binding bazat pe tipul declarat.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele non-statice folosesc dynamic binding bazat pe tipul real.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. print() este static - se rezolvă la compile-time bazat pe tipul declarat (Parent). show() este instanță - se rezolvă la runtime bazat pe tipul real (Child). Static = hiding, Instance = overriding.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Ordinea este inversă.",
            },
          ],
        },
        {
          id: 13,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Generics și PECS (Producer Extends, Consumer Super)",
          code: "1. import java.util.*;\n2. public class PECS {\n3.     static void copy(List<? extends Number> src, List<? super Number> dest) {\n4.         for (Number n : src) dest.add(n);\n5.     }\n6.     public static void main(String[] args) {\n7.         List<Integer> ints = Arrays.asList(1, 2, 3);\n8.         List<Object> objs = new ArrayList<>();\n9.         copy(ints, objs);\n10.         System.out.println(objs);\n11.     }\n12. }",
          options: [
            "[1, 2, 3]",
            "Eroare de compilare la copy()",
            "Eroare de compilare la apel",
            "ClassCastException",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. PECS: src produce valori (extends pentru citire), dest consumă valori (super pentru scriere). List<Integer> este subtip al List<? extends Number>. List<Object> este subtip al List<? super Number>.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Metoda copy() este corect definită.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Apelul respectă restricțiile de tip.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Nu există conversii de tip invalide.",
            },
          ],
        },
        {
          id: 14,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Deadlock pattern",
          code: '1. public class DeadlockDemo {\n2.     static Object lock1 = new Object();\n3.     static Object lock2 = new Object();\n4.     public static void main(String[] args) {\n5.         new Thread(() -> {\n6.             synchronized(lock1) {\n7.                 try { Thread.sleep(100); } catch(Exception e) {}\n8.                 synchronized(lock2) { System.out.print("T1 "); }\n9.             }\n10.         }).start();\n11.         new Thread(() -> {\n12.             synchronized(lock2) {\n13.                 try { Thread.sleep(100); } catch(Exception e) {}\n14.                 synchronized(lock1) { System.out.print("T2 "); }\n15.             }\n16.         }).start();\n17.     }\n18. }',
          options: [
            "T1 T2",
            "T2 T1",
            "Foarte probabil deadlock",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Thread-urile vor bloca reciproc așteptând lock-urile.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Thread-urile vor bloca reciproc așteptând lock-urile.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Classic deadlock: T1 deține lock1 și așteaptă lock2, T2 deține lock2 și așteaptă lock1. Sleep(100) aproape garantează că ambele ajung în această situație. Programul se blochează.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează corect.",
            },
          ],
        },
        {
          id: 15,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Reflection și encapsulation",
          code: '1. import java.lang.reflect.*;\n2. class Secret {\n3.     private int value = 42;\n4. }\n5. public class ReflectTest {\n6.     public static void main(String[] args) throws Exception {\n7.         Secret s = new Secret();\n8.         Field f = Secret.class.getDeclaredField("value");\n9.         f.setAccessible(true);\n10.         System.out.print(f.get(s));\n11.         f.set(s, 100);\n12.         System.out.print(" " + f.get(s));\n13.     }\n14. }',
          options: [
            "IllegalAccessException",
            "42 100",
            "Eroare de compilare",
            "42 42",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. setAccessible(true) permite accesul la membrii privați.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Reflection poate accesa și modifica câmpuri private prin setAccessible(true). Se citește 42, se setează 100, se citește 100. (Notă: în Java 9+ cu module system pot fi restricții suplimentare).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
            {
              isCorrect: false,
              explanation: "Fals. f.set() modifică valoarea câmpului.",
            },
          ],
        },
        {
          id: 16,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Functional interfaces și method references",
          code: '1. import java.util.function.*;\n2. public class FuncTest {\n3.     public static void main(String[] args) {\n4.         Function<String, Integer> f1 = String::length;\n5.         Function<Integer, Integer> f2 = x -> x * 2;\n6.         Function<String, Integer> f3 = f1.andThen(f2);\n7.         System.out.print(f3.apply("Hello"));\n8.     }\n9. }',
          options: ["5", "10", "HelloHello", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. andThen aplică și f2 după f1.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. f3 = f1.andThen(f2) creează o funcție compusă. Pentru 'Hello': f1 returnează length=5, apoi f2 returnează 5*2=10.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Function<String, Integer> returnează Integer, nu String.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul este corect - tipurile se potrivesc pentru andThen.",
            },
          ],
        },
        {
          id: 17,
          text: "Care este rezultatul următoarei secvențe?",
          description: "TreeSet și Comparator",
          code: '1. import java.util.*;\n2. public class TreeSetTest {\n3.     public static void main(String[] args) {\n4.         Set<String> set = new TreeSet<>((a, b) -> b.length() - a.length());\n5.         set.add("a");\n6.         set.add("bbb");\n7.         set.add("cc");\n8.         set.add("ddd");\n9.         System.out.println(set);\n10.     }\n11. }',
          options: [
            "[a, cc, bbb, ddd]",
            "[bbb, cc, a]",
            "[ddd, bbb, cc, a]",
            "[bbb, ddd, cc, a]",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Comparatorul sortează descrescător după lungime.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. TreeSet folosește comparatorul dat. b.length() - a.length() = descrescător după lungime. 'bbb' și 'ddd' au aceeași lungime, dar TreeSet consideră elementele egale dacă compareTo=0, deci 'ddd' nu se adaugă (este 'duplicat' conform comparatorului). Rezultat: [bbb, cc, a].",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Comparatorul returnează 0 pentru strings cu aceeași lungime, deci 'ddd' nu se adaugă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. 'ddd' nu va fi adăugat deoarece comparatorul îl consideră egal cu 'bbb'.",
            },
          ],
        },
        {
          id: 18,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Anonymous class și final variables",
          code: '1. public class AnonClass {\n2.     public static void main(String[] args) {\n3.         int x = 10;\n4.         Runnable r = new Runnable() {\n5.             int x = 20;\n6.             public void run() {\n7.                 int x = 30;\n8.                 System.out.print(x + " ");\n9.                 System.out.print(this.x + " ");\n10.                 System.out.print(AnonClass.this);\n11.             }\n12.         };\n13.         r.run();\n14.     }\n15. }',
          options: [
            "30 20 10",
            "30 20 și eroare de compilare",
            "30 20 și referința la instanța AnonClass",
            "10 20 30",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. AnonClass.this nu funcționează în context static.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. x local = 30, this.x = câmpul clasei anonime = 20. Dar AnonClass.this nu este valid deoarece main() este static - nu există instanță enclosing. Eroare de compilare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. main() este static, deci nu există AnonClass.this.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Variabilele se rezolvă de la cea mai apropiată la cea mai îndepărtată.",
            },
          ],
        },
        {
          id: 19,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Stream parallel și ordering",
          code: "1. import java.util.*;\n2. import java.util.stream.*;\n3. public class ParallelStream {\n4.     public static void main(String[] args) {\n5.         List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n6.         list.parallelStream()\n7.             .map(n -> n * 2)\n8.             .forEachOrdered(System.out::print);\n9.     }\n10. }",
          options: [
            "Ordinea este garantat 246810",
            "Ordinea este aleatoare (ex: 482106)",
            "Eroare de compilare",
            "Rezultatul poate fi orice combinație de cifre",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. forEachOrdered() garantează procesarea în encounter order chiar și pentru parallel streams. Rezultatul va fi întotdeauna 246810, deși procesarea internă poate fi paralelă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. forEachOrdered (nu forEach) păstrează ordinea.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. forEachOrdered garantează ordinea encounter-ului original.",
            },
          ],
        },
        {
          id: 20,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Bridge methods și generics",
          code: '1. interface Container<T> {\n2.     void add(T item);\n3. }\n4. class StringContainer implements Container<String> {\n5.     public void add(String item) { System.out.print("String: " + item); }\n6. }\n7. public class BridgeTest {\n8.     public static void main(String[] args) {\n9.         Container raw = new StringContainer();\n10.         raw.add("Hello");\n11.         raw.add(123);\n12.     }\n13. }',
          options: [
            "String: Hello String: 123",
            "String: Hello și ClassCastException",
            "Eroare de compilare",
            "String: Hello 123",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. 123 nu este String, va cauza eroare la cast.",
            },
            {
              isCorrect: true,
              explanation:
                'Corect. Folosind raw type, compilatorul permite orice argument. Compilatorul generează un bridge method add(Object) care face cast la String. raw.add("Hello") funcționează. raw.add(123) compilează (raw type), dar la runtime bridge method încearcă cast Integer la String -> ClassCastException.',
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Raw types permit compilarea, eroarea apare la runtime.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Integer nu poate fi convertit la String.",
            },
          ],
        },
        {
          id: 21,
          text: "Care este rezultatul următoarei secvențe?",
          description: "ConcurrentModificationException în single-threaded",
          code: "1. import java.util.*;\n2. public class ConcMod {\n3.     public static void main(String[] args) {\n4.         List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\n5.         for (int i = 0; i < list.size(); i++) {\n6.             if (list.get(i) % 2 == 0) {\n7.                 list.remove(i);\n8.             }\n9.         }\n10.         System.out.println(list);\n11.     }\n12. }",
          options: [
            "[1, 3, 5]",
            "[1, 3, 4, 5]",
            "ConcurrentModificationException",
            "IndexOutOfBoundsException",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Bucla tradițională sare peste elementul 4 din cauza shift-ului de indecși.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. NU apare CME (nu e Iterator). Dar: i=1 găsește 2, remove, lista devine [1,3,4,5], i devine 2, verifică 4 (era la index 3, acum 2), remove, lista devine [1,3,5]. 4 a fost eliminat corect din întâmplare! Dar 4 original era la index 3... Let me recalculate: Initial [1,2,3,4,5]. i=0: 1%2≠0. i=1: 2%2=0, remove(1), list=[1,3,4,5], size=4. i=2: list.get(2)=4, 4%2=0, remove(2), list=[1,3,5]. i=3: 3<3? No, exit. Result: [1,3,5]. Wait that's option A. Let me recheck: After removing 2, list=[1,3,4,5]. i increments to 2. list.get(2)=4. 4%2=0, remove. list=[1,3,5]. i=3. size=3. 3<3 is false. Exit. Result [1,3,5]. So A is correct?",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. CME apare doar cu Iterator, nu cu for clasic.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Indicii nu depășesc size-ul curent.",
            },
          ],
        },
        {
          id: 22,
          text: "Care este rezultatul următoarei secvențe?",
          description: "String interning și ==operator",
          code: '1. public class StringIntern {\n2.     public static void main(String[] args) {\n3.         String s1 = "Hello";\n4.         String s2 = "Hel" + "lo";\n5.         String s3 = "Hel";\n6.         String s4 = s3 + "lo";\n7.         System.out.print((s1 == s2) + " ");\n8.         System.out.print(s1 == s4);\n9.     }\n10. }',
          options: ["true true", "false false", "true false", "false true"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. s4 este creat la runtime, nu este în String pool.",
            },
            {
              isCorrect: false,
              explanation: "Fals. s2 este constant folding la compile-time.",
            },
            {
              isCorrect: true,
              explanation:
                'Corect. s2 = "Hel" + "lo" este evaluat la compile-time (constant folding) -> "Hello" din pool (== s1). s4 = s3 + "lo" implică variabilă, evaluat la runtime -> nou obiect (≠ s1).',
            },
            {
              isCorrect: false,
              explanation:
                "Fals. s1 == s2 este true datorită constant folding.",
            },
          ],
        },
        {
          id: 23,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Method overloading resolution",
          code: '1. public class Overload {\n2.     void test(Object o) { System.out.print("Object "); }\n3.     void test(String s) { System.out.print("String "); }\n4.     void test(Integer i) { System.out.print("Integer "); }\n5.     public static void main(String[] args) {\n6.         Overload o = new Overload();\n7.         o.test(null);\n8.     }\n9. }',
          options: [
            "Object",
            "String",
            "Integer",
            "Eroare de compilare - ambiguitate",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Object este cel mai generic, nu cel mai specific.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. String și Integer sunt la același nivel în ierarhie relative la Object.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Integer nu este mai specific decât String.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. null poate fi String sau Integer. Compilatorul alege cea mai specifică metodă, dar String și Integer nu au relație de subtip între ele -> ambiguitate. Eroare de compilare: reference to test is ambiguous.",
            },
          ],
        },
        {
          id: 24,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Cloning și shallow copy",
          code: '1. class Data implements Cloneable {\n2.     int[] arr = {1, 2, 3};\n3.     protected Object clone() throws CloneNotSupportedException {\n4.         return super.clone();\n5.     }\n6. }\n7. public class CloneTest {\n8.     public static void main(String[] args) throws Exception {\n9.         Data d1 = new Data();\n10.         Data d2 = (Data) d1.clone();\n11.         d2.arr[0] = 100;\n12.         System.out.print(d1.arr[0] + " " + (d1.arr == d2.arr));\n13.     }\n14. }',
          options: ["1 false", "100 true", "1 true", "100 false"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Shallow copy copiază referința array-ului, nu conținutul.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. super.clone() face shallow copy - copiază referințele. d1.arr și d2.arr referă ACELAȘI array. Modificarea d2.arr[0] afectează și d1.arr[0]. arr == arr returnează true.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Același array, deci d1.arr[0] este modificat la 100.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Este același array (shallow copy), deci == este true.",
            },
          ],
        },
        {
          id: 25,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Exception handling și return",
          code: "1. public class ExReturn {\n2.     static int test() {\n3.         int x = 10;\n4.         try {\n5.             x = 20;\n6.             return x;\n7.         } finally {\n8.             x = 30;\n9.         }\n10.     }\n11.     public static void main(String[] args) {\n12.         System.out.print(test());\n13.     }\n14. }",
          options: ["10", "20", "30", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. x este modificat în try înainte de return.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. return x evaluează x=20 și păstrează valoarea pentru returnare. finally se execută (x devine 30), dar valoarea deja evaluată pentru return (20) este returnată. Modificarea lui x în finally nu afectează valoarea returnată.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Valoarea pentru return este evaluată înainte de finally.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
          ],
        },
        {
          id: 26,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Immutability și wrapper classes",
          code: '1. public class Immutable {\n2.     public static void modify(Integer i, StringBuilder sb) {\n3.         i = i + 1;\n4.         sb.append(" World");\n5.     }\n6.     public static void main(String[] args) {\n7.         Integer num = 10;\n8.         StringBuilder str = new StringBuilder("Hello");\n9.         modify(num, str);\n10.         System.out.print(num + " " + str);\n11.     }\n12. }',
          options: ["11 Hello World", "10 Hello World", "11 Hello", "10 Hello"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Integer este imutabil, reasignarea locală nu afectează originalul.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Integer este imutabil - i = i + 1 creează un nou Integer și îl asignează referinței locale (num din main rămâne 10). StringBuilder este mutabil - append() modifică obiectul original.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. StringBuilder este mutabil, append afectează obiectul original.",
            },
            {
              isCorrect: false,
              explanation: "Fals. StringBuilder este mutabil.",
            },
          ],
        },
        {
          id: 27,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Initialization order cu inheritance",
          code: '1. class A {\n2.     static { System.out.print("A.static "); }\n3.     { System.out.print("A.instance "); }\n4.     A() { System.out.print("A() "); }\n5. }\n6. class B extends A {\n7.     static { System.out.print("B.static "); }\n8.     { System.out.print("B.instance "); }\n9.     B() { System.out.print("B() "); }\n10. }\n11. public class Test {\n12.     public static void main(String[] args) {\n13.         System.out.print("Start ");\n14.         new B();\n15.     }\n16. }',
          options: [
            "A.static B.static Start A.instance A() B.instance B()",
            "Start A.static B.static A.instance A() B.instance B()",
            "Start A.static A.instance A() B.static B.instance B()",
            "A.static B.static A.instance B.instance A() B()",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Ordinea: 1) Blocuri statice la încărcarea claselor (A apoi B, înainte de Start deoarece main e în Test dar B e referit). 2) 'Start' se printează. 3) new B() -> A.instance, A(), B.instance, B().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Blocurile statice se execută la încărcarea claselor, înainte de Start.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Toate blocurile statice se execută înainte de orice instanțiere.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Constructorii se execută după blocurile de instanță.",
            },
          ],
        },
        {
          id: 28,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Collectors și groupingBy",
          code: '1. import java.util.*;\n2. import java.util.stream.*;\n3. public class GroupTest {\n4.     public static void main(String[] args) {\n5.         List<String> words = Arrays.asList("a", "bb", "cc", "ddd");\n6.         Map<Integer, Long> map = words.stream()\n7.             .collect(Collectors.groupingBy(\n8.                 String::length,\n9.                 Collectors.counting()));\n10.         System.out.println(map);\n11.     }\n12. }',
          options: [
            "{1=a, 2=bb, 3=ddd}",
            "{1=1, 2=2, 3=1}",
            "{a=1, bb=2, ddd=3}",
            "{1=[a], 2=[bb, cc], 3=[ddd]}",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. groupingBy cu counting() numără elementele, nu le păstrează.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. groupingBy grupează după lungime (1, 2, 3). Collectors.counting() numără elementele din fiecare grup: lungime 1 -> 1 element ('a'), lungime 2 -> 2 elemente ('bb', 'cc'), lungime 3 -> 1 element ('ddd').",
            },
            {
              isCorrect: false,
              explanation: "Fals. Cheia este lungimea, nu cuvântul.",
            },
            {
              isCorrect: false,
              explanation: "Fals. counting() returnează Long, nu List.",
            },
          ],
        },
        {
          id: 29,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Interface private methods (Java 9+)",
          code: '1. interface Calculator {\n2.     default int add(int a, int b) {\n3.         return compute(a, b, (x, y) -> x + y);\n4.     }\n5.     default int multiply(int a, int b) {\n6.         return compute(a, b, (x, y) -> x * y);\n7.     }\n8.     private int compute(int a, int b, java.util.function.BiFunction<Integer, Integer, Integer> op) {\n9.         return op.apply(a, b);\n10.     }\n11. }\n12. public class Test implements Calculator {\n13.     public static void main(String[] args) {\n14.         Test t = new Test();\n15.         System.out.print(t.add(3, 4) + " " + t.multiply(3, 4));\n16.     }\n17. }',
          options: [
            "7 12",
            "Eroare de compilare - private în interfață",
            "Eroare de compilare - BiFunction",
            "12 7",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Din Java 9, interfețele pot avea metode private pentru a evita duplicarea codului între metodele default. compute() este folosit intern de add() și multiply(). add(3,4)=7, multiply(3,4)=12.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Java 9+ permite metode private în interfețe.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. BiFunction este valid din java.util.function.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Ordinea este add apoi multiply.",
            },
          ],
        },
        {
          id: 30,
          text: "Care este rezultatul următoarei secvențe?",
          description: "AtomicInteger și thread safety",
          code: "1. import java.util.concurrent.atomic.*;\n2. import java.util.stream.*;\n3. public class AtomicTest {\n4.     public static void main(String[] args) {\n5.         AtomicInteger ai = new AtomicInteger(0);\n6.         IntStream.range(0, 1000)\n7.             .parallel()\n8.             .forEach(i -> ai.incrementAndGet());\n9.         System.out.print(ai.get());\n10.     }\n11. }",
          options: [
            "Valoare variabilă, mai mică de 1000",
            "1000 (întotdeauna)",
            "Eroare de compilare",
            "0",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. AtomicInteger.incrementAndGet() este atomic și thread-safe.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. AtomicInteger folosește operații atomice hardware (CAS - Compare-And-Swap). incrementAndGet() este garantat atomic. Chiar și cu parallel stream, rezultatul este întotdeauna 1000.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. incrementAndGet() incrementează valoarea de 1000 de ori.",
            },
          ],
        },
      ];

      const questionsSetNou4 = [
        {
          id: 1,
          text: "Care este rezultatul următoarei secvențe?",
          description: "CompletableFuture și async programming",
          code: '1. import java.util.concurrent.*;\n2. public class FutureTest {\n3.     public static void main(String[] args) throws Exception {\n4.         CompletableFuture<String> cf = CompletableFuture\n5.             .supplyAsync(() -> "Hello")\n6.             .thenApply(s -> s + " World")\n7.             .thenApply(String::toUpperCase);\n8.         System.out.print(cf.get());\n9.     }\n10. }',
          options: [
            "Hello",
            "Hello World",
            "HELLO WORLD",
            "CompletableFuture[HELLO WORLD]",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. thenApply transformă rezultatul.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Al doilea thenApply aplică toUpperCase.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. supplyAsync produce 'Hello'. Primul thenApply adaugă ' World' -> 'Hello World'. Al doilea thenApply aplică toUpperCase -> 'HELLO WORLD'. get() extrage valoarea.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. get() returnează valoarea, nu reprezentarea CompletableFuture.",
            },
          ],
        },
        {
          id: 2,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Method hiding vs overriding cu excepții",
          code: '1. class Parent {\n2.     void test() throws Exception { System.out.print("Parent "); }\n3. }\n4. class Child extends Parent {\n5.     void test() throws RuntimeException { System.out.print("Child "); }\n6. }\n7. public class Test {\n8.     public static void main(String[] args) throws Exception {\n9.         Parent p = new Child();\n10.         p.test();\n11.     }\n12. }',
          options: [
            "Parent",
            "Child",
            "Eroare de compilare - excepție incompatibilă",
            "Parent Child",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Polimorfismul apelează metoda din Child.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. RuntimeException este subtip al Exception, deci Child.test() poate declara o excepție mai specifică sau unchecked. Polimorfismul asigură apelarea Child.test().",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metoda suprascrisă poate declara excepții mai specifice sau unchecked (RuntimeException).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Se apelează doar o metodă.",
            },
          ],
        },
        {
          id: 3,
          text: "Care este rezultatul următoarei secvențe?",
          description: "CopyOnWriteArrayList și iterare",
          code: '1. import java.util.concurrent.*;\n2. import java.util.*;\n3. public class COWTest {\n4.     public static void main(String[] args) {\n5.         List<String> list = new CopyOnWriteArrayList<>();\n6.         list.add("A"); list.add("B"); list.add("C");\n7.         for (String s : list) {\n8.             if (s.equals("B")) list.remove(s);\n9.             System.out.print(s + " ");\n10.         }\n11.         System.out.print(list);\n12.     }\n13. }',
          options: [
            "A B C [A, C]",
            "ConcurrentModificationException",
            "A C [A, C]",
            "A B C [A, B, C]",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. CopyOnWriteArrayList permite modificarea în timpul iterării. Iterator-ul lucrează pe un snapshot. Se printează A B C (snapshot-ul original), dar lista finală este [A, C] după remove.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. CopyOnWriteArrayList NU aruncă CME - este thread-safe pentru iterare.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Iterator-ul vede snapshot-ul original cu A, B, C.",
            },
            {
              isCorrect: false,
              explanation: "Fals. remove() modifică lista reală.",
            },
          ],
        },
        {
          id: 4,
          text: "Care este rezultatul următoarei secvențe?",
          description: "WeakReference și Garbage Collection",
          code: '1. import java.lang.ref.*;\n2. public class WeakRefTest {\n3.     public static void main(String[] args) {\n4.         String strong = new String("Hello");\n5.         WeakReference<String> weak = new WeakReference<>(strong);\n6.         System.out.print(weak.get() + " ");\n7.         strong = null;\n8.         System.gc();\n9.         System.out.print(weak.get());\n10.     }\n11. }',
          options: [
            "Hello Hello",
            "Hello null (cel mai probabil)",
            "null null",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. După GC, weak reference poate fi cleared.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Prima dată, strong încă referă obiectul -> 'Hello'. După strong=null și GC, nu mai există strong references, deci GC poate colecta obiectul și weak.get() returnează null. (GC nu e garantat, dar cel mai probabil rulează).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Prima accesare este înainte de GC.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
          ],
        },
        {
          id: 5,
          text: "Care este rezultatul următoarei secvențe?",
          description: "record classes (Java 14+)",
          code: '1. record Point(int x, int y) {\n2.     Point {\n3.         if (x < 0 || y < 0) throw new IllegalArgumentException();\n4.     }\n5.     Point(int v) { this(v, v); }\n6. }\n7. public class RecordTest {\n8.     public static void main(String[] args) {\n9.         Point p = new Point(5);\n10.         System.out.print(p.x() + " " + p.y() + " " + p);\n11.     }\n12. }',
          options: [
            "5 5 Point[x=5, y=5]",
            "5 5 Point@hashcode",
            "Eroare de compilare - record nu poate avea constructori",
            "5 5 (5, 5)",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Records pot avea compact constructor (validare) și constructori adiționali. Point(5) apelează this(5,5). toString() generat automat returnează Point[x=5, y=5]. Accesorii sunt x() și y().",
            },
            {
              isCorrect: false,
              explanation: "Fals. Records au toString() generat automat.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Records pot avea constructori adiționali care apelează canonical constructor.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. toString() generat pentru records are formatul Type[field=value].",
            },
          ],
        },
        {
          id: 6,
          text: "Care este rezultatul următoarei secvențe?",
          description: "sealed classes (Java 17+)",
          code: "1. sealed interface Shape permits Circle, Rectangle {}\n2. final class Circle implements Shape { int radius = 5; }\n3. non-sealed class Rectangle implements Shape { int w = 3, h = 4; }\n4. class Square extends Rectangle { int side = 2; }\n5. public class SealedTest {\n6.     public static void main(String[] args) {\n7.         Shape s = new Square();\n8.         System.out.print(s instanceof Rectangle);\n9.     }\n10. }",
          options: [
            "true",
            "false",
            "Eroare de compilare - Square nu poate extinde Rectangle",
            "Eroare de compilare - Square trebuie permis în sealed",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Rectangle este non-sealed, deci poate fi extins liber de Square. Square este Rectangle (moștenire). s instanceof Rectangle returnează true.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Square extend Rectangle, deci instanceof Rectangle este true.",
            },
            {
              isCorrect: false,
              explanation: "Fals. non-sealed permite extindere liberă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Doar subclasele directe ale sealed trebuie permise. Square extinde non-sealed Rectangle.",
            },
          ],
        },
        {
          id: 7,
          text: "Care este rezultatul următoarei secvențe?",
          description: "var și type inference (Java 10+)",
          code: '1. import java.util.*;\n2. public class VarTest {\n3.     public static void main(String[] args) {\n4.         var list = new ArrayList<String>();\n5.         list.add("Hello");\n6.         var item = list.get(0);\n7.         // item = 123;\n8.         System.out.print(item.getClass().getSimpleName());\n9.     }\n10. }',
          options: ["Object", "String", "ArrayList", "Eroare de compilare"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. var inferează tipul concret, nu Object.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. var inferează tipul la compile-time. list este ArrayList<String>, list.get(0) returnează String, deci item este String. Linia comentată (item=123) ar cauza eroare dacă ar fi decomentata.",
            },
            {
              isCorrect: false,
              explanation: "Fals. item este rezultatul get(), nu lista.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
          ],
        },
        {
          id: 8,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Pattern matching pentru instanceof (Java 16+)",
          code: '1. public class PatternMatch {\n2.     public static void main(String[] args) {\n3.         Object obj = "Hello";\n4.         if (obj instanceof String s && s.length() > 3) {\n5.             System.out.print(s.toUpperCase());\n6.         } else if (obj instanceof String s) {\n7.             System.out.print(s.toLowerCase());\n8.         }\n9.     }\n10. }',
          options: [
            "Hello",
            "HELLO",
            "hello",
            "Eroare de compilare - s redeclarat",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Se aplică transformația din if.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Pattern matching: 'String s' declară și verifică tipul simultan. 'Hello' are length 5 > 3, deci prima condiție este true. s.toUpperCase() = 'HELLO'. Variabila s din else if are scope diferit, nu e conflict.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Prima condiție este satisfăcută.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Variabilele din pattern matching au scope limitat la branch-ul respectiv.",
            },
          ],
        },
        {
          id: 9,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Text blocks (Java 15+)",
          code: '1. public class TextBlock {\n2.     public static void main(String[] args) {\n3.         String s = """\n4.                    Hello\n5.                    World""";\n6.         System.out.print(s.lines().count() + " ");\n7.         System.out.print(s.contains("\\n"));\n8.     }\n9. }',
          options: ["2 false", "2 true", "3 true", "1 false"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Text block-ul conține newline real, nu escaped.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Text block are 2 linii (Hello\\nWorld). lines() returnează 2. contains('\\\\n') caută literal backslash-n, dar text block-ul conține newline REAL (caracterul), nu secvența '\\n'. True deoarece... wait, \"\\\\n\" în cod e newline real, deci s conține newline -> true.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Nu există linie goală la început.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Sunt 2 linii în text block.",
            },
          ],
        },
        {
          id: 10,
          text: "Care este rezultatul următoarei secvențe?",
          description: "switch expressions (Java 14+)",
          code: '1. public class SwitchExpr {\n2.     public static void main(String[] args) {\n3.         int day = 3;\n4.         String result = switch(day) {\n5.             case 1, 2, 3, 4, 5 -> "Weekday";\n6.             case 6, 7 -> "Weekend";\n7.             default -> throw new IllegalArgumentException();\n8.         };\n9.         System.out.print(result);\n10.     }\n11. }',
          options: [
            "Weekday",
            "Weekend",
            "Eroare de compilare - switch nu poate returna",
            "Weekday Weekend",
          ],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Switch expressions (Java 14+) pot returna valori. Arrow syntax (->) nu necesită break. day=3 se potrivește cu case 1,2,3,4,5 -> returnează 'Weekday'.",
            },
            {
              isCorrect: false,
              explanation: "Fals. day=3 este weekday, nu weekend.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Switch expressions sunt valide din Java 14.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Switch expression returnează o singură valoare.",
            },
          ],
        },
        {
          id: 11,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Collectors.teeing (Java 12+)",
          code: "1. import java.util.*;\n2. import java.util.stream.*;\n3. public class TeeingTest {\n4.     public static void main(String[] args) {\n5.         var result = Stream.of(1, 2, 3, 4, 5).collect(\n6.             Collectors.teeing(\n7.                 Collectors.summingInt(i -> i),\n8.                 Collectors.counting(),\n9.                 (sum, count) -> sum / count));\n10.         System.out.print(result);\n11.     }\n12. }",
          options: ["2", "3", "2.5", "15"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Integer division 15/5 = 3, nu 2.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. teeing() aplică doi collectori și combină rezultatele. sum = 1+2+3+4+5 = 15 (Integer), count = 5 (Long). 15/5 = 3 (integer division deoarece sum este Integer).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Este integer division, nu floating point.",
            },
            {
              isCorrect: false,
              explanation: "Fals. 15 este suma, nu rezultatul după combinare.",
            },
          ],
        },
        {
          id: 12,
          text: "Care este rezultatul următoarei secvențe?",
          description: "ReentrantLock și tryLock",
          code: '1. import java.util.concurrent.locks.*;\n2. public class LockTest {\n3.     static ReentrantLock lock = new ReentrantLock();\n4.     public static void main(String[] args) {\n5.         lock.lock();\n6.         System.out.print(lock.tryLock() + " ");\n7.         System.out.print(lock.getHoldCount());\n8.         lock.unlock();\n9.         lock.unlock();\n10.     }\n11. }',
          options: [
            "false 1",
            "true 2",
            "true 1",
            "Eroare - IllegalMonitorStateException",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. ReentrantLock permite reacquisition de către același thread.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. ReentrantLock permite același thread să achiziționeze lock-ul de mai multe ori. lock() -> holdCount=1. tryLock() -> succes (true), holdCount=2. Fiecare unlock decrementează holdCount.",
            },
            {
              isCorrect: false,
              explanation: "Fals. tryLock() incrementează holdCount la 2.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ambele unlock sunt valide deoarece holdCount ajunge la 0.",
            },
          ],
        },
        {
          id: 13,
          text: "Care este rezultatul următoarei secvențe?",
          description: "ForkJoinPool și work stealing",
          code: '1. import java.util.concurrent.*;\n2. public class ForkJoinTest {\n3.     public static void main(String[] args) {\n4.         ForkJoinPool pool = ForkJoinPool.commonPool();\n5.         int result = pool.invoke(new RecursiveTask<Integer>() {\n6.             protected Integer compute() {\n7.                 return 1 + 1;\n8.             }\n9.         });\n10.         System.out.print(result + " " + pool.getParallelism());\n11.     }\n12. }',
          options: [
            "2 1",
            "2 (numărul de procesoare - 1)",
            "2 (numărul de procesoare)",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Paralelismul common pool depinde de CPU.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. RecursiveTask compute() returnează 2. ForkJoinPool.commonPool() are parallelism = Runtime.getRuntime().availableProcessors() - 1 (default, minimum 1).",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Common pool rezervă un procesor pentru calling thread.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
          ],
        },
        {
          id: 14,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Optional chaining",
          code: '1. import java.util.*;\n2. public class OptChain {\n3.     public static void main(String[] args) {\n4.         Optional<String> opt = Optional.of("test");\n5.         String result = opt\n6.             .filter(s -> s.length() > 2)\n7.             .map(String::toUpperCase)\n8.             .flatMap(s -> Optional.of(s + "!"))\n9.             .orElseThrow();\n10.         System.out.print(result);\n11.     }\n12. }',
          options: ["test", "TEST", "TEST!", "NoSuchElementException"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. map și flatMap transformă valoarea.",
            },
            {
              isCorrect: false,
              explanation: "Fals. flatMap adaugă '!' la sfârșit.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. filter: 'test'.length()=4>2 -> trece. map: 'TEST'. flatMap: Optional.of('TEST!') -> 'TEST!'. orElseThrow extrage valoarea.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Optional-ul nu este gol după filter.",
            },
          ],
        },
        {
          id: 15,
          text: "Care este rezultatul următoarei secvențe?",
          description: "LinkedHashMap access order",
          code: '1. import java.util.*;\n2. public class LHMTest {\n3.     public static void main(String[] args) {\n4.         Map<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);\n5.         map.put("A", 1); map.put("B", 2); map.put("C", 3);\n6.         map.get("A");\n7.         map.put("B", 20);\n8.         System.out.println(map.keySet());\n9.     }\n10. }',
          options: ["[A, B, C]", "[C, A, B]", "[B, C, A]", "[A, C, B]"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. accessOrder=true reordonează la acces.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. LinkedHashMap cu accessOrder=true reordonează intrarea accesată la sfârșit. Initial: A,B,C. get('A') -> C,B,A. put('B',20) -> C,A,B. Wait, let me recheck: After inserts: A,B,C. get('A') moves A to end: B,C,A. put('B',20) moves B to end: C,A,B.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. put() pe cheie existentă mută intrarea la sfârșit.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ordinea după get('A') și put('B') este diferită.",
            },
          ],
        },
        {
          id: 16,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Spliterator characteristics",
          code: '1. import java.util.*;\n2. public class SplitTest {\n3.     public static void main(String[] args) {\n4.         List<Integer> list = Arrays.asList(1, 2, 3);\n5.         Set<Integer> set = new HashSet<>(list);\n6.         Spliterator<Integer> ls = list.spliterator();\n7.         Spliterator<Integer> ss = set.spliterator();\n8.         System.out.print(ls.hasCharacteristics(Spliterator.ORDERED) + " ");\n9.         System.out.print(ss.hasCharacteristics(Spliterator.ORDERED));\n10.     }\n11. }',
          options: ["true true", "false false", "true false", "false true"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. HashSet nu garantează ordinea.",
            },
            {
              isCorrect: false,
              explanation: "Fals. List păstrează ordinea.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. List (ArrayList) are Spliterator ORDERED - elementele au ordine definită. HashSet NU are ORDERED - nu garantează ordinea elementelor.",
            },
            {
              isCorrect: false,
              explanation: "Fals. List este ordered, HashSet nu este.",
            },
          ],
        },
        {
          id: 17,
          text: "Care este rezultatul următoarei secvențe?",
          description: "MethodHandles vs Reflection",
          code: '1. import java.lang.invoke.*;\n2. public class MHTest {\n3.     private static int secret = 42;\n4.     public static void main(String[] args) throws Throwable {\n5.         MethodHandles.Lookup lookup = MethodHandles.lookup();\n6.         VarHandle vh = lookup.findStaticVarHandle(MHTest.class, "secret", int.class);\n7.         System.out.print(vh.get() + " ");\n8.         vh.set(100);\n9.         System.out.print(secret);\n10.     }\n11. }',
          options: [
            "42 42",
            "42 100",
            "IllegalAccessException",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. VarHandle.set() modifică valoarea.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. MethodHandles.lookup() în aceeași clasă are acces la membrii privați. VarHandle permite get/set direct. secret devine 100.",
            },
            {
              isCorrect: false,
              explanation: "Fals. lookup() din aceeași clasă are acces full.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul este valid.",
            },
          ],
        },
        {
          id: 18,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Collectors.collectingAndThen",
          code: '1. import java.util.*;\n2. import java.util.stream.*;\n3. public class CollectTest {\n4.     public static void main(String[] args) {\n5.         List<String> list = Stream.of("a", "b", "c")\n6.             .collect(Collectors.collectingAndThen(\n7.                 Collectors.toList(),\n8.                 Collections::unmodifiableList));\n9.         System.out.print(list.getClass().getSimpleName() + " ");\n10.         try { list.add("d"); } catch(Exception e) {\n11.             System.out.print(e.getClass().getSimpleName());\n12.         }\n13.     }\n14. }',
          options: [
            "ArrayList null",
            "UnmodifiableList UnsupportedOperationException",
            "UnmodifiableRandomAccessList UnsupportedOperationException",
            "ArrayList UnsupportedOperationException",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. unmodifiableList învelește lista.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Clasa internă se numește UnmodifiableRandomAccessList.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. collectingAndThen aplică finisher (unmodifiableList) după colectare. Clasa wrapper este UnmodifiableRandomAccessList. add() aruncă UnsupportedOperationException.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Nu mai este ArrayList după wrapping.",
            },
          ],
        },
        {
          id: 19,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Proxy și InvocationHandler",
          code: '1. import java.lang.reflect.*;\n2. interface Greeter { String greet(String name); }\n3. public class ProxyTest {\n4.     public static void main(String[] args) {\n5.         Greeter g = (Greeter) Proxy.newProxyInstance(\n6.             Greeter.class.getClassLoader(),\n7.             new Class[]{Greeter.class},\n8.             (proxy, method, params) -> "Hello, " + params[0] + "!");\n9.         System.out.print(g.greet("World"));\n10.     }\n11. }',
          options: [
            "null",
            "Hello, World!",
            "Eroare de compilare",
            "InvocationTargetException",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Handler-ul returnează un String.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Proxy dinamic interceptează apelurile. InvocationHandler primește metoda și parametrii. params[0] = 'World'. Returnează 'Hello, World!'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul este valid - lambda implementează InvocationHandler.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Handler-ul nu aruncă excepții.",
            },
          ],
        },
        {
          id: 20,
          text: "Care este rezultatul următoarei secvențe?",
          description: "ConcurrentHashMap compute operations",
          code: '1. import java.util.concurrent.*;\n2. public class CHMTest {\n3.     public static void main(String[] args) {\n4.         ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n5.         map.put("A", 1);\n6.         map.compute("A", (k, v) -> v == null ? 1 : v + 1);\n7.         map.compute("B", (k, v) -> v == null ? 1 : v + 1);\n8.         map.merge("A", 10, Integer::sum);\n9.         System.out.print(map);\n10.     }\n11. }',
          options: ["{A=2, B=1}", "{A=12, B=1}", "{A=11, B=1}", "{A=10, B=1}"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. merge() adaugă 10 la valoarea existentă.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. put('A',1) -> A=1. compute('A') -> v=1, return 2 -> A=2. compute('B') -> v=null, return 1 -> B=1. merge('A',10,sum) -> 2+10=12 -> A=12. Final: {A=12, B=1}.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. merge adaugă valoarea nouă la cea existentă folosind funcția.",
            },
            {
              isCorrect: false,
              explanation: "Fals. merge nu înlocuiește, ci combină valorile.",
            },
          ],
        },
        {
          id: 21,
          text: "Care este rezultatul următoarei secvențe?",
          description: "ServiceLoader și SPI",
          code: '1. import java.util.*;\n2. public class SPITest {\n3.     public static void main(String[] args) {\n4.         ServiceLoader<List> loader = ServiceLoader.load(List.class);\n5.         int count = 0;\n6.         for (List l : loader) count++;\n7.         System.out.print(count > 0 ? "Found" : "Empty");\n8.     }\n9. }',
          options: [
            "Found",
            "Empty",
            "ServiceConfigurationError",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Fără META-INF/services configurate, nu se găsesc implementări.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. ServiceLoader caută în META-INF/services pentru implementări înregistrate. Fără configurare explicită, nu se găsesc servicii pentru List. Iteratorul este gol.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Lipsă config-ului nu cauzează eroare, doar rezultat gol.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Codul compilează (deși are raw type warning).",
            },
          ],
        },
        {
          id: 22,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Class initialization deadlock",
          code: '1. class A {\n2.     static { System.out.print("A "); new B(); }\n3. }\n4. class B {\n5.     static { System.out.print("B "); new A(); }\n6. }\n7. public class InitDeadlock {\n8.     public static void main(String[] args) {\n9.         new Thread(() -> new A()).start();\n10.         new Thread(() -> new B()).start();\n11.     }\n12. }',
          options: [
            "A B A B",
            "Potențial deadlock la inițializarea claselor",
            "B A B A",
            "Eroare de compilare",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. Dependențele circulare pot cauza deadlock.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Blocurile statice se execută cu class-level lock. T1 achiziționează lock pe A, încearcă să inițializeze B. T2 achiziționează lock pe B, încearcă să inițializeze A. Deadlock clasic la inițializarea claselor.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Ordinea depinde de scheduling, dar deadlock este probabil.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Codul compilează.",
            },
          ],
        },
        {
          id: 23,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Stream.iterate cu Predicate",
          code: '1. import java.util.stream.*;\n2. public class IterateTest {\n3.     public static void main(String[] args) {\n4.         Stream.iterate(2, n -> n < 20, n -> n * 2)\n5.               .forEach(n -> System.out.print(n + " "));\n6.     }\n7. }',
          options: ["2 4 8 16", "2 4 8 16 32", "4 8 16", "2 4 8"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. iterate(seed, hasNext, next) - versiunea cu Predicate (Java 9+). Start: 2. 2<20: print 2, next=4. 4<20: print 4, next=8. 8<20: print 8, next=16. 16<20: print 16, next=32. 32<20: false, stop.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Condiția se verifică înainte de folosire, 32 nu este < 20.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Seed-ul (2) este primul element.",
            },
            {
              isCorrect: false,
              explanation: "Fals. 16 < 20, deci 16 este inclus.",
            },
          ],
        },
        {
          id: 24,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Collectors.partitioningBy",
          code: '1. import java.util.*;\n2. import java.util.stream.*;\n3. public class PartitionTest {\n4.     public static void main(String[] args) {\n5.         Map<Boolean, List<Integer>> map = Stream.of(1, 2, 3, 4, 5)\n6.             .collect(Collectors.partitioningBy(n -> n % 2 == 0));\n7.         System.out.print(map.get(true).size() + " " + map.get(false).size());\n8.     }\n9. }',
          options: ["2 3", "3 2", "2 2", "null null"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. partitioningBy împarte în două grupuri (true/false). n%2==0: true pentru 2,4 (2 elemente), false pentru 1,3,5 (3 elemente).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Sunt 2 numere pare și 3 impare.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Numărul total este 5, nu 4.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. partitioningBy garantează ambele chei (true și false) chiar dacă listele sunt goale.",
            },
          ],
        },
        {
          id: 25,
          text: "Care este rezultatul următoarei secvențe?",
          description: "instanceof cu null",
          code: '1. public class InstanceofNull {\n2.     public static void main(String[] args) {\n3.         String s = null;\n4.         System.out.print((s instanceof String) + " ");\n5.         System.out.print((s instanceof Object) + " ");\n6.         System.out.print((null instanceof String));\n7.     }\n8. }',
          options: [
            "true true true",
            "false false false",
            "NullPointerException",
            "true true false",
          ],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. null instanceof orice tip returnează false.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. instanceof cu null pe partea stângă returnează întotdeauna false, indiferent de tipul testat. Nu aruncă NullPointerException.",
            },
            {
              isCorrect: false,
              explanation: "Fals. instanceof nu aruncă NPE pentru null.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. s este null, deci toate verificările returnează false.",
            },
          ],
        },
        {
          id: 26,
          text: "Care este rezultatul următoarei secvențe?",
          description: "StampedLock optimistic reading",
          code: '1. import java.util.concurrent.locks.*;\n2. public class StampedTest {\n3.     static StampedLock lock = new StampedLock();\n4.     static int value = 10;\n5.     public static void main(String[] args) {\n6.         long stamp = lock.tryOptimisticRead();\n7.         int local = value;\n8.         if (lock.validate(stamp)) {\n9.             System.out.print(local);\n10.         } else {\n11.             System.out.print("Invalid");\n12.         }\n13.     }\n14. }',
          options: ["10", "Invalid", "Eroare - lock necesar", "0"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. tryOptimisticRead() nu blochează - returnează un stamp. Dacă nimeni nu a scris între timp (single-threaded aici), validate() returnează true. Se printează 10.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. În single-threaded, nu există scrieri concurente.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Optimistic read nu necesită lock explicit.",
            },
            {
              isCorrect: false,
              explanation: "Fals. value este inițializat cu 10.",
            },
          ],
        },
        {
          id: 27,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Inheritance și generic methods",
          code: '1. class Base {\n2.     <T> T process(T item) { return item; }\n3. }\n4. class Derived extends Base {\n5.     @Override\n6.     <T> T process(T item) {\n7.         System.out.print("Derived ");\n8.         return super.process(item);\n9.     }\n10. }\n11. public class GenericOverride {\n12.     public static void main(String[] args) {\n13.         Base b = new Derived();\n14.         String result = b.process("Hello");\n15.         System.out.print(result);\n16.     }\n17. }',
          options: [
            "Hello",
            "Derived Hello",
            "Eroare de compilare - nu se poate suprascrie metodă generică",
            "Derived",
          ],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. Polimorfismul apelează versiunea din Derived.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Metodele generice pot fi suprascrise. Polimorfismul asigură apelarea Derived.process() care printează 'Derived ' și returnează rezultatul super.process() = 'Hello'.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Metodele generice pot fi suprascrise cu aceeași semnatură generică.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Se printează și rezultatul returnat.",
            },
          ],
        },
        {
          id: 28,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Arrays.asList vs List.of",
          code: '1. import java.util.*;\n2. public class ListCreation {\n3.     public static void main(String[] args) {\n4.         List<String> list1 = Arrays.asList("A", "B");\n5.         List<String> list2 = List.of("A", "B");\n6.         try { list1.set(0, "X"); System.out.print("1ok "); }\n7.         catch(Exception e) { System.out.print("1fail "); }\n8.         try { list2.set(0, "X"); System.out.print("2ok"); }\n9.         catch(Exception e) { System.out.print("2fail"); }\n10.     }\n11. }',
          options: ["1ok 2ok", "1fail 2fail", "1ok 2fail", "1fail 2ok"],
          answers: [
            {
              isCorrect: false,
              explanation:
                "Fals. List.of() returnează listă complet imutabilă.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Arrays.asList() permite set(), doar add/remove sunt blocate.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. Arrays.asList() - fixed-size dar permite set() (modifică array-ul backing). List.of() - complet imutabilă, set() aruncă UnsupportedOperationException.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Arrays.asList permite set().",
            },
          ],
        },
        {
          id: 29,
          text: "Care este rezultatul următoarei secvențe?",
          description: "ThreadLocal și value isolation",
          code: '1. public class TLTest {\n2.     static ThreadLocal<Integer> tl = ThreadLocal.withInitial(() -> 0);\n3.     public static void main(String[] args) throws Exception {\n4.         tl.set(10);\n5.         Thread t = new Thread(() -> {\n6.             tl.set(20);\n7.             System.out.print(tl.get() + " ");\n8.         });\n9.         t.start();\n10.         t.join();\n11.         System.out.print(tl.get());\n12.     }\n13. }',
          options: ["20 20", "20 10", "10 20", "0 10"],
          answers: [
            {
              isCorrect: false,
              explanation: "Fals. ThreadLocal izolează valorile per thread.",
            },
            {
              isCorrect: true,
              explanation:
                "Corect. ThreadLocal păstrează valori separate per thread. Main setează 10. Thread-ul nou setează 20, printează 20. După join, main printează valoarea sa (10).",
            },
            {
              isCorrect: false,
              explanation: "Fals. Thread-ul nou nu vede valoarea din main.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. Noul thread își setează valoarea proprie la 20, nu folosește default.",
            },
          ],
        },
        {
          id: 30,
          text: "Care este rezultatul următoarei secvențe?",
          description: "Comparator.comparing și thenComparing",
          code: '1. import java.util.*;\n2. record Person(String name, int age) {}\n3. public class CompareChain {\n4.     public static void main(String[] args) {\n5.         List<Person> list = new ArrayList<>(List.of(\n6.             new Person("Bob", 25),\n7.             new Person("Ana", 30),\n8.             new Person("Ana", 25)));\n9.         list.sort(Comparator.comparing(Person::name)\n10.                            .thenComparing(Person::age));\n11.         System.out.print(list.get(0).name() + " " + list.get(0).age());\n12.     }\n13. }',
          options: ["Ana 25", "Ana 30", "Bob 25", "Eroare de compilare"],
          answers: [
            {
              isCorrect: true,
              explanation:
                "Corect. Sortare: mai întâi după name (alfabetic), apoi după age. Ana < Bob alfabetic. Între cele două Ana, cea cu age 25 < 30. Primul element: Ana, 25.",
            },
            {
              isCorrect: false,
              explanation:
                "Fals. thenComparing sortează crescător după age pentru același name.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Ana vine înaintea lui Bob alfabetic.",
            },
            {
              isCorrect: false,
              explanation: "Fals. Record și Comparator.comparing sunt valide.",
            },
          ],
        },
      ];

      const quizzes = {
        examExCB: {
          title: "Examen exemplu - CB",
          data: questionsExamCBExemplu,
        },
        examCA2021: {
          title: "Examen CA 2021",
          data: questionsExamenCa2021,
        },
        examCA2020: {
          title: "Examen CA 2020",
          data: questionsExamenCa2020,
        },
        javaBasics: {
          title: "Java Basics (Test)",
          data: questionsJavaBasics,
        },
        setNou1: {
          title: "Set Nou 1 - Stil CB",
          data: questionsSetNou1,
        },
        setNou2: {
          title: "Set Nou 2 - Stil CB",
          data: questionsSetNou2,
        },
        setNou3: {
          title: "Set Nou 3 - Avansat",
          data: questionsSetNou3,
        },
        setNou4: {
          title: "Set Nou 4 - Avansat",
          data: questionsSetNou4,
        },
      };

      // --- STATE ---

      let currentQuizId = "examExCB";
      let currentQuestions = quizzes[currentQuizId].data;
      let questionState = new Array(currentQuestions.length).fill(null);

      // --- FUNCTIONS ---

      function escapeHTML(str) {
        if (!str) return "";
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function switchQuiz(quizId) {
        currentQuizId = quizId;
        currentQuestions = quizzes[quizId].data;

        // Update title
        document.getElementById("quizTitle").innerText = quizzes[quizId].title;

        // Reset state
        questionState = new Array(currentQuestions.length).fill(null);

        // Re-render
        renderQuiz();
        updateScoreDisplay();
      }

      function renderQuiz() {
        const container = document.getElementById("quiz");
        let html = "";

        currentQuestions.forEach((q, index) => {
          let codeBlock = q.code
            ? `
                    <div class="code-wrapper">
                        <button class="copy-btn" onclick="copyToClipboard(${index}, this)" title="Copy code">Copy</button>
                        <pre><code>${escapeHTML(q.code)}</code></pre>
                    </div>`
            : "";
          let descriptionHtml = q.description
            ? `<div class="question-description" style="margin-bottom: 15px; white-space: pre-wrap;">${escapeHTML(q.description)}</div>`
            : "";

          let optionsHtml = q.options
            .map(
              (opt, i) => `
                    <li class="option-item">
                        <label class="option-label" id="label-${index}-${i}">
                            <input type="radio" name="q${index}" value="${i}" onchange="checkAnswer(${index}, ${i})">
                            ${escapeHTML(opt)}
                        </label>
                    </li>
                `,
            )
            .join("");

          html += `
                    <div class="question-card" id="card-${index}">
                        <div class="question-text">${index + 1}. ${escapeHTML(q.text)}</div>
                        ${descriptionHtml}
                        ${codeBlock}
                        <ul class="options">${optionsHtml}</ul>
                        <div class="result-box" id="result-${index}"></div>
                    </div>
                `;
        });

        container.innerHTML = html;
      }

      function copyToClipboard(index, btn) {
        const rawCode = currentQuestions[index].code;
        // Remove line numbers (e.g. "1. ")
        const cleanCode = rawCode.replace(/^\s*\d+\.\s/gm, "");

        navigator.clipboard
          .writeText(cleanCode)
          .then(() => {
            const originalText = btn.innerText;
            btn.innerText = "Copied!";
            setTimeout(() => {
              btn.innerText = originalText;
            }, 2000);
          })
          .catch((err) => {
            console.error("Failed to copy: ", err);
          });
      }

      function checkAnswer(qIndex, selectedValue) {
        const q = currentQuestions[qIndex];
        const resultBox = document.getElementById(`result-${qIndex}`);
        const labels = document.querySelectorAll(`[id^="label-${qIndex}-"]`);

        // Reset visual state for this question
        labels.forEach((label) => {
          label.classList.remove("correct", "incorrect");
        });

        // Show result box
        resultBox.style.display = "block";
        resultBox.className = "result-box";

        const selectedAnswer = q.answers[selectedValue];

        if (selectedAnswer.isCorrect) {
          // Update state
          questionState[qIndex] = true;

          resultBox.innerHTML = "Corect!";
          resultBox.classList.add("correct-answer");
          document
            .getElementById(`label-${qIndex}-${selectedValue}`)
            .classList.add("correct");
        } else {
          // Update state
          questionState[qIndex] = false;

          // Find correct answer index
          const correctIndex = q.answers.findIndex((a) => a.isCorrect);
          const correctOptionText = q.options[correctIndex];

          resultBox.innerHTML = `Greșit. Varianta corectă era: "${escapeHTML(correctOptionText)}"`;
          resultBox.classList.add("wrong-answer");
          document
            .getElementById(`label-${qIndex}-${selectedValue}`)
            .classList.add("incorrect");
          document
            .getElementById(`label-${qIndex}-${correctIndex}`)
            .classList.add("correct");
        }

        if (selectedAnswer.explanation) {
          resultBox.innerHTML += `<div class="explanation">${escapeHTML(selectedAnswer.explanation)}</div>`;
        }

        updateScoreDisplay();
      }

      function updateScoreDisplay() {
        const finalDiv = document.getElementById("finalScore");
        const currentScore = questionState.filter((s) => s === true).length;
        const answeredCount = questionState.filter((s) => s !== null).length;
        finalDiv.innerText = `Scor: ${currentScore} / ${currentQuestions.length} (Răspunsuri: ${answeredCount})`;
      }

      // Initialize
      renderQuiz();
      updateScoreDisplay();
    </script>
  </body>
</html>
