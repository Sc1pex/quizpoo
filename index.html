<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Interactiv Java</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --error-color: #c0392b;
            --bg-color: #f4f7f6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 20px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .stats {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }

        .quiz-selector-container {
            margin: 20px 0;
        }

        select {
            padding: 8px 12px;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
        }

        .quiz-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .question-card {
            padding: 25px;
            border-bottom: 1px solid #eee;
        }

        .question-text {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid var(--accent-color);
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .options {
            list-style: none;
            padding: 0;
        }

        .option-item {
            margin-bottom: 10px;
        }

        .option-label {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-label:hover {
            background-color: #f0f8ff;
            border-color: var(--accent-color);
        }

        input[type="radio"] {
            margin-right: 15px;
            transform: scale(1.2);
        }

        .controls {
            padding: 20px;
            text-align: center;
            background: #eee;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .result-box {
            display: none;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .correct-answer {
            background-color: rgba(39, 174, 96, 0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        .wrong-answer {
            background-color: rgba(192, 57, 43, 0.1);
            border: 1px solid var(--error-color);
            color: var(--error-color);
        }

        .explanation {
            margin-top: 5px;
            font-weight: normal;
            font-size: 0.9em;
            color: #555;
        }

        .code-wrapper {
            position: relative;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            font-size: 0.8rem;
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            z-index: 5;
            transition: all 0.2s;
            line-height: 1.2;
        }

        .copy-btn:hover {
            background-color: #e2e6ea;
            border-color: #adb5bd;
        }

        /* Highlight classes for results */
        .option-label.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
        }

        .option-label.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }
    </style>
</head>

<body>

    <header>
        <h1 id="quizTitle">Examen Java - Ianuarie 2021</h1>
        <div class="quiz-selector-container">
            <label for="quizSelector">Alege testul: </label>
            <select id="quizSelector" onchange="switchQuiz(this.value)">
                <option value="examExCB">Examen exemplu - CB</option>
                <option value="examCA2021">Examen CA 2021</option>
                <option value="examCA2020">Examen CA 2020</option>
                <option value="javaBasics">Java Basics (Test)</option>
            </select>
        </div>
        <div class="stats">Quiz Interactiv</div>
    </header>

    <div class="quiz-container" id="quiz">
        <!-- Întrebările vor fi generate aici prin JS -->
    </div>

    <div class="controls">
        <div id="finalScore" style="font-weight: bold; font-size: 1.2em;"></div>
    </div>

    <script>
        // --- DATA ---

        const questionsExamCBExemplu = [
            {
                "id": 1,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "1. package pkgA;\n2. public class Foo {\n3.     int a = 5;\n4.     protected int b = 6;\n5.     public int c = 7;\n6. }\n\n3. package pkgB;\n4. import pkgA.*;\n5. public class Baz {\n6.     public static void main(String[] args) {\n7.         Foo f = new Foo();\n8.         System.out.print(\" \" + f.a);\n9.         System.out.print(\" \" + f.b);\n10.         System.out.print(\" \" + f.c);\n11.     }\n12. }",
                "options": [
                    "5 6 7",
                    "5 urmat de eroare",
                    "Eroare de compilare la linia 8",
                    "Eroare de compilare la linia 10"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va rula cu succes deoarece câmpul 'a' (cu modificator implicit/package-private) nu este accesibil din pachetul pkgB."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Eroarea va apărea mai devreme, la compilare, nu la rulare."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Câmpul 'a' are modificatorul implicit (package-private) și nu poate fi accesat din pachetul pkgB. Eroarea de compilare apare la linia 8 când se încearcă accesarea lui f.a."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Câmpul 'c' este public și poate fi accesat fără probleme. Eroarea apare mai devreme, la linia 8."
                    }
                ]
            },
            {
                "id": 2,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "4. class Announce {\n5.     public static void main(String[] args) {\n6.         for(int __x = 0; __x < 3; __x++) ;\n7.         int #lb = 7;\n8.         long [] x [5];\n9.         Boolean []ba[];\n10.         enum Traffic { RED, YELLOW, GREEN };\n11.     }\n12. }",
                "options": [
                    "Compilare cu succes",
                    "Eroare de compilare la linia 6",
                    "Eroare de compilare la linia 8",
                    "Eroare de compilare la linia 10"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Există eroare de compilare la linia 7 din cauza caracterului '#' în numele variabilei."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 6 este validă - variabilele pot începe cu underscore."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. La linia 7, identificatorul '#lb' este invalid deoarece caracterul '#' nu este permis în numele variabilelor Java."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Enum-urile locale nu pot fi declarate în interiorul metodelor, dar eroarea apare mai devreme la linia 7."
                    }
                ]
            },
            {
                "id": 3,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "class Top {\n    public Top(String s) { System.out.print(\"B\"); }\n}\npublic class Bottom2 extends Top {\n    public Bottom2(String s) { System.out.print(\"D\");}\n    public static void main(String [] args) {\n        new Bottom2(\"C\");\n        System.out.println(\" \");\n    }\n}",
                "options": [
                    "Eroare de compilare",
                    "BD",
                    "DB",
                    "BDC"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Constructorul clasei Bottom2 nu apelează explicit super(s), dar clasa Top nu are un constructor implicit (fără parametri). Java cere apel explicit la super(String) în constructorul Bottom2."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila din cauza lipsei apelului explicit la constructorul părintelui."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila din cauza lipsei apelului explicit la constructorul părintelui."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila din cauza lipsei apelului explicit la constructorul părintelui."
                    }
                ]
            },
            {
                "id": 4,
                "text": "Care afirmatie este corecta?",
                "description": null,
                "code": null,
                "options": [
                    "Coeziunea este un principiu de programare orientata obiect asociat cu ascunderea detaliilor de implementare",
                    "Coeziunea este un principiu de programare orientata obiect prin care functionalitatile unei clase sunt expuse printr-un API",
                    "Coeziunea este un principiu de programare orientata obiect prin care scopul unei clase se rezuma exclusiv la un punct de interes bine definit",
                    "Coeziunea este un principiu de programare orientata obiect prin care un obiect poate fi perceput ca avand multiple tipuri"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Această definiție descrie mai degrabă encapsularea, nu coeziunea."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Acest principiu se referă la interfața publică a clasei, nu la coeziune."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Coeziunea înseamnă că o clasă ar trebui să aibă o singură responsabilitate bine definită și toate metodele și atributele ei să contribuie la acea responsabilitate."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Această definiție descrie polimorfismul, nu coeziunea."
                    }
                ]
            },
            {
                "id": 5,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "1. class MyException extends RuntimeException { }\n2. public class Houdini {\n3.     public static void main(String[] args) throws Exception {\n4.         throw new MyException();\n5.         System.out.println(\"success\");\n6.     }\n}",
                "options": [
                    "succes",
                    "Eroare de compilare la linia 3",
                    "Eroare de compilare la linia 4",
                    "Eroare de compilare la linia 5"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Excepția este aruncată la linia 4, iar linia 5 nu va fi niciodată atinsă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Declararea 'throws Exception' este validă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Aruncarea MyException (care extinde RuntimeException) este validă."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Linia 5 nu poate fi atinsă niciodată (unreachable code) deoarece linia 4 aruncă întotdeauna o excepție. Aceasta este o eroare de compilare."
                    }
                ]
            },
            {
                "id": 6,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. class Alpha {\n4.     static String s = \" \";\n5.     protected Alpha() { s += \"alpha \"; }\n6. }\n7. class SubAlpha extends Alpha {\n8.     private SubAlpha() { s += \"sub \"; }\n9. }\n10. public class SubSubAlpha extends Alpha {\n11.     private SubSubAlpha() { s += \"subsub \"; }\n12.     public static void main(String[] args) {\n13.         new SubSubAlpha();\n14.         System.out.println(s);\n15.     }\n16. }",
                "options": [
                    "subsub",
                    "sub subsub",
                    "alpha subsub",
                    "Eroare de compilare"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Constructorul clasei părinte Alpha este apelat automat înainte de constructorul SubSubAlpha."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. SubSubAlpha extinde Alpha, nu SubAlpha."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Când se creează un obiect SubSubAlpha, mai întâi se apelează constructorul Alpha (adăugând 'alpha '), apoi constructorul SubSubAlpha (adăugând 'subsub '). Rezultatul este 'alpha subsub'."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul compilează și rulează corect."
                    }
                ]
            },
            {
                "id": 7,
                "text": "Cate obiecte sunt eligibile sa fie colectate de GC la atingerea secventei indicate?",
                "description": null,
                "code": "class CardBoard {\n    Short story = 200;\n    CardBoard go(CardBoard cb) {\n        cb = null;\n        return cb;\n    }\n    public static void main(String[] args) {\n        CardBoard c1 = new CardBoard();\n        CardBoard c2 = new CardBoard();\n        CardBoard c3 = c1.go(c2);\n        c1 = null;\n        // secventa rulare GC\n    }\n}",
                "options": [
                    "0",
                    "1",
                    "2",
                    "Imposibil de determinat cu exactitate"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Există obiecte care nu mai au referințe și sunt eligibile pentru GC."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Mai mult de un obiect este eligibil pentru colectare."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. c1 este setat la null, deci primul obiect CardBoard nu mai are referințe. c3 primește null din metoda go(), deci al doilea obiect CardBoard (c2) nu mai are referințe. Ambele obiecte CardBoard sunt eligibile pentru GC."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Numărul de obiecte eligibile poate fi determinat analizând referințele."
                    }
                ]
            },
            {
                "id": 8,
                "text": "Care eroare poate fi prinsa in cadrul urmatorului bloc?",
                "description": null,
                "code": "try { int x = Integer.parseInt(\"unu\"); }",
                "options": [
                    "NumberFormatException",
                    "ClassCastException",
                    "ArrayIndexOutOfBoundsException",
                    "IllegalStateException"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Integer.parseInt() aruncă NumberFormatException când string-ul nu poate fi convertit la un număr valid."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. ClassCastException apare la conversii invalide de tip (cast), nu la parsarea string-urilor."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. ArrayIndexOutOfBoundsException apare la accesarea unui index invalid într-un array, nu la parsarea string-urilor."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. IllegalStateException se aruncă când o metodă este apelată la un moment nepotrivit, nu la parsarea string-urilor."
                    }
                ]
            },
            {
                "id": 9,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. public class KaChung {\n4.     public static void main(String[] args) {\n5.         String s = \"\";\n6.         if(Integer.parseInt(\"011\") == Integer.parseInt(\"9\")) s += 1;\n7.         if(021 == Integer.valueOf(\"17\")) s += 2;\n8.         if(1024 == new Integer(1024)) s += 3;\n9.         System.out.println(s);\n10.     }\n}",
                "options": [
                    "2",
                    "3",
                    "13",
                    "23"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Mai multe condiții sunt adevărate."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Nu doar condiția de la linia 8 este adevărată."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Condiția de la linia 6 nu este adevărată (11 != 9)."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Linia 6: Integer.parseInt('011') = 11, nu 9, deci fals. Linia 7: 021 (octal) = 17 (decimal), adevărat, s += '2'. Linia 8: auto-unboxing face 1024 == 1024, adevărat, s += '3'. Rezultat: '23'."
                    }
                ]
            },
            {
                "id": 10,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. public static void main(String[] args) {\n4.     try {\n5.         throw new Error();\n6.     }\n7.     catch (Error e) {\n8.         try { throw new RuntimeException(); }\n9.         catch (Throwable t) { }\n10.     }\n11.     System.out.println(\"oioioi\");\n12. }",
                "options": [
                    "oioioi",
                    "Eroare de compilare la linia 5",
                    "Eroare de compilare la linia 8",
                    "Eroare de compilare la linia 9"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Excepția Error este prinsă la linia 7. În interiorul blocului catch, se aruncă RuntimeException la linia 8, care este prinsă de catch-ul de la linia 9. Programul continuă normal și afișează 'oioioi' la linia 11."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Aruncarea unui Error este permisă în Java."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Sintaxa este validă - try-catch poate fi scris pe o singură linie când este simplu."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Sintaxa este validă - catch-ul prinde corect excepția aruncată în try-ul de pe aceeași linie."
                    }
                ]
            },
            {
                "id": 11,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "class Bird {\n    { System.out.print(\"b1 \"); }\n    public Bird() { System.out.print(\"b2 \"); }\n}\nclass Raptor extends Bird {\n    static { System.out.print(\"r1 \"); }\n    public Raptor() { System.out.print(\"r2 \"); }\n    { System.out.print(\"r3 \"); }\n    static { System.out.print(\"r4 \"); }\n}\nclass Hawk extends Raptor {\n    public static void main(String[] args) {\n        System.out.print(\"pre \");\n        new Hawk();\n        System.out.println(\"hawk \");\n    }\n}",
                "options": [
                    "pre b1 b2 r3 r2 hawk",
                    "pre b2 b1 r2 r3 hawk",
                    "pre b2 b1 r2 r3 hawk r1 r4",
                    "r1 r4 pre b1 b2 r3 r2 hawk"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Blocurile static se execută înaintea blocului main și înainte de pre."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Blocurile static se execută înaintea blocului main."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Blocurile static se execută la începutul încărcării clasei, nu la final."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Ordinea de execuție: (1) Blocurile static ale Raptor (r1 r4) când clasa Hawk este încărcată, (2) main începe (pre), (3) se creează Hawk: bloc de inițializare Bird (b1), constructor Bird (b2), bloc de inițializare Raptor (r3), constructor Raptor (r2), (4) afișare hawk."
                    }
                ]
            },
            {
                "id": 12,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. public class Ouch {\n4.     static int ouch = 7;\n5.     public static void main(String[] args) {\n6.         new Ouch().go(ouch);\n7.         System.out.print(\" \" + ouch);\n8.     }\n9.     void go(int ouch) {\n10.         ouch++;\n11.         for(int ouch = 3; ouch < 6; ouch++)\n12.             ;\n13.         System.out.print(\" \" + ouch);\n14.     }\n15. }",
                "options": [
                    "Eroare de compilare",
                    "5 7",
                    "5 8",
                    "8 8"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Eroare de compilare la linia 11: variabila 'ouch' este deja declarată ca parametru al metodei go() la linia 9. Nu se poate redeclara în bucla for din același scope."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila din cauza redeclarării variabilei 'ouch'."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila din cauza redeclarării variabilei 'ouch'."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila din cauza redeclarării variabilei 'ouch'."
                    }
                ]
            },
            {
                "id": 13,
                "text": "Care afirmatie este corecta in momentul atingerii liniei 14?",
                "description": null,
                "code": "3. class Dozens {\n4.     int[] dz = {1,2,3,4,5,6,7,8,9,10,11,12};\n5. }\n6. public class Eggs {\n7.     public static void main(String[] args) {\n8.         Dozens [] da = new Dozens[3];\n9.         da[0] = new Dozens();\n10.         Dozens d = new Dozens();\n11.         da[1] = d;\n12.         d = null;\n13.         da[1] = null;\n14.         // secventa rulare GC\n15.     }\n16. }",
                "options": [
                    "1 obiect este preluat de GC",
                    "2 obiecte sunt preluate de GC",
                    "3 obiecte au fost create",
                    "4 obiecte au fost create"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Două obiecte Dozens nu mai au referințe."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Obiectul creat la linia 10 (asignat inițial lui d, apoi lui da[1]) nu mai are referințe după liniile 12 și 13. da[0] încă există, dar da[2] este null. Deci 2 obiecte Dozens sunt eligibile pentru GC: cel de la linia 10 și cel de la da[2] care nu a fost niciodată inițializat (dar array-ul da nu contează ca obiect Dozens)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Au fost create mai mult de 3 obiecte (2 obiecte Dozens + array-ul da + array-urile interne dz)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Au fost create doar 2 obiecte Dozens, nu 4."
                    }
                ]
            },
            {
                "id": 14,
                "text": "Pornind de la declaratia?\n\nSi avand urmatoarele secvente de cod:\n\nCare afirmatie este corecta",
                "description": "F1. if(f1 == f2)\nF2. if(f1 == f2[2][1])\nF3. if(x == f2[0][0])\nF4. if(f1 == f2[1,1])\nF5. if(f3 == f2[2])",
                "code": "1. class Comp {\n2.     public static void main(String[] args) {\n3.         float f1 = 2.3f;\n4.         float[][] f2 = {{42.0f}, {1.7f, 2.3f}, {2.6f, 2.7f}};\n5.         float[] f3 = {2.7f};\n6.         Long x = 42L;\n7.         // inserati o secventa de cod aici\n8.         System.out.println(\"true\");\n9.     }\n10. }",
                "options": [
                    "1 secv va compila si 1 secv va intoarce true",
                    "2 secv vor compila si 1 secv va intoarce true",
                    "3 secv vor compila si 1 secv va intoarce true",
                    "3 secv vor compila si 2 secv vor intoarce true"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Mai multe de o secvență vor compila."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Mai mult de 2 secvențe vor compila."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Compilează: F2 (compară float cu float, dar 2.3f != 2.7f), F3 (compară Long cu float prin unboxing, 42L == 42.0f adevărat), F5 (compară referințe de array-uri, false). F1 nu compilează (float vs float[][]), F4 nu compilează (sintaxă invalidă f2[1,1]). 3 compilează, doar F3 returnează true."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Doar o secvență va returna true."
                    }
                ]
            },
            {
                "id": 15,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. interface Vessel { }\n4. interface Toy { }\n5. class Boat implements Vessel { }\n6. class Speedboat extends Boat implements Toy { }\n7. public class Tree {\n8.     public static void main(String[] args) {\n9.         String s = \"0\";\n10.         Boat b = new Boat();\n11.         Boat b2 = new Speedboat();\n12.         Speedboat s2 = new Speedboat();\n13.         if((b instanceof Vessel) && (b2 instanceof Toy)) s += \"1\";\n14.         if((s2 instanceof Vessel) && (s2 instanceof Toy)) s += \"2\";\n15.         System.out.println(s);\n16.     }\n17. }",
                "options": [
                    "0",
                    "01",
                    "02",
                    "012"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Cel puțin una dintre condiții este adevărată."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 13: b instanceof Vessel este true, dar b2 (declarat ca Boat) referă un Speedboat care implementează Toy, deci (b2 instanceof Toy) este true. Dar și linia 14 este true."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Ambele condiții de la liniile 13 și 14 sunt adevărate."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Linia 13: b instanceof Vessel (true) && b2 instanceof Toy (true, b2 referă Speedboat care implementează Toy), s devine '01'. Linia 14: s2 instanceof Vessel (true, Speedboat extinde Boat care implementează Vessel) && s2 instanceof Toy (true), s devine '012'."
                    }
                ]
            },
            {
                "id": 16,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. public class Circles {\n4.     public static void main(String[] args) {\n5.         int[] ia = {1,3,5,7,9};\n6.         for(int x : ia) {\n7.             for(int j = 0; j < 3; j++) {\n8.                 if(x > 4 && x < 8) continue;\n9.                 System.out.print(\" \" + x);\n10.                 if(j == 1) break;\n11.                 continue;\n12.             }\n13.             continue;\n14.         }\n15.     }\n16. }",
                "options": [
                    "1 3 9",
                    "5 5 7 7",
                    "1 3 3 9 9",
                    "1 1 3 3 9 9"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Fiecare valoare care trece de linia 8 este afișată de 2 ori."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Valorile 5 și 7 sunt sărite de continue la linia 8."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Fiecare valoare eligibilă este afișată de 2 ori, nu o dată."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Pentru x=1,3,9 (nu sunt între 4 și 8): se printează x la j=0, apoi la j=1 se printează din nou și se face break. Pentru x=5,7 (sunt între 4 și 8): continue sare printarea. Rezultat: 1 1 3 3 9 9."
                    }
                ]
            },
            {
                "id": 17,
                "text": "Care afirmatie este corecta?",
                "description": null,
                "code": "3. public class Theory {\n4.     public static void main(String[] args) {\n5.         String s1 = \"abc\";\n6.         String s2 = s1;\n7.         s1 += \"d\";\n8.         System.out.println(s1 + \" \" + s2 + \" \" + (s1==s2));\n9.\n10.         StringBuffer sb1 = new StringBuffer(\"abc\");\n11.         StringBuffer sb2 = sb1;\n12.         sb1.append(\"d\");\n13.         System.out.println(sb1 + \" \" + sb2 + \" \" + (sb1==sb2));\n14.     }\n15. }",
                "options": [
                    "Prima linie este abc abc false",
                    "Prima linie este abcd abc false",
                    "A doua linie este abc abc false",
                    "A doua linie este abcd abc false"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. După s1 += 'd', s1 devine 'abcd', nu 'abc'."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. String-urile sunt imutabile. s1 += 'd' creează un nou String 'abcd', iar s2 rămâne 'abc'. s1 și s2 sunt referințe diferite, deci s1==s2 este false. Prima linie: abcd abc false."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. StringBuffer este mutabil. sb1 și sb2 referă același obiect, care devine 'abcd'. sb1==sb2 este true."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. sb1 și sb2 referă același obiect StringBuffer, deci sb1==sb2 este true, nu false."
                    }
                ]
            },
            {
                "id": 18,
                "text": "Care declaratie este admisibila?",
                "description": null,
                "code": "public static void main(String[] args) {\n    // inserati declaratia\n    for (int i = 0; i <= 10; i++) {\n        List<Integer> row = new ArrayList<Integer>();\n        for (int j = 0; j <= 10; j++)\n            row.add(i * j);\n        table.add(row);\n    }\n    for (List<Integer> row : table)\n        System.out.println(row);\n}",
                "options": [
                    "List<List<Integer>> table = new List<List<Integer>>();",
                    "List<List<Integer>> table = new ArrayList<List<Integer>>();",
                    "List<List<Integer>> table = new ArrayList<ArrayList<Integer>>();",
                    "List<List, Integer> table = new List<List, Integer>();"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. List este o interfață și nu poate fi instanțiată direct cu 'new List<>()'."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Declarația este corectă: List<List<Integer>> este tipul variabilei, iar ArrayList<List<Integer>>() este implementarea concretă. Tipul generic al ArrayList trebuie să fie compatibil cu tipul declarat."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. ArrayList<ArrayList<Integer>>() nu este compatibil cu List<List<Integer>> din punct de vedere al tipurilor generice (generics nu sunt covariante)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Sintaxa List<List, Integer> este invalidă. Tipurile generice nu folosesc virgule în acest mod."
                    }
                ]
            },
            {
                "id": 19,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. import java.util.*;\n4. class Dog { int size; Dog(int s) { size = s; } }\n5. public class FirstGrade {\n6.     public static void main(String[] args) {\n7.         TreeSet<Integer> i = new TreeSet<Integer>();\n8.         TreeSet<Dog> d = new TreeSet<Dog>();\n9.\n10.         d.add(new Dog(1)); d.add(new Dog(2)); d.add(new Dog(1));\n11.         i.add(1); i.add(2); i.add(1);\n12.         System.out.println(d.size() + \" \" + i.size());\n13.     }\n14. }",
                "options": [
                    "1 2",
                    "2 2",
                    "2 3",
                    "Exceptie de rulare"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul va arunca o excepție la rulare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul va arunca o excepție la rulare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul va arunca o excepție la rulare."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. TreeSet necesită ca elementele să fie comparabile (să implementeze Comparable sau să se furnizeze un Comparator). Clasa Dog nu implementează Comparable, deci la adăugarea primului obiect Dog se va arunca ClassCastException."
                    }
                ]
            },
            {
                "id": 20,
                "text": "Care afirmatie este adevarata despre o metoda a unei clase interne?",
                "description": null,
                "code": null,
                "options": [
                    "Trebuie sa fie marcata final",
                    "Poate fi marcata abstract",
                    "Trebuie sa fi marcata publica",
                    "Poate fi marcata static"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metodele claselor interne nu trebuie să fie marcate final în mod obligatoriu."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. O metodă a unei clase interne poate fi marcată abstract, ceea ce ar face ca clasa internă însăși să fie abstractă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metodele claselor interne pot avea orice modificator de acces (private, protected, public, package-private)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metodele claselor interne non-statice nu pot fi statice. Doar clasele interne statice pot avea metode statice."
                    }
                ]
            },
            {
                "id": 21,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "1. public class HorseTest {\n2.     public static void main(String[] args) {\n3.         class Horse {\n4.             public String name;\n5.             public Horse(String s) {\n6.                 name = s;\n7.             }\n8.         }\n9.         Object obj = new Horse(\"Zippo\");\n10.         System.out.println(obj.name);\n11.     }\n12. }",
                "options": [
                    "Exceptie de rulare la linia 10",
                    "Eroare de compilare la linia 3",
                    "Zippo",
                    "Eroare de compilare la linia 10"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Eroarea apare la compilare, nu la rulare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Declararea unei clase locale în metodă este permisă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul nu va compila."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. obj este declarat de tip Object, care nu are câmpul 'name'. Deși obj referă un obiect Horse, compilatorul verifică tipul declarat. Pentru a accesa 'name', ar fi necesară conversie: ((Horse)obj).name. Eroare de compilare la linia 10."
                    }
                ]
            },
            {
                "id": 22,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "5. class A { void m() { System.out.println(\"outer\"); } }\n6. public class TestInners {\n7.     public static void main(String[] args) {\n8.         new TestInners().go();\n9.     }\n10.     void go() {\n11.         new A().m();\n12.         class A { void m() { System.out.println(\"inner\"); } }\n13.     }\n14.     class A { void m() { System.out.println(\"middle\"); } }\n15. }",
                "options": [
                    "inner",
                    "middle",
                    "outer",
                    "Exceptie la rulare"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Clasa A locală (inner) este declarată după apelul la linia 11, deci nu este vizibilă la momentul apelului."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. La linia 11, new A() se referă la clasa member A (middle) din linia 14, care este vizibilă în metoda go(). Clasa locală A din linia 12 nu este vizibilă încă, iar clasa outer A nu este vizibilă direct în metoda de instanță. Se afișează 'middle'."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Clasa outer A nu este cea mai apropiată în scope-ul metodei go()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul compilează și rulează fără excepții."
                    }
                ]
            },
            {
                "id": 23,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "3. public class Navel {\n4.     private int size = 7;\n5.     private static int length = 3;\n6.     public static void main(String[] args) {\n7.         new Navel().go();\n8.     }\n9.     void go() {\n10.         int size = 5;\n11.         System.out.println(new Gazer().adder());\n12.     }\n13.     class Gazer {\n14.         int adder() { return size * length; }\n15.     }\n16. }",
                "options": [
                    "15",
                    "21",
                    "Eroare de compilare la linia 10",
                    "Exceptie la rulare"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metoda adder() accesează câmpul size al clasei outer Navel (7), nu variabila locală size din go()."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Clasa internă Gazer are acces la câmpurile clasei outer Navel. În metoda adder(), 'size' se referă la Navel.this.size = 7 (nu la variabila locală din go()), iar 'length' = 3. Rezultat: 7 * 3 = 21."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Nu există eroare de compilare - variabilele locale pot avea același nume cu câmpurile clasei."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul rulează fără excepții."
                    }
                ]
            },
            {
                "id": 24,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "class MyThread extends Thread {\n    MyThread() {\n        System.out.print(\" MyThread\");\n    }\n    public void run() { System.out.print(\" bar\"); }\n    public void run(String s) { System.out.print(\" baz\"); }\n}\npublic class TestThreads {\n    public static void main (String [] args) {\n        Thread t = new MyThread() {\n            public void run() { System.out.print(\" foo\"); }\n        };\n        t.start();\n    }\n}",
                "options": [
                    "foo",
                    "MyThread foo",
                    "MyThread bar",
                    "foo bar"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Constructorul MyThread se execută și afișează ' MyThread'."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Se creează o instanță anonimă de MyThread care suprascrie run(). Mai întâi se apelează constructorul MyThread (afișează ' MyThread'), apoi când thread-ul pornește, se execută metoda run() suprascrisă (afișează ' foo'). Rezultat: MyThread foo."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metoda run() este suprascrisă în clasa anonimă, deci nu se va executa run() din MyThread."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Constructorul MyThread se execută și afișează ' MyThread'."
                    }
                ]
            },
            {
                "id": 25,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "1. public class Argue {\n2.     static boolean b;\n3.     static int x = 0;\n4.     public static void main(String[] args) {\n5.         int guess = (int)(Math.random() * 5);\n6.         if(guess < 0) assert false;\n7.         assert b = true;\n8.         assert x = 0;\n9.         assert x == 0;\n10.     }\n}",
                "options": [
                    "Eroare de compilare la linia 6",
                    "Eroare de compilare la linia 7",
                    "Eroare de compilare la linia 8",
                    "Eroare de compilare la linia 9"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 6 este validă - 'assert false' este o expresie boolean corectă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 7 este validă - 'b = true' este o expresie de atribuire care returnează true (boolean)."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. La linia 8, 'x = 0' este o expresie de atribuire care returnează int (0), nu boolean. Assert necesită o expresie boolean. Eroare de compilare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 9 este validă - 'x == 0' este o expresie boolean corectă."
                    }
                ]
            },
            {
                "id": 26,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "2. import java.util.*;\n3. public class AndOver {\n4.     public static void main(String[] args) {\n5.         List g = new ArrayList();\n6.         g.add(new Gaited(\"Eyra\"));\n7.         g.add(new Gaited(\"Vafi\"));\n8.         g.add(new Gaited(\"Andi\"));\n9.         Iterator i2 = g.iterator();\n10.         while(i2.hasNext()) {\n11.             System.out.print(i2.next().name + \" \");\n12.         }\n13.     }\n}\n13. class Gaited {\n14.     public String name;\n15.     Gaited(String n) { name = n; }\n16. }",
                "options": [
                    "Eroare de rulare",
                    "Andi Eyra Vafi",
                    "Eyra Vafi Andi",
                    "Eroare de compilare"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul compilează, dar va avea eroare la rulare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul va avea eroare la compilare sau la rulare înainte de a afișa."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Programul va avea eroare la compilare sau la rulare înainte de a afișa."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. La linia 11, i2.next() returnează Object (deoarece List nu este parametrizat cu generics). Object nu are câmpul 'name', deci este necesară conversie (cast). Eroare de compilare: cannot find symbol - variable name."
                    }
                ]
            },
            {
                "id": 27,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "2. public class Maize {\n3.     public static void main(String[] args) {\n4.         String s = \"12\";\n5.         s.concat(\"ab\");\n6.         s = go(s);\n7.         System.out.println(s);\n8.     }\n9.     static String go(String s) {\n10.         s.concat(\"56\");\n11.         return s;\n12.     }\n}",
                "options": [
                    "ab",
                    "12",
                    "ab56",
                    "12ab56"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. String-urile sunt imutabile, iar rezultatul concat() nu este asignat."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. String-urile sunt imutabile. Metodele concat() de la liniile 5 și 10 creează noi string-uri, dar rezultatul nu este asignat nicăieri. s rămâne '12' pe tot parcursul execuției."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Valorile concatenate nu sunt păstrate deoarece rezultatul concat() nu este asignat."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Valorile concatenate nu sunt păstrate deoarece rezultatul concat() nu este asignat."
                    }
                ]
            },
            {
                "id": 28,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "13. int count = 0;\n14. outer:\n15. for(int x = 0; x < 5; x++) {\n16.     middle:\n17.     for(int y = 0; y < 5; y++) {\n18.         if(y == 1) continue middle;\n19.         if(y == 3) break middle;\n20.         count++;\n21.     }\n22.     if(x > 2) continue outer;\n23.     count = count + 10;\n24. }\n25. System.out.println(\"count: \" + count);",
                "options": [
                    "count: 33",
                    "count: 40",
                    "count: 45",
                    "count: 65"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Calculul corect dă un rezultat diferit."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Pentru fiecare iterație x (0-4), bucla interioară execută count++ pentru y=0 și y=2 (y=1 face continue, y=3 face break), deci 2 incrementări per iterație exterioară = 10 total. Apoi count+=10 se execută doar pentru x=0,1,2 (când x>2 se face continue outer), deci 3×10 = 30. Total: 10 + 30 = 40."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Calculul nu ține cont de break-ul de la middle când y==3."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Calculul nu ține cont de continue outer când x>2."
                    }
                ]
            },
            {
                "id": 29,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "5. boolean[] ba = {true, false};\n6. short[][] gr = {{1,2}, {3,4}};\n7. int i = 0;\n8. for( ; i < 10; ) i++;\n9. for(short s: gr) ;\n10. for(int j = 0, k = 10; k > j; ++j, k--) ;\n11. for(int j = 0; j < 3; System.out.println(j++)) ;\n12. for(Boolean b: ba) ;",
                "options": [
                    "Eroare de compilare la linia 8",
                    "Eroare de compilare la linia 9",
                    "Eroare de compilare la linia 10",
                    "Eroare de compilare la linia 11"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 8 este un for valid cu toate cele 3 părți opționale."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. La linia 9, enhanced for încearcă să itereze peste gr care este short[][] (array 2D). Variabila s este declarată short, dar gr[i] este short[] (array 1D), nu short. Incompatibilitate de tipuri. Eroare de compilare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 10 este validă - se pot declara multiple variabile în inițializarea for-ului."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 11 este validă - System.out.println(j++) poate fi în secțiunea de update a for-ului."
                    }
                ]
            },
            {
                "id": 30,
                "text": "Care este rezultatul următoarei secvențe?",
                "description": null,
                "code": "2. public class Clover extends Harrier {\n3.     String bark() { return \"feed me \"; }\n4.     public static void main(String[] args) {\n5.         Dog[] dogs = new Dog[3];\n6.         dogs[0] = new Harrier();\n7.         dogs[1] = (Dog)new Clover();\n8.         dogs[2] = (Dog)new Harrier();\n9.         for(Dog d: dogs) System.out.print(d.bark());\n10.     }\n}\n11. class Dog { String bark() { return \"bark \"; } }\n12. class Harrier extends Dog { String bark() { return \"woof \"; } }",
                "options": [
                    "bark bark bark",
                    "woof bark bark",
                    "woof feed me woof",
                    "Eroare de compilare la linia 6."
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Prin polimorfism, se apelează metodele suprascrise, nu metoda din Dog."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Toate cele trei elemente sunt instanțe de Harrier sau Clover, nu Dog direct."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. dogs[0] = Harrier → bark() returnează 'woof '. dogs[1] = Clover (extends Harrier) → bark() returnează 'feed me '. dogs[2] = Harrier → bark() returnează 'woof '. Rezultat: woof feed me woof."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 6 este validă - Harrier extinde Dog, deci conversie implicită este permisă."
                    }
                ]
            }
        ];

        const questionsExamenCa2021 = [
            {
                "id": 1,
                "text": "Având în vedere codul de mai jos, care dintre afirmațiile de mai jos sunt adevărate în ceea ce privește conceptul de imutabilitate aplicat în cazul clasei Student?",
                "description": null,
                "code": "class Student {\n    long id;\n    List<Double> grades;\n}",
                "options": ["toate", "1, 2, 4", "1, 2, 5", "1, 3, 5"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Nu toate afirmațiile sunt adevărate. Afirmația 3 (să avem metode getter și setter) contravine principiului imutabilității, iar afirmația 5 (întoarcerea directă a listei grades) ar permite modificarea acesteia din exterior."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Pentru imutabilitate: câmpurile trebuie finale (1), doar getters (2), și getter pentru grades trebuie să returneze o copie (4), astfel încât obiectul grades să nu poată fi modificat din exterior."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 5 este greșită deoarece întoarcerea directă a referinței grades ar permite modificarea listei din exterior, compromițând imutabilitatea."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 3 (metode getter și setter) este greșită pentru imutabilitate, iar afirmația 5 permite modificarea obiectului grades din exterior."
                    }
                ]
            },
            {
                "id": 2,
                "text": "Care dintre afirmațiile de mai jos sunt adevărate?",
                "description": "1. Într-un Set putem avea duplicate\n2. În LinkedHashMap se păstrează ordinea de inserție a elementelor\n3. Interfața Map extinde interfața Collection\n4. În TreeSet nu se păstrează ordinea de inserție a elementelor",
                "code": null,
                "options": ["toate", "2 și 4", "1, 2, 3", "1, 3"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmațiile 1 (Set permite duplicate) și 3 (Map extinde Collection) sunt false. Set nu permite duplicate, iar Map nu extinde Collection."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. LinkedHashMap păstrează ordinea de inserție a elementelor (2) și TreeSet nu păstrează ordinea de inserție, ci sortează elementele natural sau prin comparator (4)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 1 este greșită deoarece Set nu permite duplicate, iar afirmația 3 este greșită deoarece Map nu extinde interfața Collection."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Ambele afirmații sunt false. Set nu permite duplicate (1) și Map nu extinde Collection (3)."
                    }
                ]
            },
            {
                "id": 3,
                "text": "Care dintre următoarele afirmații despre clase abstracte în Java sunt false:",
                "description": "1. Dacă derivăm o clasă abstractă și nu implementăm toate metodele abstracte, atunci clasă derivată trebuie de asemenea să fie abstractă\n2. Clasele abstracte pot avea constructori\n3. O clasă nu poate fi abstractă fără o metodă abstractă\n4. O clasă abstractă poate moșteni de la mai multe clase abstracte",
                "code": null,
                "options": ["1, 2", "1, 3", "3, 4", "1, 3, 4"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 1 este adevărată (o clasă care nu implementează toate metodele abstracte trebuie să fie abstractă), iar afirmația 2 este de asemenea adevărată (clasele abstracte pot avea constructori)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 1 este adevărată. Doar afirmația 3 este falsă în acest set."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Afirmația 3 este falsă deoarece o clasă poate fi abstractă fără metode abstracte. Afirmația 4 este falsă deoarece Java nu suportă moștenire multiplă - o clasă poate moșteni de la o singură clasă (abstractă sau nu)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 1 este adevărată - o clasă care nu implementează toate metodele abstracte trebuie să fie abstractă."
                    }
                ]
            },
            {
                "id": 4,
                "text": "Care dintre următoarele afirmații despre interfețe și clase abstracte sunt adevărate?",
                "description": "1. O clasă poate moșteni în același timp mai multe clase abstracte\n2. O interfață poate moșteni mai multe interfețe în același timp\n3. O interfață poate moșteni o clasă abstractă care are doar metode abstracte\n4. O clasă poate implementa mai multe interfețe în același timp",
                "code": null,
                "options": ["1, 2, 3", "2, 4", "1, 2, 3, 4", "2, 3, 4"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 1 este falsă deoarece Java nu permite moștenire multiplă a claselor. Afirmația 3 este de asemenea falsă - o interfață nu poate moșteni o clasă."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. O interfață poate moșteni (extends) mai multe interfețe în același timp (2) și o clasă poate implementa (implements) mai multe interfețe simultan (4)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 1 este falsă (nu există moștenire multiplă în Java) și afirmația 3 este falsă (o interfață nu poate moșteni o clasă)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Afirmația 3 este falsă - o interfață nu poate moșteni o clasă abstractă. Interfețele pot moșteni doar alte interfețe."
                    }
                ]
            },
            {
                "id": 5,
                "text": "Care dintre următoarele afirmații e corectă?",
                "description": null,
                "code": null,
                "options": [
                    "Cuvântul final în fața unei metode arată faptul că acea metodă poate fi apelată doar în clasa respectivă",
                    "Cuvântul final în fața unei clase înseamnă că nu poate fi instantiată",
                    "Cuvântul final în fața unei variabile arată că acea variabilă poate fi asignată o singură dată",
                    "Cuvântul final în fața unei variabile arată că acea variabilă nu poate fi moștenită"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Cuvântul final în fața unei metode înseamnă că metoda nu poate fi suprascrisă (overridden) în subclase, nu că poate fi apelată doar în clasa respectivă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Cuvântul final în fața unei clase înseamnă că clasa nu poate fi moștenită (extended), nu că nu poate fi instantiată."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Cuvântul final la o variabilă o transformă într-o constantă, ceea ce înseamnă că poate primi o valoare o singură dată și apoi nu mai poate fi modificată."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Variabilele nu se moștenesc în mod direct. Cuvântul final la o variabilă înseamnă că valoarea ei nu poate fi modificată după inițializare."
                    }
                ]
            },
            {
                "id": 6,
                "text": "Care dintre următoarele variante nu are legătură cu încapsularea?",
                "description": null,
                "code": null,
                "options": [
                    "expunerea unei interfețe de lucru cu obiectul",
                    "accesul la membri privați folosind metode de tip getter și setter",
                    "construirea de obiecte complexe și ascunderea modului lor de funcționare",
                    "posibilitatea suprascrierii (overriding) metodelor"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Expunerea unei interfețe publice pentru lucrul cu obiectul este un aspect fundamental al încapsulării - ascundem detaliile interne și oferim doar metodele necesare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Getters și setters sunt instrumente cheie ale încapsulării, permițând accesul controlat la câmpurile private ale unei clase."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Ascunderea detaliilor de implementare și expunerea doar a funcționalității este esența încapsulării."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Overriding-ul (suprascrierea metodelor) este legat de polimorfism, nu de încapsulare. Încapsularea se ocupă de ascunderea detaliilor interne și controlul accesului la date."
                    }
                ]
            },
            {
                "id": 7,
                "text": "Care este outputul următorului program?",
                "description": null,
                "code": "public class Star {\n    private int shininess;\n\n    static void change(Star s, int newShine) {\n        s = new Star();\n        s.shininess = newShine;\n    }\n\n    public static void main() {\n        Star star = new Star();\n        System.out.print(\"Old shininess:\" + star.shininess + \"|\");\n        change(star, newShine: 10);\n        System.out.println(\"New shininess:\" + star.shininess);\n    }\n}",
                "options": [
                    "Old shininess: 0 | New shininess: 10",
                    "Old shininess: 0 | New shininess: 0",
                    "Old shininess: null | New shininess: 0",
                    "Old shininess: null | New shininess: 10"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Parametrul s în metoda change este pasat prin valoare (copia referinței). Când creăm un nou obiect în metodă, modificăm doar copia locală, nu obiectul original star."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. În Java, parametrii sunt pasați prin valoare. Când s = new Star() este executat în change(), se creează un nou obiect și s (copia referinței)PointEază către el, dar obiectul original star rămâne neschimbat cu shininess = 0 (valoarea default pentru int)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Câmpul shininess este de tip int (tip primitiv), care are valoarea default 0, nu null. Null se aplică doar referințelor la obiecte."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Shininess este int, nu Object, deci nu poate fi null. De asemenea, modificarea din change() nu afectează obiectul original."
                    }
                ]
            },
            {
                "id": 8,
                "text": "Care instanțiere este corectă?",
                "description": null,
                "code": null,
                "options": [
                    "List<Integer> list = new ArrayList<Object>();",
                    "ArrayList<Integer> list = new List<Integer>();",
                    "List<Integer> list = new ArrayList<Integer>();",
                    "ArrayList<Object> list = new ArrayList<Integer>();"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. List<Integer> nu este compatibil cu ArrayList<Object> chiar dacă Object este superclasă. În Java, generics nu sunt covariant - List<Object> nu este supertip pentru List<Integer>."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. List este o interfață și nu poate fi instantiată direct. Trebuie să instantiem o implementare concretă (ArrayList, LinkedList, etc.)."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Tipul din stânga (List<Integer>) este interfața, iar tipul din dreapta (ArrayList<Integer>) este implementarea concretă. ArrayList implementează List, deci această atribuire este validă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. ArrayList<Object> și ArrayList<Integer> nu sunt compatibile. Generics în Java sunt invariante - ArrayList<Integer> nu este subtip al ArrayList<Object>."
                    }
                ]
            },
            {
                "id": 9,
                "text": "Ce design pattern face ușoară separarea operațiilor de obiectele pe care se execută operațiile respective?",
                "description": null,
                "code": null,
                "options": [
                    "Builder Pattern",
                    "Visitor Pattern",
                    "Factory Pattern",
                    "Observer Pattern"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Builder Pattern este folosit pentru construirea treptată a obiectelor complexe, nu pentru separarea operațiilor de obiecte."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Visitor Pattern permite definirea de noi operații fără a modifica clasele elementelor pe care operează. Separează algoritmul de structura obiectului, facilitând adăugarea de noi operații."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Factory Pattern se ocupă de crearea obiectelor fără a specifica clasa exactă, nu de separarea operațiilor de obiecte."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Observer Pattern definește o dependență one-to-many între obiecte pentru notificarea automată la schimbări de stare."
                    }
                ]
            },
            {
                "id": 10,
                "text": "Ce design pattern trebuie să folosim în caz că dorim ca un client să nu aibă rol în crearea unui entități după o preferință de a sa?",
                "description": null,
                "code": null,
                "options": [
                    "Singleton Pattern",
                    "Factory Pattern",
                    "Builder Pattern",
                    "Observer Pattern"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Singleton Pattern asigură că o clasă are o singură instanță și oferă un punct global de acces la ea, nu se ocupă de crearea entităților după preferințe."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Factory Pattern permite crearea obiectelor fără ca clientul să specifice clasa exactă. Clientul solicită un obiect pe baza unor criterii, iar factory-ul decide ce tip concret să instantieze."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Builder Pattern este folosit pentru construirea treptată a obiectelor complexe, dar clientul rămâne implicat în procesul de configurare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Observer Pattern se ocupă de notificarea automată a observatorilor când se schimbă starea unui subiect, nu de crearea obiectelor."
                    }
                ]
            },
            {
                "id": 11,
                "text": "Ce fel de Singleton este această secvență de cod?",
                "description": null,
                "code": "public class Database {\n    private static Database obj = null;\n\n    private Database() {\n    }\n\n    public static Database getInstance() {\n        if (obj == null) {\n            obj = new Database();\n        }\n        return obj;\n    }\n}",
                "options": [
                    "Singleton cu inițializare eager",
                    "Singleton cu inițializare lazy",
                    "nu avem Singleton aici",
                    "Singleton cu inițializare în blocuri statice"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Inițializarea eager înseamnă că instanța este creată la încărcarea clasei (ex: private static Database obj = new Database();). Aici instanța este creată la cerere."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Singleton cu lazy initialization - obiectul este creat doar când este solicitat prima dată prin getInstance(). Instanța este null inițial și se creează la primul apel al metodei."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Aceasta este o implementare clasică Singleton: constructor privat, instanță statică și metodă publică getInstance()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Inițializarea în blocuri statice ar folosi un bloc static {} pentru a crea instanța la încărcarea clasei. Aici instanța se creează în getInstance()."
                    }
                ]
            },
            {
                "id": 12,
                "text": "Ce metode pot fi accesate din clasa MyTest?",
                "description": null,
                "code": "package test;\npublic class Test {\n    void execute1() {}\n    protected void execute2() {}\n    private void execute3() {}\n}\n\n....\npackage mytest;\npublic class MyTest extends Test {\n    public void execute2() {}\n}",
                "options": [
                    "execute1, execute2 din Test, execute2 din MyTest",
                    "execute1, execute2 din Test, execute3, execute2 din MyTest",
                    "execute2 din Test, execute2 din MyTest",
                    "execute2 din MyTest"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. execute1() are acces default (package-private) și poate fi accesată doar în același pachet (test). MyTest este în pachetul mytest, deci nu are acces la execute1()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. execute1() nu este accesibilă (package-private din alt pachet), iar execute3() este privată și nu poate fi accesată din subclase."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. MyTest poate accesa: execute2() din Test (moștenită, protected), și execute2() din MyTest (override public). execute1() este package-private și nu este accesibilă din alt pachet. execute3() este privată."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. MyTest are acces și la execute2() din Test (metoda protected moștenită), nu doar la versiunea override."
                    }
                ]
            },
            {
                "id": 13,
                "text": "Ce reprezintă o metodă default în cadrul unei interfețe?",
                "description": null,
                "code": null,
                "options": [
                    "o metodă abstractă",
                    "o metodă non-statică care este deja implementată într-o interfață",
                    "o metodă statică implementată într-o interfață",
                    "nu putem avea metode default într-o interfață"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metodele default nu sunt abstracte - ele au implementare în interfață. Metodele abstracte nu au corp și trebuie implementate de clasele care implementează interfața."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Metodele default în interfețe (introduse în Java 8) sunt metode non-statice cu implementare completă. Permit adăugarea de funcționalitate nouă la interfețe fără a rupe compatibilitatea cu clasele existente."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Metodele default sunt non-statice. Interfețele pot avea și metode statice, dar acestea sunt diferite de metodele default."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Din Java 8, interfețele pot conține metode default cu implementare, alături de metodele abstracte și statice."
                    }
                ]
            },
            {
                "id": 14,
                "text": "Ce se afișează la rularea acestui cod?",
                "description": null,
                "code": "class Document {\n}\n\nclass PdfDocument extends Document {\n}\n\nclass CsvDocument extends Document {\n}\n\nclass DocumentViewer {\n    public void openDocument(Document document) {\n        System.out.println(\"Opening document\");\n    }\n\n    public void openDocument(PdfDocument document) {\n        System.out.println(\"Opening pdf\");\n    }\n\n    public void openDocument(CsvDocument document) {\n        System.out.println(\"Opening csv\");\n    }\n}\n\nclass AdobeReader extends DocumentViewer {\n    public void openDocument(PdfDocument document) {\n        System.out.println(\"Adobe is opening pdf\");\n    }\n\n    public void openDocument(CsvDocument document) {\n        System.out.println(\"Cannot open csv\");\n    }\n}\n\nclass DocumentTest {\n    public static void main(String[] args) {\n        DocumentViewer documentViewer = new AdobeReader();\n        Document file1 = new PdfDocument();\n        CsvDocument file2 = new CsvDocument();\n\n        documentViewer.openDocument(file1);\n        documentViewer.openDocument(file2);\n    }\n}",
                "options": [
                    "Opening document Cannot open csv",
                    "Adobe is opening pdf Cannot open csv",
                    "Adobe is opening pdf Opening csv",
                    "Opening document Opening csv"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. file1 este declarat ca Document (compile-time type), deci se alege openDocument(Document) la compilare, iar la runtime se execută override-ul din AdobeReader. Dar AdobeReader nu override openDocument(Document), deci se execută din DocumentViewer. file2 este CsvDocument, se face override corect."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. file1 are tipul compile-time Document, nu PdfDocument, deci se apelează openDocument(Document). Overloading se rezolvă la compile-time bazat pe tipul declarat, nu pe tipul runtime."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Pentru file1 se apelează openDocument(Document), nu openDocument(PdfDocument), deoarece tipul declarat este Document."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Pentru file2, care este de tip CsvDocument, se apelează versiunea override din AdobeReader care printează \"Cannot open csv\", nu \"Opening csv\"."
                    }
                ]
            },
            {
                "id": 15,
                "text": "Ce se va afișa la execuția codului de mai jos?",
                "description": null,
                "code": "public class Test {\n    public static void main(String[] args){\n        A.B.write();\n        A a = new A();\n        A.write();\n        A.B.write();\n    }\n}\n\nclass A {\n    static boolean x = false;\n    A(){\n        x = false;\n        B.x = true;\n    }\n    static class B {\n        static boolean x = false;\n\n        public static void write(){\n            x = !x;\n            if (x) System.out.print(\"A\");\n            else System.out.print(\"B\");\n        }\n    }\n    public static void write(){\n        x = !x;\n        if (x) System.out.print(\"C\");\n        else System.out.print(\"D\");\n    }\n}",
                "options": ["BCA", "ACB", "ADB", "BDA"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Secvența corectă este: A.B.write() -> B.x devine true -> A, new A() setează B.x = true (rămâne true), A.write() -> A.x devine true -> C, A.B.write() -> B.x devine false -> B. Rezultatul este ACB."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. 1) A.B.write(): B.x devine true -> printează \"A\". 2) new A(): setează A.x=false și B.x=true. 3) A.write(): A.x devine true -> printează \"C\". 4) A.B.write(): B.x devine false -> printează \"B\". Output: ACB."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Prima apelare A.B.write() face B.x = true, deci se printează \"A\", nu \"B\". A doua apelare A.write() face A.x = true, printând \"C\"."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Inițial B.x este false, deci prima apelare A.B.write() va printa \"A\" (B.x devine true), nu \"B\"."
                    }
                ]
            },
            {
                "id": 16,
                "text": "Ce tip de clasă reprezintă următoarea implementare?",
                "description": null,
                "code": "Predicate<Integer> check = x -> x % 2 == 0;",
                "options": [
                    "clasă locală",
                    "clasă anonimă",
                    "clasă nested non-statică",
                    "clasă nested statică"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. O clasă locală este definită într-o metodă cu un nume explicit (class NumeClasa {...}). Lambda expression-urile nu sunt clase locale."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Lambda expression este o formă concisă de a implementa o interfață funcțională (cu o singură metodă abstractă). Compilatorul o transformă într-o clasă anonimă care implementează interfața Predicate."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. O clasă nested non-statică (inner class) este definită în interiorul altei clase fără modificatorul static. Lambda-urile nu sunt clase nested."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. O clasă nested statică este o clasă membră cu modificatorul static. Lambda expression-urile nu sunt clase nested statice."
                    }
                ]
            },
            {
                "id": 17,
                "text": "Ce va afișa programul?",
                "description": null,
                "code": "public class Test {\n    public static void main(String[] args) {\n        Test obj = new Test();\n        obj.first();\n    }\n\n    void first() {\n        String a = \"good\";\n        String b = second(a);\n        System.out.print(\":\" + a + b);\n    }\n\n    String second(String a) {\n        a = a + \"luck\";\n        System.out.print(a);\n        return \"luck\";\n    }\n}",
                "options": [
                    "goodluck:goodluckluck",
                    "goodluck:goodgoodluck",
                    "goodluck:goodluck",
                    "goodluck:luckgoodluck"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. În first(), variabila a rămâne \"good\" deoarece String este imutabil. Operația a + \"luck\" din second() creează un string nou local, fără a modifica string-ul original."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. String-urile sunt imutabile în Java. Modificarea lui a în second() nu afectează variabila a din first(). a rămâne \"good\" în first()."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. 1) În second(), a devine \"goodluck\" local (String imutabil) și se printează \"goodluck\". 2) second() returnează \"luck\" care devine b. 3) În first(), a rămâne \"good\" (imutabil), se printează \":\" + \"good\" + \"luck\" = \":goodluck\". Total: \"goodluck:goodluck\"."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. b primește valoarea returnată \"luck\", nu \"goodluck\". String-ul modificat în second() este local și nu afectează valoarea returnată."
                    }
                ]
            },
            {
                "id": 18,
                "text": "Identificați pe care linii avem suprascriere (overriding) și pe care avem supraîncărcare (overloading) corecte, fără erori de compilare:",
                "description": null,
                "code": "public class Test {\n    public static void main(String[] args) {\n        AudioBook book = new AudioBook();\n    }\n}\n\nclass BookException extends Exception {\n}\n\ninterface Book {\n    void markRead();\n    void markToRead() throws BookException;\n}\n\nclass AudioBook implements Book {\n    public void markRead() {\n    } // 1\n\n    public void markToRead() {\n    } // 2\n\n    public void markRead(int rating) {\n    } // 3\n\n    public void markRead(int rating, Date date) {\n    } // 4\n}",
                "options": [
                    "Suprascriere: 1, Supraîncărcare: 3, 4",
                    "Suprascriere: 1, 2, Supraîncărcare: 3,4",
                    "Suprascriere: 3, 4, Supraîncărcare: 1, 2",
                    "Suprascriere: 3, 4, Supraîncărcare: 1"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 2 este de asemenea suprascriere (override) a metodei markToRead() din interfața Book. O metodă override poate să nu declare excepții chiar dacă metoda din interfață le declară."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Overriding (implementare interfață): liniile 1 și 2 implementează metodele din Book. Overloading (aceeași metodă, parametri diferiți): liniile 3 și 4 sunt versiuni supraîncărcate ale markRead() cu parametri diferiți."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Liniile 1 și 2 sunt overriding (implementare de interfață), nu overloading. Liniile 3 și 4 sunt overloading al metodei markRead()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Linia 1 este overriding (implementare markRead() din Book), iar linia 2 este de asemenea overriding (implementare markToRead() din Book)."
                    }
                ]
            },
            {
                "id": 19,
                "text": "În ce zonă de memorie sunt stocate obiectele?",
                "description": null,
                "code": null,
                "options": ["pe stivă", "pe heap", "în memoria cache", "memoria externă"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Stiva (stack) stochează variabilele locale, parametrii metodelor și referințele la obiecte, nu obiectele în sine."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Obiectele în Java sunt alocate pe heap (memoria dinamică). Referințele la aceste obiecte sunt stocate pe stack, dar obiectele propriu-zise sunt pe heap și sunt gestionate de Garbage Collector."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Memoria cache este o memorie hardware rapidă folosită de procesor pentru optimizare, nu o zonă explicită de alocare a obiectelor în Java."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Memoria externă (disk) nu este folosită implicit pentru stocarea obiectelor în timpul execuției. Obiectele sunt în RAM, pe heap."
                    }
                ]
            },
            {
                "id": 20,
                "text": "Pentru ce folosim map() pe colecții și pe arrays în Java?",
                "description": null,
                "code": null,
                "options": [
                    "pentru a selecta elementele dintr-o colecție / dintr-un array care respectă o condiție reprezentată de funcția lambda dată că parametru",
                    "pentru a aplica o operație pe fiecare element din cadrul colecției sau al array-ului, operație reprezentată de funcția lambda dată că parametru",
                    "pentru a reduce elementele unei colecții / unui array la un singur element prin operația reprezentată de funcția lambda dată că parametru",
                    "pentru a crea o nouă copie a colecției / al array-ului"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Pentru selectarea elementelor care respectă o condiție se folosește filter(), nu map(). Filter returnează un stream cu elementele care îndeplinesc condiția."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. map() aplică o funcție de transformare pe fiecare element și returnează un nou stream/array cu rezultatele. De exemplu, list.stream().map(x -> x * 2) înmulțește fiecare element cu 2."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. Pentru reducerea elementelor la o singură valoare se folosește reduce(), nu map(). Reduce acumulează valorile folosind o operație binară."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Fals. map() nu creează o copie simplă, ci transformă fiecare element folosind funcția dată. Pentru copiere simplă există alte metode (clone(), copyOf(), etc.)."
                    }
                ]
            }
        ];

        const questionsExamenCa2020 = [
            {
                "id": 1,
                "text": "Când apare NullPointerException?",
                "description": null,
                "code": null,
                "options": [
                    "(a) Când încercăm să deschidem un fișier care nu există",
                    "(b) Când facem buffer overflow la un array",
                    "(c) Când încercăm să folosim un obiect null",
                    "(d) Când folosim o colecție care este instanțiată și goală"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Când încercăm să deschidem un fișier care nu există, se aruncă FileNotFoundException, nu NullPointerException."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Buffer overflow la un array generează ArrayIndexOutOfBoundsException, nu NullPointerException."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. NullPointerException apare când încercăm să folosim un obiect care este null (să apelăm o metodă sau să accesăm un câmp al unui obiect null)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. O colecție instanțiată și goală nu produce NullPointerException; colecția există în memorie, doar că nu conține elemente."
                    }
                ]
            },
            {
                "id": 2,
                "text": "Care este rezultatul execuției codului de mai jos?",
                "description": null,
                "code": "String a = \"hello\";\nString b = \"world\";\nString c = b;\nb = a + b;\nString d = new String(\"hello\");\nSystem.out.println(c + \" \" + (d == a));",
                "options": [
                    "(a) world false",
                    "(b) helloworld true",
                    "(c) hello true",
                    "(d) helloworld false"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Variabila c păstrează referința către \"world\" (valoarea inițială a lui b). Comparația d == a este false pentru că d este creat cu \"new\" și are o altă adresă în memorie decât a (care folosește string pool-ul)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. c nu devine \"helloworld\" deoarece atribuirea b = a + b modifică doar referința lui b, nu și pe cea a lui c care continua să refere \"world\"."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. c nu este \"hello\", ci \"world\", valoarea inițială la care referă înainte ca b să fie modificat."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. c nu este \"helloworld\", ci \"world\", deoarece c a fost asignat cu referința inițială a lui b."
                    }
                ]
            },
            {
                "id": 3,
                "text": "Care variantă definește cel mai bine legătura dintre interfețe și clase?",
                "description": null,
                "code": null,
                "options": [
                    "(a) Nu pot exista relații între clase și interfețe",
                    "(b) Nici clasele, nici interfețele nu precizează modul în care un obiect execută o operație",
                    "(c) Interfețele precizează operațiile expuse de un obiect, în timp ce clasele modul în care acesta le execută",
                    "(d) Atât clasele, cât și interfețele definesc modul în care un obiect execută o operație"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Există relații foarte importante între clase și interfețe - clasele implementează interfețele."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Clasele definesc exact modul în care operațiile sunt executate prin implementarea metodelor."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Interfețele definesc contractul (ce operații trebuie să existe), iar clasele definesc implementarea (cum se execută aceste operații)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Interfețele nu definesc modul de execuție, ci doar semnătura metodelor; implementarea este furnizată de clase."
                    }
                ]
            },
            {
                "id": 4,
                "text": "Ce afirmație despre Set și List este adevărată?",
                "description": null,
                "code": null,
                "options": [
                    "(a) În Set nu avem elemente duplicate, iar Set extinde interfața List",
                    "(b) În Set putem avea elemente duplicate, la fel ca în List",
                    "(c) Nici în Set, nici în List nu avem elemente duplicate",
                    "(d) În Set nu avem elemente duplicate, iar în List putem să avem"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Deși este corect că Set nu permite duplicate, Set NU extinde interfața List - ambele extind Collection independent."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Set nu permite elemente duplicate, aceasta fiind caracteristica sa definitorie."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. List permite elemente duplicate, spre deosebire de Set."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Set nu permite duplicate (unicitate), în timp ce List permite duplicate și păstrează ordinea de inserție."
                    }
                ]
            },
            {
                "id": 5,
                "text": "Care este rezultatul execuției codului de mai jos?",
                "description": "Fie:\nclass Device {\n    public static void charge() {\n        System.out.print(\"Charging device; \");\n    }\n}\nclass Phone extends Device {\n    public static void charge() {\n        System.out.print(\"Charging phone; \");\n    }\n}",
                "code": "Device phone = new Phone();\nDevice device = new Device();\nphone.charge();\ndevice.charge();\nDevice.charge();",
                "options": [
                    "(a) Charging device; Charging device; Charging phone;",
                    "(b) Charging phone; Charging phone; Charging device;",
                    "(c) Charging device; Charging device; Charging device;",
                    "(d) Charging phone; Charging device; Charging device;"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Ultimul apel nu execută metoda din Phone."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Metodele statice nu beneficiază de polimorfism - apelul se face pe baza tipului variabilei de referință."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Metodele statice nu suportă polimorfism. Apelul se face în funcție de tipul variabilei de referință, nu de tipul obiectului. Toate apelurile folosesc metoda din Device."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. phone.charge() nu execută metoda din Phone, ci din Device, deoarece metodele statice nu sunt polimorfice."
                    }
                ]
            },
            {
                "id": 6,
                "text": "Care afirmații sunt adevărate despre clase interne statice?",
                "description": "1. Nu au acces la membri non-statici ai clasei exterioare\n2. Este nevoie de o instanță a clasei externe pentru a o instanția\n3. Trebuie să moștenească clasa exterioară\n4. Trebuie instanțiată astfel: Outer out = new Outer(); Inner in = out.new Inner();",
                "code": null,
                "options": ["(a) 3", "(b) 1", "(c) 2,4", "(d) 1,2"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Afirmația 3 este falsă - clasele interne statice nu trebuie să moștenească clasa exterioară."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Clasele interne statice (static nested classes) nu au acces la membrii non-statici ai clasei exterioare și pot fi instanțiate direct: Outer.Inner in = new Outer.Inner(); fără a avea nevoie de o instanță a clasei externe."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Ambele afirmații sunt false - clasele interne statice NU necesită instanță a clasei externe și se instanțiază direct: Outer.Inner in = new Outer.Inner();"
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Afirmația 2 este falsă - clasele interne statice NU necesită o instanță a clasei externe pentru a fi instanțiate."
                    }
                ]
            },
            {
                "id": 7,
                "text": "În Java, prin compararea a două obiecte cu ==, ce se compară?",
                "description": null,
                "code": null,
                "options": [
                    "(a) tipurile obiectelor",
                    "(b) mărimile obiectelor",
                    "(c) adresele obiectelor",
                    "(d) valorile obiectelor"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Operatorul == nu compară tipurile obiectelor - tipurile sunt verificate la compilare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Operatorul == nu compară mărimea (dimensiunea) obiectelor în memorie."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Operatorul == pentru obiecte compară adresele (referințele) din memorie, nu conținutul obiectelor."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Pentru compararea valorilor (conținutului) obiectelor trebuie folosită metoda equals(), nu operatorul ==."
                    }
                ]
            },
            {
                "id": 8,
                "text": "Fie un serviciu de tip Youtube, în care avem utilizatori care se pot abona la canale, putând fi la curent cu noutățile canalelor la care ei sunt abonați (încărcare videoclip nou, depășirea unui anumit număr de abonați etc). Ce design pattern se poate aplica aici?",
                "description": null,
                "code": null,
                "options": ["(a) Visitor", "(b) Factory", "(c) Observer", "(d) Command"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Visitor pattern se folosește pentru a adăuga operații noi la o ierarhie de clase fără a le modifica."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Factory pattern se ocupă cu crearea de obiecte, nu cu notificarea schimbărilor."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Observer pattern este utilizat pentru scenariile subscribe/notify, unde observatorii (utilizatorii) sunt notificați automat când subiectul (canalul) se schimbă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Command pattern încapsulează operații ca obiecte, dar nu gestionează relații subscribe/notify."
                    }
                ]
            },
            {
                "id": 9,
                "text": "Care dintre următoarele afirmații sunt adevărate?",
                "description": "1) Clasele abstracte pot avea keyword-ul final\n2) O clasă poate moșteni mai multe clase în același timp\n3) O interfață poate moșteni mai multe interfețe în același timp\n4) Metodele și atributele de tip protected pot fi accesate doar din clasa-origine și din clasele derivate",
                "code": null,
                "options": ["(a) 1, 2, 3", "(b) 3, 4", "(c) 2, 3, 4", "(d) 1, 2, 3, 4"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Afirmațiile 1 și 2 sunt false - clasele abstracte nu pot fi finale (contradicție) și Java nu suportă moștenire multiplă pentru clase."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Afirmația 3 este adevărată (interfețele pot moșteni multiple interfețe) și 4 este parțial adevărată (protected e accesibil în clasă, clase derivate și în același package). Afirmațiile 1 (abstract și final sunt contradictorii) și 2 (nu există moștenire multiplă pentru clase în Java) sunt false."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Afirmația 2 este falsă - Java nu permite moștenire multiplă pentru clase (doar pentru interfețe)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Afirmațiile 1 și 2 sunt false."
                    }
                ]
            },
            {
                "id": 10,
                "text": "Dacă Feline extinde clasa abstractă Animal și Lion extinde Feline, atunci care instanțiere este corectă?",
                "description": null,
                "code": null,
                "options": [
                    "(a) Feline feline = new Animal();",
                    "(b) Animal animal = new Feline();",
                    "(c) Lion lion = new Animal();",
                    "(d) Lion lion = new Feline();"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Nu putem instanția Animal deoarece este o clasă abstractă, iar downcast-ul de la clasa abstractă la subclasă este invalid."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Dacă Feline este o clasă concretă (nu abstractă), putem instanția un obiect de tip Feline și îl putem referi prin variabila de tip Animal datorită polimorfismului (upcast de la subclasă la superclasă)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Nu putem instanția Animal deoarece este o clasă abstractă."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Nu putem face downcast implicit de la Feline la Lion fără un cast explicit, și chiar cu cast ar da ClassCastException la runtime dacă obiectul nu este de fapt un Lion."
                    }
                ]
            },
            {
                "id": 11,
                "text": "Ce înseamnă constructorul default?",
                "description": null,
                "code": null,
                "options": [
                    "(a) constructor fără parametri declarat de utilizator",
                    "(b) constructor fără implementare",
                    "(c) constructor fără modificatori de acces",
                    "(d) constructor fără parametri adăugat de Java dacă niciun constructor nu a fost declarat"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Un constructor fără parametri declarat de utilizator se numește \"no-argument constructor\", nu \"default constructor\"."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Constructorul default are implementare (chiar dacă goală) și apelează super()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Constructorul default are modificator de acces - același cu cel al clasei."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Constructorul default este constructorul fără parametri pe care Java îl adaugă automat dacă nu declarăm niciun constructor. Odată ce declarăm orice constructor, Java nu mai adaugă constructorul default."
                    }
                ]
            },
            {
                "id": 12,
                "text": "Ce design pattern putem folosi pentru a avea un obiect unic și vizibil la nivel global?",
                "description": null,
                "code": null,
                "options": ["(a) Observer", "(b) Visitor", "(c) Singleton", "(d) Factory"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Observer pattern se ocupă cu notificări între obiecte, nu cu unicitatea instanțelor."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Visitor pattern se ocupă cu adăugarea de operații noi la ierarhii de clase."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Singleton pattern asigură că o clasă are o singură instanță și oferă un punct global de acces la ea prin constructor privat și metodă statică getInstance()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Factory pattern se ocupă cu crearea de obiecte, dar nu garantează unicitatea instanței."
                    }
                ]
            },
            {
                "id": 13,
                "text": "În ce colecție de tip Set se păstrează ordinea inserției elementelor?",
                "description": null,
                "code": null,
                "options": [
                    "(a) AbstractSet",
                    "(b) LinkedHashSet",
                    "(c) HashSet",
                    "(d) TreeSet"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. AbstractSet este o clasă abstractă care nu garantează ordinea."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. LinkedHashSet păstrează ordinea de inserție a elementelor folosind o listă dublu înlănțuită, spre deosebire de HashSet care nu garantează ordinea."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. HashSet nu păstrează și nu garantează nicio ordine a elementelor."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. TreeSet păstrează elementele sortate natural sau conform unui Comparator, nu ordinea inserției."
                    }
                ]
            },
            {
                "id": 14,
                "text": "Ce colecție ar fi mai eficientă de folosit dacă dorim să stocăm o secvență de elemente pe care să o modificăm rar dar pe care să o accesăm foarte des?",
                "description": null,
                "code": null,
                "options": [
                    "(a) ArrayList",
                    "(b) LinkedList",
                    "(c) niciuna din variante",
                    "(d) Vector"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. ArrayList este mai eficient pentru acces aleator (get) datorită structurii de array intern care permite acces O(1), în timp ce LinkedList necesită traversare O(n)."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. LinkedList este eficient pentru inserări/ștergeri frecvente, dar accesul la elemente este O(n) față de O(1) la ArrayList."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. ArrayList este o variantă foarte bună pentru acest scenariu."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Deși Vector este similar cu ArrayList pentru acces, este sincronizat (thread-safe) ceea ce adaugă overhead inutil dacă nu este necesar."
                    }
                ]
            },
            {
                "id": 15,
                "text": "Ce rol are un copy constructor?",
                "description": null,
                "code": null,
                "options": [
                    "(a) de a copia datele și referința unui obiect",
                    "(b) de a copia referința unui obiect",
                    "(c) de a distruge referința unui obiect",
                    "(d) de a copia datele unui obiect"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Copy constructor creează un nou obiect cu date copiate, nu copiază referința - ar însemna că ambele variabile ar referi același obiect."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Copierea doar a referinței nu este rolul copy constructor-ului - aceasta se face prin simpla atribuire."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Copy constructor creează obiecte noi, nu distruge referințe."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Copy constructor creează un nou obiect copiind datele (valorile câmpurilor) dintr-un obiect existent, creând astfel o copie independentă cu propria referință în memorie."
                    }
                ]
            },
            {
                "id": 16,
                "text": "Care este rezultatul execuției codului de mai jos?",
                "description": "Unde:\nclass Cake extends Food {\n    public void cut() {\n        System.out.print(\" Cake \");\n    }\n}\nclass Food {\n    public void cut() {\n        System.out.print(\" Food \");\n    }\n}",
                "code": "Food food1 = new Food();\nFood food2 = new Cake();\nCake cake = new Cake();\nfood1.cut();\nfood2.cut();\ncake.cut();",
                "options": [
                    "(a) Food Food Cake",
                    "(b) Food Food Food",
                    "(c) Food Cake Cake",
                    "(d) Cake Cake Cake"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. food2 referă un obiect de tip Cake, deci se va apela metoda cut() din Cake datorită polimorfismului."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Polimorfismul face ca metoda din clasa efectivă a obiectului să fie apelată, nu cea din tipul variabilei de referință."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Polimorfism în acțiune: food1.cut() apelează Food.cut(), food2.cut() apelează Cake.cut() (deși tipul variabilei este Food, obiectul este Cake și metoda este override), cake.cut() apelează Cake.cut()."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. food1 este de tip Food și referă un obiect Food, deci se va apela metoda cut() din Food."
                    }
                ]
            },
            {
                "id": 17,
                "text": "Identificați pe care linii avem suprascriere (overriding) și pe care avem supraîncărcare (overloading)",
                "description": null,
                "code": "interface Coffee {\n    void brew(); // 1\n    void drink(); // 2\n}\nclass Espresso implements Coffee {\n    public void brew() { } // 3\n    public void drink() { } // 4\n    public void drink(Boolean withSugar) { } // 5\n    public void drink(Boolean withMilk,\n                      Boolean withSugar) { } // 6\n}",
                "options": [
                    "(a) Suprascriere: 5,6; Supraîncărcare: 3,4",
                    "(b) Suprascriere: 1,2,3; Supraîncărcare: 4,5,6",
                    "(c) Suprascriere: 3; Supraîncărcare: 4,5,6",
                    "(d) Suprascriere: 3,4; Supraîncărcare: 5,6"
                ],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Liniile 3 și 4 sunt suprascriere (implementare de metode din interfață), nu supraîncărcare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Liniile 1 și 2 sunt doar declarații în interfață, nu suprascriere. Linia 4 este suprascriere, nu supraîncărcare."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Linia 4 este suprascriere (implementare din interfață), nu supraîncărcare."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Liniile 3 și 4 implementează (override) metodele din interfața Coffee. Liniile 5 și 6 sunt overloading (aceeași metodă drink cu parametri diferiți în aceeași clasă)."
                    }
                ]
            },
            {
                "id": 18,
                "text": "Ce se va afișa la rularea codului?",
                "description": null,
                "code": "class Foo {\n    public int doWork(int x) {\n        try {\n            x++;\n            if (x < 3) {\n                throw new Exception();\n            }\n            return ++x;\n        } catch (Exception e) {\n            return x++;\n        } finally {\n            return ++x;\n        }\n    }\n}\nclass Main {\n    public static void main(String[] args) {\n        Foo f = new Foo();\n        System.out.println(f.doWork(1));\n    }\n}",
                "options": ["(a) 3", "(b) 4", "(c) 2", "(d) 5"],
                "answers": [
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Valoarea returnată este 4, nu 3."
                    },
                    {
                        "isCorrect": true,
                        "explanation": "Corect. x devine 2 în try (x=1, apoi x++), se aruncă excepția (2<3), în catch x++ returnează 2 dar înainte x devine 3, apoi finally execută ++x care face x să devină 4 și returnează 4, suprascriind return-ul din catch."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Deși catch-ul ar returna 2 (valoarea lui x înainte de incrementare), blocul finally suprascrie acest return."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Valoarea returnată este 4, nu 5."
                    }
                ]
            },
            {
                "id": 19,
                "text": "Ce se va afișa la rularea codului?",
                "description": null,
                "code": "class Foo {\n    public static void doWork() {\n        System.out.print(\"Done! \");\n    }\n}\nclass Main {\n    public static void main(String[] args) {\n        Foo f = null;\n        f.doWork();\n        Foo.doWork();\n    }\n}",
                "options": [
                    "(a) \"Done! Done!\"",
                    "(b) La compilare va da o eroare la f.doWork();",
                    "(c) \"Done! \"",
                    "(d) La rulare programul va da NullPointerException"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Metodele statice pot fi apelate pe referințe null fără NullPointerException (deși nu e recomandat). Apelul f.doWork() este rezolvat la compile-time ca Foo.doWork(). Ambele apeluri funcționează și afișează \"Done! Done!\"."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Nu există eroare de compilare - apelarea metodelor statice pe referințe null este permisă sintactic."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Ambele apeluri se execută și afișează \"Done! \", deci rezultatul este \"Done! Done!\"."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. NullPointerException apare doar când încercăm să accesăm membri non-statici pe referințe null, nu la metode statice."
                    }
                ]
            },
            {
                "id": 20,
                "text": "Ce reprezintă implementarea unei clase anonime?",
                "description": null,
                "code": null,
                "options": [
                    "(a) implementarea unei interfețe sau extinderea unei clase",
                    "(b) implementarea de metode anonime",
                    "(c) implementarea unei interfețe în mod exclusiv",
                    "(d) crearea unei clase care are un constructor"
                ],
                "answers": [
                    {
                        "isCorrect": true,
                        "explanation": "Corect. Clasele anonime pot implementa o interfață SAU extinde o clasă concretă sau abstractă, oferind implementare inline fără a declara o clasă separată cu nume."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Nu există conceptul de \"metode anonime\" în Java - clasele anonime implementează metode obișnuite."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Clasele anonime pot atât implementa interfețe, cât și extinde clase, nu doar interfețe în mod exclusiv."
                    },
                    {
                        "isCorrect": false,
                        "explanation": "Greșit. Clasele anonime NU pot avea constructori declarați explicit - pot avea doar blocuri de inițializare."
                    }
                ]
            }
        ];



        const questionsJavaBasics = [
            {
                "id": 1,
                "text": "Care este mărimea tipului primitiv 'int' în Java?",
                "code": null,
                "options": [
                    "8 biți",
                    "16 biți",
                    "32 biți",
                    "64 biți"
                ],
                "answers": [
                    {"isCorrect": false, "explanation": "byte are 8 biți."},
                    {"isCorrect": false, "explanation": "short are 16 biți."},
                    {"isCorrect": true, "explanation": "Corect. int are 32 de biți (4 bytes)."},
                    {"isCorrect": false, "explanation": "long are 64 de biți."}
                ]
            },
            {
                "id": 2,
                "text": "Care dintre următoarele NU este un cuvânt cheie (keyword) în Java?",
                "code": null,
                "options": [
                    "static",
                    "Boolean",
                    "void",
                    "transient"
                ],
                "answers": [
                    {"isCorrect": false, "explanation": "static este un cuvânt cheie."},
                    {"isCorrect": true, "explanation": "Corect. 'Boolean' este o clasă wrapper din pachetul java.lang. Cuvântul cheie pentru tipul primitiv este 'boolean' (cu literă mică)."},
                    {"isCorrect": false, "explanation": "void este un cuvânt cheie."},
                    {"isCorrect": false, "explanation": "transient este un cuvânt cheie."}
                ]
            },
            {
                "id": 3,
                "text": "Ce va afișa următorul cod?",
                "code": "String s = \"Java\";\ns.concat(\" SE 11\");\ns.replace('J', 'L');\nSystem.out.println(s);",
                "options": [
                    "Java SE 11",
                    "Lava",
                    "Java",
                    "Lava SE 11"
                ],
                "answers": [
                    {"isCorrect": false, "explanation": "Metodele clasei String nu modifică obiectul curent."},
                    {"isCorrect": false, "explanation": "Metodele clasei String nu modifică obiectul curent."},
                    {"isCorrect": true, "explanation": "Corect. Clasa String este imutabilă. Metodele concat() și replace() returnează noi obiecte String, dar rezultatele lor sunt ignorate aici. Variabila s rămâne neschimbată."},
                    {"isCorrect": false, "explanation": "Metodele clasei String nu modifică obiectul curent."}
                ]
            }
        ];

        const quizzes = {
            "examExCB": {
                title: "Examen exemplu - CB",
                data: questionsExamCBExemplu
            },
            "examCA2021": {
                title: "Examen CA 2021",
                data: questionsExamenCa2021
            },
            "examCA2020": {
                title: "Examen CA 2020",
                data: questionsExamenCa2020
            },
            "javaBasics": {
                title: "Java Basics (Test)",
                data: questionsJavaBasics
            }
        };

        // --- STATE ---

        let currentQuizId = "examExCB";
        let currentQuestions = quizzes[currentQuizId].data;
        let questionState = new Array(currentQuestions.length).fill(null);

        // --- FUNCTIONS ---

        function escapeHTML(str) {
            if (!str) return "";
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function switchQuiz(quizId) {
            currentQuizId = quizId;
            currentQuestions = quizzes[quizId].data;

            // Update title
            document.getElementById('quizTitle').innerText = quizzes[quizId].title;

            // Reset state
            questionState = new Array(currentQuestions.length).fill(null);

            // Re-render
            renderQuiz();
            updateScoreDisplay();
        }

        function renderQuiz() {
            const container = document.getElementById('quiz');
            let html = '';

            currentQuestions.forEach((q, index) => {
                let codeBlock = q.code ? `
                    <div class="code-wrapper">
                        <button class="copy-btn" onclick="copyToClipboard(${index}, this)" title="Copy code">Copy</button>
                        <pre><code>${escapeHTML(q.code)}</code></pre>
                    </div>` : '';
                let descriptionHtml = q.description ? `<div class="question-description" style="margin-bottom: 15px; white-space: pre-wrap;">${escapeHTML(q.description)}</div>` : '';

                let optionsHtml = q.options.map((opt, i) => `
                    <li class="option-item">
                        <label class="option-label" id="label-${index}-${i}">
                            <input type="radio" name="q${index}" value="${i}" onchange="checkAnswer(${index}, ${i})">
                            ${escapeHTML(opt)}
                        </label>
                    </li>
                `).join('');

                html += `
                    <div class="question-card" id="card-${index}">
                        <div class="question-text">${index + 1}. ${escapeHTML(q.text)}</div>
                        ${descriptionHtml}
                        ${codeBlock}
                        <ul class="options">${optionsHtml}</ul>
                        <div class="result-box" id="result-${index}"></div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function copyToClipboard(index, btn) {
            const rawCode = currentQuestions[index].code;
            // Remove line numbers (e.g. "1. ")
            const cleanCode = rawCode.replace(/^\s*\d+\.\s/gm, '');

            navigator.clipboard.writeText(cleanCode).then(() => {
                const originalText = btn.innerText;
                btn.innerText = 'Copied!';
                setTimeout(() => {
                    btn.innerText = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }

        function checkAnswer(qIndex, selectedValue) {
            const q = currentQuestions[qIndex];
            const resultBox = document.getElementById(`result-${qIndex}`);
            const labels = document.querySelectorAll(`[id^="label-${qIndex}-"]`);

            // Reset visual state for this question
            labels.forEach(label => {
                label.classList.remove('correct', 'incorrect');
            });

            // Show result box
            resultBox.style.display = 'block';
            resultBox.className = 'result-box';

            const selectedAnswer = q.answers[selectedValue];

            if (selectedAnswer.isCorrect) {
                // Update state
                questionState[qIndex] = true;

                resultBox.innerHTML = "Corect!";
                resultBox.classList.add('correct-answer');
                document.getElementById(`label-${qIndex}-${selectedValue}`).classList.add('correct');
            } else {
                // Update state
                questionState[qIndex] = false;

                // Find correct answer index
                const correctIndex = q.answers.findIndex(a => a.isCorrect);
                const correctOptionText = q.options[correctIndex];

                resultBox.innerHTML = `Greșit. Varianta corectă era: "${escapeHTML(correctOptionText)}"`;
                resultBox.classList.add('wrong-answer');
                document.getElementById(`label-${qIndex}-${selectedValue}`).classList.add('incorrect');
                document.getElementById(`label-${qIndex}-${correctIndex}`).classList.add('correct');
            }

            if (selectedAnswer.explanation) {
                resultBox.innerHTML += `<div class="explanation">${escapeHTML(selectedAnswer.explanation)}</div>`;
            }

            updateScoreDisplay();
        }

        function updateScoreDisplay() {
            const finalDiv = document.getElementById('finalScore');
            const currentScore = questionState.filter(s => s === true).length;
            const answeredCount = questionState.filter(s => s !== null).length;
            finalDiv.innerText = `Scor: ${currentScore} / ${currentQuestions.length} (Răspunsuri: ${answeredCount})`;
        }

        // Initialize
        renderQuiz();
        updateScoreDisplay();
    </script>
</body>

</html>
