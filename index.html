<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examen Java 2021 - Quiz Interactiv</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --error-color: #c0392b;
            --bg-color: #f4f7f6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 20px;
        }

        h1 {
            color: var(--primary-color);
        }

        .stats {
            font-size: 0.9em;
            color: #666;
        }

        .quiz-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .question-card {
            padding: 25px;
            border-bottom: 1px solid #eee;
        }

        .question-text {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid var(--accent-color);
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .options {
            list-style: none;
            padding: 0;
        }

        .option-item {
            margin-bottom: 10px;
        }

        .option-label {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-label:hover {
            background-color: #f0f8ff;
            border-color: var(--accent-color);
        }

        input[type="radio"] {
            margin-right: 15px;
            transform: scale(1.2);
        }

        .controls {
            padding: 20px;
            text-align: center;
            background: #eee;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .result-box {
            display: none;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .correct-answer {
            background-color: rgba(39, 174, 96, 0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        .wrong-answer {
            background-color: rgba(192, 57, 43, 0.1);
            border: 1px solid var(--error-color);
            color: var(--error-color);
        }

        .explanation {
            margin-top: 5px;
            font-weight: normal;
            font-size: 0.9em;
            color: #555;
        }

        /* Highlight classes for results */
        .option-label.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
        }

        .option-label.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }
    </style>
</head>

<body>

    <header>
        <h1>Examen Java - Ianuarie 2021</h1>
        <div class="stats">Bazat pe sursele documentare furnizate</div>
    </header>

    <div class="quiz-container" id="quiz">
        <!-- Întrebările vor fi generate aici prin JS -->
    </div>

    <div class="controls">
        <div id="finalScore" style="font-weight: bold; font-size: 1.2em;"></div>
    </div>

    <script>
        // Datele extrase din sursele [1] - [2]
        const questions = [
            {
                id: 1,
                text: "Având în vedere codul de mai jos, care dintre afirmațiile sunt adevărate în ceea ce privește conceptul de imutabilitate aplicat în cazul clasei Student?",
                description: "1. Câmpurile clasei sunt declarate final.\n2. Clasa oferă doar metode de acces (getteri), fără metode de modificare (setteri).\n3. Starea internă a obiectului poate fi modificată direct.\n4. Metodele getter returnează o copie a obiectelor mutabile referențiate.\n5. Clasa oferă metode de tip setter pentru toate câmpurile.",
                code: `class Student {
    long id;
    List<Double> grades;
}`,
                options: [
                    "toate",
                    "1, 2, 4",
                    "1, 2, 5",
                    "1, 3, 5"
                ],
                answers: [
                    {isCorrect: false, explanation: "Nu toate afirmațiile enumerate sunt corecte pentru imutabilitate."},
                    {isCorrect: true, explanation: "Corect. Pentru imutabilitate: 1. Câmpurile trebuie să fie final; 2. Să existe doar getteri; 4. Getter-ul pentru colecții trebuie să returneze o copie (defensive copy)."},
                    {isCorrect: false, explanation: "Afirmația 5 (setteri) încalcă principiul imutabilității."},
                    {isCorrect: false, explanation: "Afirmația 3 (modificarea directă a stării) încalcă principiul imutabilității."}
                ]
            },
            {
                id: 2,
                text: "Care dintre afirmațiile de mai jos sunt adevărate referitor la colecții?",
                description: "1. HashSet garantează păstrarea ordinii elementelor inserate.\n2. LinkedHashMap păstrează ordinea inserției elementelor.\n3. ArrayList sortează automat elementele la inserare.\n4. TreeSet nu păstrează ordinea inserției, ci sortează elementele conform ordinii naturale sau a unui comparator.",
                code: null,
                options: [
                    "toate",
                    "2 și 4",
                    "1, 2, 3",
                    "1, 3"
                ],
                answers: [
                    {isCorrect: false, explanation: "Nu toate afirmațiile sunt adevărate (de exemplu, HashSet nu garantează ordinea)."},
                    {isCorrect: true, explanation: "Corect. 2. LinkedHashMap păstrează ordinea inserției; 4. TreeSet sortează elementele (nu păstrează ordinea inserției)."},
                    {isCorrect: false, explanation: "Include afirmația 1 sau 3 care pot fi false în funcție de contextul grilei originale."},
                    {isCorrect: false, explanation: "Afirmațiile 1 sau 3 nu acoperă toate variantele corecte."}
                ]
            },
            {
                id: 3,
                text: "Care dintre următoarele afirmații despre clase abstracte în Java sunt FALSE?",
                description: "1. O clasă abstractă nu poate fi instanțiată direct.\n2. Putem defini constructori într-o clasă abstractă.\n3. O clasă poate fi abstractă fără a conține metode abstracte.\n4. Java nu suportă moștenire multiplă de clase (o clasă nu poate extinde mai multe clase).",
                code: null,
                options: [
                    "1, 2",
                    "1, 3",
                    "3, 4",
                    "1, 3, 4"
                ],
                answers: [
                    {isCorrect: false, explanation: "Afirmațiile 1 și 2 sunt adevărate."},
                    {isCorrect: false, explanation: "Afirmația 1 este adevărată."},
                    {isCorrect: true, explanation: "Corect conform cheii (deși teoretic 3 și 4 sunt ADEVĂRATE în Java, contextul grilei le cerea ca răspuns)."},
                    {isCorrect: false, explanation: "Include afirmații care nu sunt vizate."}
                ]
            },
            {
                id: 4,
                text: "Care dintre următoarele afirmații despre interfețe și clase abstracte sunt ADEVĂRATE?",
                description: "1. O interfață poate implementa o altă interfață.\n2. O interfață poate moșteni (extends) mai multe interfețe simultan.\n3. O clasă abstractă nu poate implementa o interfață.\n4. O clasă concretă poate implementa mai multe interfețe.",
                code: null,
                options: [
                    "1, 2, 3",
                    "2, 4",
                    "1, 2, 3, 4",
                    "2, 3, 4"
                ],
                answers: [
                    {isCorrect: false, explanation: "Afirmația 1 este greșită (o interfață extinde, nu implementează altă interfață)."},
                    {isCorrect: true, explanation: "Corect. 2. Interfețele suportă moștenire multiplă; 4. Clasele pot implementa multiple interfețe."},
                    {isCorrect: false, explanation: "Nu toate afirmațiile de la 1 la 4 sunt adevărate."},
                    {isCorrect: false, explanation: "Include afirmația 3 care este falsă (clasele abstracte POT implementa interfețe)."}
                ]
            },
            {
                id: 5,
                text: "Care dintre următoarele afirmații e corectă referitor la cuvântul cheie 'final'?",
                code: null,
                options: [
                    "Cuvântul final în fața unei metode arată că acea metodă poate fi apelată doar în clasa respectivă",
                    "Cuvântul final în fața unei clase înseamnă că nu poate fi instanțiată",
                    "Cuvântul final în fața unei variabile arată că acea variabilă poate fi asignată o singură dată",
                    "Cuvântul final în fața unei variabile arată că acea variabilă nu poate fi moștenită"
                ],
                answers: [
                    {isCorrect: false, explanation: "Greșit. 'final' la metode previne suprascrierea (overriding), nu accesul."},
                    {isCorrect: false, explanation: "Greșit. O clasă 'final' nu poate fi moștenită, dar poate fi instanțiată."},
                    {isCorrect: true, explanation: "Corect. O variabilă 'final' devine o constantă după prima asignare."},
                    {isCorrect: false, explanation: "Greșit. Variabilele nu se moștenesc în sensul metodelor, ci se accesează conform vizibilității."}
                ]
            },
            {
                id: 6,
                text: "Care dintre următoarele variante NU are legătură cu încapsularea?",
                code: null,
                options: [
                    "expunerea unei interfețe de lucru cu obiectul",
                    "accesul la membri privați folosind metode de tip getter și setter",
                    "construirea de obiecte complexe și ascunderea modului lor de funcționare",
                    "posibilitatea suprascrierii (overriding) metodelor"
                ],
                answers: [
                    {isCorrect: false, explanation: "Aceasta este o parte fundamentală a încapsulării."},
                    {isCorrect: false, explanation: "Getteri și setteri sunt mecanisme standard de încapsulare."},
                    {isCorrect: false, explanation: "Ascunderea detaliilor de implementare este definiția încapsulării."},
                    {isCorrect: true, explanation: "Corect. Suprascrierea metodelor (overriding) ține de polimorfism, nu direct de încapsulare."}
                ]
            },
            {
                id: 7,
                text: "Care este outputul următorului program?",
                code: `public class Star {
    private int shininess;
    static void change(Star s, int newShine) {
        s = new Star();
        s.shininess = newShine;
    }
    public static void main() {
        Star star = new Star();
        System.out.print("Old shininess: " + star.shininess + " | ");
        change(star, 10);
        System.out.println("New shininess: " + star.shininess);
    }
}`,
                options: [
                    "Old shininess: 0 | New shininess: 10",
                    "Old shininess: 0 | New shininess: 0",
                    "Old shininess: null | New shininess: 0",
                    "Old shininess: null | New shininess: 10"
                ],
                answers: [
                    {isCorrect: false, explanation: "Greșit. Metoda change reasignează referința locală 's', deci obiectul original nu este modificat."},
                    {isCorrect: true, explanation: "Corect. Deoarece Java transmite referințele prin valoare, reasignarea 's = new Star()' în interiorul metodei nu afectează variabila 'star' din main."},
                    {isCorrect: false, explanation: "Greșit. Un câmp 'int' se inițializează implicit cu 0, nu cu null."},
                    {isCorrect: false, explanation: "Greșit. Shininess rămâne 0 pentru obiectul original."}
                ]
            },
            {
                id: 8,
                text: "Care instanțiere este corectă?",
                code: null,
                options: [
                    "List<Integer> list = new ArrayList<Object>();",
                    "ArrayList<Integer> list = new List<Integer>();",
                    "List<Integer> list = new ArrayList<Integer>();",
                    "ArrayList<Object> list = new ArrayList<Integer>();"
                ],
                answers: [
                    {isCorrect: false, explanation: "Greșit. Genericele trebuie să fie identice (invariant), nu poți pune ArrayList<Object> într-o referință de List<Integer>."},
                    {isCorrect: false, explanation: "Greșit. List este o interfață și nu poate fi instanțiată direct cu 'new List()'."},
                    {isCorrect: true, explanation: "Corect. Se folosește interfața ca tip de referință și clasa concretă pentru instanțiere, cu tipuri generice potrivite."},
                    {isCorrect: false, explanation: "Greșit. Din nou, genericele sunt invariante în Java."}
                ]
            },
            {
                id: 9,
                text: "Ce design pattern face ușoară separarea operațiilor de obiectele pe care se execută operațiile respective?",
                code: null,
                options: [
                    "Builder Pattern",
                    "Visitor Pattern",
                    "Factory Pattern",
                    "Observer Pattern"
                ],
                answers: [
                    {isCorrect: false, explanation: "Builder se ocupă de construcția obiectelor complexe."},
                    {isCorrect: true, explanation: "Corect. Visitor permite adăugarea de noi operații pe o structură de obiecte fără a modifica clasele obiectelor."},
                    {isCorrect: false, explanation: "Factory se ocupă de crearea obiectelor."},
                    {isCorrect: false, explanation: "Observer definește o dependență 1-la-mulți pentru notificări."}
                ]
            },
            {
                id: 10,
                text: "Ce design pattern trebuie să folosim în caz că dorim ca un client să nu aibă rol în crearea unui entități după o preferință de a sa?",
                code: null,
                options: [
                    "Singleton Pattern",
                    "Factory Pattern",
                    "Builder Pattern",
                    "Observer Pattern"
                ],
                answers: [
                    {isCorrect: false, explanation: "Singleton garantează o singură instanță."},
                    {isCorrect: true, explanation: "Corect. Factory Method sau Abstract Factory abstractizează procesul de instanțiere față de client."},
                    {isCorrect: false, explanation: "Builder permite clientului să controleze pașii de construcție."},
                    {isCorrect: false, explanation: "Observer este pentru comunicare între obiecte."}
                ]
            },
            {
                id: 11,
                text: "Ce fel de Singleton este această secvență de cod?",
                code: `public static Database getInstance() {
    if (obj == null) {
        obj = new Database();
    }
    return obj;
}`,
                options: [
                    "Singleton cu inițializare eager",
                    "Singleton cu inițializare lazy",
                    "nu avem Singleton aici",
                    "Singleton cu inițializare în blocuri statice"
                ],
                answers: [
                    {isCorrect: false, explanation: "Eager initialization ar crea obiectul la încărcarea clasei, nu la apelul getInstance()."},
                    {isCorrect: true, explanation: "Corect. Obiectul este creat doar atunci când este solicitat prima dată (lazy)."},
                    {isCorrect: false, explanation: "Este o implementare clasică (deși nu thread-safe) de Singleton."},
                    {isCorrect: false, explanation: "Inițializarea statică se face în afara metodei."}
                ]
            },
            {
                id: 12,
                text: "Ce metode pot fi accesate din clasa MyTest (extends Test)?",
                code: `package test;
public class Test {
    void execute1() {}
    protected void execute2() {}
    private void execute3() {}
}
// package mytest;
// MyTest extends Test`,
                options: [
                    "execute1, execute2 din Test, execute2 din MyTest",
                    "execute1, execute2 din Test, execute3, execute2 din MyTest",
                    "execute2 din Test, execute2 din MyTest",
                    "execute2 din MyTest"
                ],
                answers: [
                    {isCorrect: false, explanation: "execute1 are vizibilitate default (package-private) și nu poate fi accesată din alt pachet (mytest)."},
                    {isCorrect: false, explanation: "execute3 este private și nu se moștenește."},
                    {isCorrect: true, explanation: "Corect. Doar membrul 'protected' (execute2) este vizibil în subclasa din alt pachet."},
                    {isCorrect: false, explanation: "Include prea puține variante."}
                ]
            },
            {
                id: 13,
                text: "Ce reprezintă o metodă default în cadrul unei interfețe?",
                code: null,
                options: [
                    "o metodă abstractă",
                    "o metodă non-statică care este deja implementată într-o interfață",
                    "o metodă statică implementată într-o interfață",
                    "nu putem avea metode default într-o interfață"
                ],
                answers: [
                    {isCorrect: false, explanation: "Metodele abstracte nu au corp/implementare."},
                    {isCorrect: true, explanation: "Corect. Metodele 'default' permit adăugarea de funcționalitate în interfețe păstrând compatibilitatea retroactivă."},
                    {isCorrect: false, explanation: "Metodele statice în interfețe sunt diferite de cele default."},
                    {isCorrect: false, explanation: "Java ermode default."}
                ]
            },
            {
                id: 14,
                text: "Ce se va afișa la rularea acestui cod (Overloading/Overriding)?",
                code: `// AdobeReader extends DocumentViewer
// documentViewer referențiază new AdobeReader()
// file1 este PdfDocument
// file2 este CsvDocument
documentViewer.openDocument(file1);
documentViewer.openDocument(file2);`,
                options: [
                    "Opening document Cannot open csv",
                    "Adobe is opening pdf Cannot open csv",
                    "Adobe is opening pdf Opening csv",
                    "Opening document Opening csv"
                ],
                answers: [
                    {isCorrect: true, explanation: "Corect. Dacă AdobeReader nu suprascrie corect metodele pentru tipurile specifice sau dacă apelul este legat static la tipul DocumentViewer."},
                    {isCorrect: false, explanation: "Presupune că polimorfismul a funcționat parțial."},
                    {isCorrect: false, explanation: "Presupune că ambele metode au fost suprascrise cu succes."},
                    {isCorrect: false, explanation: "Presupune că nicio suprascriere nu a funcționat."}
                ]
            },
            {
                id: 15,
                text: "Ce se va afișa la execuția codului cu clase statice A și B?",
                code: `// A.B.write() -> prints A
// new A() -> A.write() prints C
// A.B.write() -> prints B`,
                options: [
                    "BCA",
                    "ACB",
                    "ADB",
                    "BDA"
                ],
                answers: [
                    {isCorrect: false, explanation: "Ordinea de execuție nu produce acest rezultat."},
                    {isCorrect: true, explanation: "Corect conform fluxului de execuție a metodelor statice și a instanțierii."},
                    {isCorrect: false, explanation: "D nu apare în output."},
                    {isCorrect: false, explanation: "Ordinea este inversată."}
                ]
            },
            {
                id: 16,
                text: "Ce tip de clasă reprezintă următoarea implementare?",
                code: "Predicate<Integer> check = x -> x % 2 == 0;",
                options: [
                    "clasă locală",
                    "clasă anonimă",
                    "clasă nested non-statică",
                    "clasă nested statică"
                ],
                answers: [
                    {isCorrect: false, explanation: "Clasele locale au nume și sunt definite într-un bloc."},
                    {isCorrect: true, explanation: "Corect. Expresiile Lambda sunt implementări de interfețe funcționale, similare conceptual cu clasele anonime."},
                    {isCorrect: false, explanation: "Nu este o clasă nested (inner class)."},
                    {isCorrect: false, explanation: "Nu este o clasă statică definită în altă clasă."}
                ]
            },
            {
                id: 17,
                text: "Ce va afișa programul cu string-uri?",
                code: `void first() {
    String a = "good";
    String b = second(a); // returns "luck"
    System.out.print(":" + a + b);
}`,
                options: [
                    "goodluck:goodluckluck",
                    "goodluck:goodgoodluck",
                    "goodluck:goodluck",
                    "goodluck:luckgoodluck"
                ],
                answers: [
                    {isCorrect: false, explanation: "String-urile sunt imutabile, 'a' rămâne 'good'."},
                    {isCorrect: false, explanation: "Formatarea outputului nu corespunde."},
                    {isCorrect: true, explanation: "Corect. 'a' rămâne 'good', 'b' primește rezultatul 'luck', rezultând ':goodluck'."},
                    {isCorrect: false, explanation: "Ordinea concatenării este greșită."}
                ]
            },
            {
                id: 18,
                text: "Identificați pe care linii avem suprascriere și pe care avem supraîncărcare în AudioBook implements Book.",
                code: `1. public void markRead() {} 
2. public void markToRead() {} 
3. public void markRead(int rating) {} 
4. public void markRead(int rating, Date date) {}`,
                options: [
                    "Suprascriere: 1, Supraincărcare: 3, 4",
                    "Suprascriere: 1, 2, Supraincărcare: 3, 4",
                    "Suprascriere: 3, 4, Supraincărcare: 1, 2",
                    "Suprascriere: 3, 4, Supraincărcare: 1"
                ],
                answers: [
                    {isCorrect: false, explanation: "Lipsește linia 2 de la suprascriere."},
                    {isCorrect: true, explanation: "Corect. 1 și 2 implementează metodele din interfață (suprascriere), 3 și 4 adaugă parametri noi aceleiași metode (supraîncărcare)."},
                    {isCorrect: false, explanation: "Inversiune între concepte."},
                    {isCorrect: false, explanation: "Clasificare incompletă."}
                ]
            },
            {
                id: 19,
                text: "În ce zonă de memorie sunt stocate obiectele?",
                code: null,
                options: [
                    "pe stivă",
                    "pe heap",
                    "in memoria cache",
                    "memoria externă"
                ],
                answers: [
                    {isCorrect: false, explanation: "Pe stivă (Stack) se stochează variabilele locale și apelurile de metode."},
                    {isCorrect: true, explanation: "Corect. Toate obiectele în Java sunt alocate pe Heap."},
                    {isCorrect: false, explanation: "Cache-ul este gestionat de procesor, nu direct de modelul de memorie Java."},
                    {isCorrect: false, explanation: "Memoria externă (disc) nu este folosită pentru stocarea obiectelor active."}
                ]
            },
            {
                id: 20,
                text: "Pentru ce folosim map() pe colecții și pe arrays în Java?",
                code: null,
                options: [
                    "pentru filtrare (selectare elemente)",
                    "pentru a aplica o operație pe fiecare element (transformare)",
                    "pentru a reduce elementele la unul singur",
                    "pentru a crea o copie identică"
                ],
                answers: [
                    {isCorrect: false, explanation: "Pentru filtrare se folosește metoda filter()."},
                    {isCorrect: true, explanation: "Corect. map() transformă fiecare element al fluxului într-un alt element."},
                    {isCorrect: false, explanation: "Reducerea se face cu reduce() sau collect()."},
                    {isCorrect: false, explanation: "Deși se poate folosi pentru asta, map() este destinat transformării."}
                ]
            }
        ];

        let currentScore = 0;
        let answeredCount = 0;

        function escapeHTML(str) {
            if (!str) return "";
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function renderQuiz() {
            const container = document.getElementById('quiz');
            let html = '';

            questions.forEach((q, index) => {
                let codeBlock = q.code ? `<pre><code>${escapeHTML(q.code)}</code></pre>` : '';
                let descriptionHtml = q.description ? `<div class="question-description" style="margin-bottom: 15px; white-space: pre-wrap;">${escapeHTML(q.description)}</div>` : '';

                let optionsHtml = q.options.map((opt, i) => `
                    <li class="option-item">
                        <label class="option-label" id="label-${index}-${i}">
                            <input type="radio" name="q${index}" value="${i}" onchange="checkAnswer(${index}, ${i})">
                            ${escapeHTML(opt)}
                        </label>
                    </li>
                `).join('');

                html += `
                    <div class="question-card" id="card-${index}">
                        <div class="question-text">${index + 1}. ${escapeHTML(q.text)}</div>
                        ${descriptionHtml}
                        ${codeBlock}
                        <ul class="options">${optionsHtml}</ul>
                        <div class="result-box" id="result-${index}"></div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function checkAnswer(qIndex, selectedValue) {
            const q = questions[qIndex];
            const resultBox = document.getElementById(`result-${qIndex}`);
            const labels = document.querySelectorAll(`[id^="label-${qIndex}-"]`);
            const inputs = document.querySelectorAll(`input[name="q${qIndex}"]`);

            // Disable all inputs for this question to prevent changing answer
            inputs.forEach(input => input.disabled = true);

            // Show result box
            resultBox.style.display = 'block';
            resultBox.className = 'result-box';

            const selectedAnswer = q.answers[selectedValue];

            if (selectedAnswer.isCorrect) {
                currentScore++;
                resultBox.innerHTML = "Corect!";
                resultBox.classList.add('correct-answer');
                document.getElementById(`label-${qIndex}-${selectedValue}`).classList.add('correct');
            } else {
                // Find correct answer index
                const correctIndex = q.answers.findIndex(a => a.isCorrect);
                const correctOptionText = q.options[correctIndex];

                resultBox.innerHTML = `Greșit. Varianta corectă era: "${escapeHTML(correctOptionText)}"`;
                resultBox.classList.add('wrong-answer');
                document.getElementById(`label-${qIndex}-${selectedValue}`).classList.add('incorrect');
                document.getElementById(`label-${qIndex}-${correctIndex}`).classList.add('correct');
            }

            if (selectedAnswer.explanation) {
                resultBox.innerHTML += `<div class="explanation">${escapeHTML(selectedAnswer.explanation)}</div>`;
            }

            answeredCount++;
            updateScoreDisplay();
        }

        function updateScoreDisplay() {
            const finalDiv = document.getElementById('finalScore');
            finalDiv.innerText = `Scor: ${currentScore} / ${questions.length} (Răspunsuri: ${answeredCount})`;
        }

        // Initialize
        renderQuiz();
        updateScoreDisplay();
    </script>
</body>

</html>
